/**
 *
 * Leaflet.Weather
 * 基于leaflet1.0.2的气象gis库类
 * 需匹配使用sun.js@1.0.24
 */
LW = L.Weather = {
    // version: '1.5.5',
    version: '1.5.6-alpha',

    /**
     * Update Note：
     *      + v1.4.7 ：增加workerPath和workerLibPath来配置存放worker和worker需要用到的库的跟地址
     *      + v1.5.6 ：map增加可以获取比例尺的方法
     */
    workerPath:'./worker/',

    /**
     * Update Note：
     *      + v1.5.0 ：增加icon图片地址的跟地址，并修改有引用图片的位置改为直接用这个跟地址
     */
    defaultIconPath:function () {
        var el = L.DomUtil.create('div',  'lw-default-icon-path', document.body);
        var path = L.DomUtil.getStyle(el, 'background-image') ||
            L.DomUtil.getStyle(el, 'backgroundImage');	// IE8

        document.body.removeChild(el);

        return path.indexOf('url') === 0 ?
            path.replace(/^url\([\"\']?/, '').replace(/marker\.png[\"\']?\)$/, '') : '';
    }
};

L.Map.addInitHook(function () {
    this.createPane('boundaryPane');
    this.createPane('gridPane');
    this.createPane('typPane');
});
L.Map.include({
    /**
     * 获取地图等级的比例系数
     * @method getCurrentScale
     * @returns {string}
     */
    getCurrentScale: function (){
        var pxTOmm = (function () {
            var heightRef = document.createElement('div');
            heightRef.style = 'height:1mm;display:none';
            heightRef.id = 'heightRef';
            document.body.appendChild(heightRef);

            heightRef = document.getElementById('heightRef');
            var pxPermm = $('#heightRef').height();

            heightRef.parentNode.removeChild(heightRef);

            return function _pxTOmm(px) {
                return px / pxPermm;
            }
        })();

        var centerOfMap = this.getSize().y / 2;

        var realWorldMetersPer100Pixels = this.distance(
            this.containerPointToLatLng([0, centerOfMap]),
            this.containerPointToLatLng([100, centerOfMap])
        );

        var screenMetersPer100Pixels = pxTOmm(100) / 1000;

        var scaleFactor = realWorldMetersPer100Pixels / screenMetersPer100Pixels;

        //.replace formats the scale with commas 50000 -> 50,000
        // return '1:' + Math.round(scaleFactor).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        return '1:' + Math.round(scaleFactor);
    }
});

function exposeLW() {
    var oldLW = window.LW;

    LW.noConflict = function () {
        window.LW = oldLW;
        return this;
    };

    window.LW = LW;
}

// define LW for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = LW;

// define LW as an AMD module
} else if (typeof define === 'function' && define.amd) {
    define(LW);
}

if (typeof window !== 'undefined') {
    exposeLW();
}





// 资源池 Tip:key为资源地址
LW.ResourceCache = L.Class.extend({
    imageCache:{},
    base64Cache:{},

    getImage:function (key, fn,crossOrigin) {
        var self = this;
        return new Promise(function (resolve, reject) {
            var cachedObj = self.imageCache[key];
            if (!cachedObj) {
                cachedObj = new Image();
                if (crossOrigin)
                    cachedObj.crossOrigin = 'anonymous';
                cachedObj.onload = function () {
                    self.imageCache[key] = cachedObj;
                    if(fn) fn(cachedObj);
                    else resolve(cachedObj);
                };
                cachedObj.src = key;
            }
            else{
                if(fn) fn(cachedObj);
                else resolve(cachedObj);
            }
        });
    },

    getImageBase64:function (url,fn){
        var self = this;
        var cachedObj = self.base64Cache[url];
        if (!cachedObj) {
            LW.ResourceCache.getImage(url, function (img) {
                var w = img.width, h = img.height;
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                canvas.width = w;
                canvas.height = h;
                ctx.drawImage(img, 0, 0, w, h);
                cachedObj = self.base64Cache[url] = canvas.toDataURL();
                if (fn) fn(cachedObj);
            }, true);
        }
        else {
            if (fn) fn(cachedObj);
        }
    },

    getAPng:function (key,fn){
        var self = this;
        return new Promise(function (resolve, reject) {
            var cachedObj = self.imageCache[key];
            if (!cachedObj) {
                SW.Promise.create(key, 'GET', null, 'arraybuffer').then(function (buffer) {
                    var image = UPNG.decode(buffer);
                    var rgba = UPNG.toRGBA8(image);
                    var canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    var ctx = canvas.getContext("2d");
                    var playTime = 0;
                    for (var i = 0; i < rgba.length; i++) {
                        var item = rgba[i];
                        var uArray = new Uint8ClampedArray(item);
                        var imgData = new ImageData(uArray, image.width, image.height);
                        ctx.putImageData(imgData, 0, 0);

                        var img = document.createElement("img");
                        img.src = canvas.toDataURL("image/png");
                        image.frames[i].img = img;
                        image.frames[i].data = null;
                        playTime += image.frames[i].delay;
                    }
                    image.playTime = playTime;
                    self.imageCache[key] = image;
                    if (fn) fn(image);
                    else resolve(image);
                });
            }
            else{
                if(fn) fn(cachedObj);
                else resolve(cachedObj);
            }
        });
    }
});

LW.ResourceCache = LW.ResourceCache.prototype;


// 矢量池 Tip:key为资源地址
LW.VectorCache = L.Class.extend({
    circleCache:{},
    triangleCache:{},
    rectCache:{},

    circle:function (r, fill, stroke, strokeWidth) {
        var key = r+fill+(stroke?stroke+strokeWidth:'');
        var obj = this.circleCache[key];
        if(!obj){
            obj = this.circleCache[key] = L.DomUtil.create('canvas');
            obj.width = r*4;//Tip:为了有描边的点也够绘制，所以增加了cache canvas的大小
            obj.height = r*4;
            var ctx = obj.getContext('2d');
            ctx.beginPath();
            ctx.fillStyle = fill;
            ctx.arc(r*2, r*2, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
            if(stroke){
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();
            }
        }
        return obj;
    },

    triangle:function (side, fill, stroke, strokeWidth) {
        var key = side+fill+(stroke?stroke+strokeWidth:'');
        var obj = this.triangleCache[key];
        if(!obj){
            obj = this.triangleCache[key] = L.DomUtil.create('canvas');
            obj.width = side*2;//Tip:为了有描边的点也够绘制，所以增加了cache canvas的大小
            obj.height = side*2;
            var width=side,height=Math.sqrt(Math.pow(side,2)-Math.pow(side/2,2));
            var x=side-width/2,y=side+height/2;
            var ctx = obj.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(x , y);
            ctx.lineTo(x + width, y);
            ctx.lineTo(x + width/2, y - height);
            ctx.lineTo(x, y);
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.closePath();
            if(stroke){
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();
            }
        }
        return obj;
    },


    rect:function (side, fill, stroke, strokeWidth,rotation) {
        var key = side+fill+(stroke?stroke+strokeWidth:'')+(rotation?'r'+rotation:'');
        var obj = this.rectCache[key];
        if(!obj){
            obj = this.rectCache[key] = L.DomUtil.create('canvas');
            obj.width = side*2;//Tip:为了有描边的点也够绘制，所以增加了cache canvas的大小
            obj.height = side*2;
            var ctx = obj.getContext('2d');
            if(rotation){
                ctx.translate(side, side);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.translate(-side, -side);
            }

            ctx.beginPath();
            ctx.rect(side-side/2, side-side/2, side, side);
            ctx.closePath();
            if(fill){
                ctx.fillStyle = fill;
                ctx.fill();
            }
            if(stroke){
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;
                ctx.stroke();
            }
        }
        return obj;
    }
});

LW.VectorCache = LW.VectorCache.prototype;

L.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};

/**
 * Leaflet GeometryUtil的一些扩展
 */
L.GeometryUtil = L.extend(L.GeometryUtil || {}, {

	distance: function (map, latlngA, latlngB) {
		 return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));
	},

    nceSegment: function (map, latlng, latlngA, latlngB) {
		 var p = map.latLngToLayerPoint(latlng),
			 p1 = map.latLngToLayerPoint(latlngA),
			 p2 = map.latLngToLayerPoint(latlngB);
		 return L.LineUtil.pointToSegmentDistance(p, p1, p2);
	},

	readableDistance: function (distance, unit) {
		 var isMetric = (unit !== 'imperial'),
			  distanceStr;
		 if (isMetric) {
			  // show metres when distance is < 1km, then show km
			  if (distance > 1000) {
					distanceStr = (distance  / 1000).toFixed(2) + ' km';
			  }
			  else {
					distanceStr = Math.ceil(distance) + ' m';
			  }
		 }
		 else {
			  distance *= 1.09361;
			  if (distance > 1760) {
					distanceStr = (distance / 1760).toFixed(2) + ' miles';
			  }
			  else {
					distanceStr = Math.ceil(distance) + ' yd';
			  }
		 }
		 return distanceStr;
	},

	belongsSegment: function(latlng, latlngA, latlngB, tolerance) {
		 tolerance = tolerance === undefined ? 0.2 : tolerance;
		 var hypotenuse = latlngA.distanceTo(latlngB),
			  delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;
		 return delta/hypotenuse < tolerance;
	},

	length: function (coords) {
		 var accumulated = L.GeometryUtil.accumulatedLengths(coords);
		 return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;
	},

	accumulatedLengths: function (coords) {
		 if (typeof coords.getLatLngs == 'function') {
			  coords = coords.getLatLngs();
		 }
		 if (coords.length === 0)
			  return [];
		 var total = 0,
			  lengths = [0];
		 for (var i = 0, n = coords.length - 1; i< n; i++) {
			  total += coords[i].distanceTo(coords[i+1]);
			  lengths.push(total);
		 }
		 return lengths;
	},

	closestOnSegment: function (map, latlng, latlngA, latlngB) {
		 var maxzoom = map.getMaxZoom();
		 if (maxzoom === Infinity)
			  maxzoom = map.getZoom();
		 var p = map.project(latlng, maxzoom),
			 p1 = map.project(latlngA, maxzoom),
			 p2 = map.project(latlngB, maxzoom),
			 closest = L.LineUtil.closestPointOnSegment(p, p1, p2);
		 return map.unproject(closest, maxzoom);
	},

	closest: function (map, layer, latlng, vertices) {

		 var latlngs,
			  mindist = Infinity,
			  result = null,
			  i, n, distance, subResult;

		 if (layer instanceof Array) {
			  // if layer is Array<Array<T>>
			  if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {
					// if we have nested arrays, we calc the closest for each array
					// recursive
					for (i = 0; i < layer.length; i++) {
						 subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);
						 if (subResult && subResult.distance < mindist) {
							  mindist = subResult.distance;
							  result = subResult;
						 }
					}
					return result;
			  } else if (layer[0] instanceof L.LatLng
							  || typeof layer[0][0] === 'number'
							  || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}
					layer = L.polyline(layer);
			  } else {
					return result;
			  }
		 }

		 // if we don't have here a Polyline, that means layer is incorrect
		 // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23
		 if (! ( layer instanceof L.Polyline ) )
			  return result;

		 // deep copy of latlngs
		 latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));

		 // add the last segment for L.Polygon
		 if (layer instanceof L.Polygon) {
			  // add the last segment for each child that is a nested array
			  var addLastSegment = function(latlngs) {
					if (L.Polyline._flat(latlngs)) {
						 latlngs.push(latlngs[0]);
					} else {
						 for (var i = 0; i < latlngs.length; i++) {
							  addLastSegment(latlngs[i]);
						 }
					}
			  };
			  addLastSegment(latlngs);
		 }

		 // we have a multi polygon / multi polyline / polygon with holes
		 // use recursive to explore and return the good result
		 if ( ! L.Polyline._flat(latlngs) ) {
			  for (i = 0; i < latlngs.length; i++) {
					// if we are at the lower level, and if we have a L.Polygon, we add the last segment
					subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);
					if (subResult.distance < mindist) {
						 mindist = subResult.distance;
						 result = subResult;
					}
			  }
			  return result;

		 } else {

			  // Lookup vertices
			  if (vertices) {
					for(i = 0, n = latlngs.length; i < n; i++) {
						 var ll = latlngs[i];
						 distance = L.GeometryUtil.distance(map, latlng, ll);
						 if (distance < mindist) {
							  mindist = distance;
							  result = ll;
							  result.distance = distance;
						 }
					}
					return result;
			  }

			  // Keep the closest point of all segments
			  for (i = 0, n = latlngs.length; i < n-1; i++) {
					var latlngA = latlngs[i],
						 latlngB = latlngs[i+1];
					distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);
					if (distance <= mindist) {
						 mindist = distance;
						 result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);
						 result.distance = distance;
					}
			  }
			  return result;
		 }

	},

	closestLayer: function (map, layers, latlng) {
		 var mindist = Infinity,
			  result = null,
			  ll = null,
			  distance = Infinity;

		 for (var i = 0, n = layers.length; i < n; i++) {
			  var layer = layers[i];
			  if (layer instanceof L.LayerGroup) {
					// recursive
					var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);
					if (subResult.distance < mindist) {
						 mindist = subResult.distance;
						 result = subResult;
					}
			  } else {
					// Single dimension, snap on points, else snap on closest
					if (typeof layer.getLatLng == 'function') {
						 ll = layer.getLatLng();
						 distance = L.GeometryUtil.distance(map, latlng, ll);
					}
					else {
						 ll = L.GeometryUtil.closest(map, layer, latlng);
						 if (ll) distance = ll.distance;  // Can return null if layer has no points.
					}
					if (distance < mindist) {
						 mindist = distance;
						 result = {layer: layer, latlng: ll, distance: distance};
					}
			  }
		 }
		 return result;
	},

	nClosestLayers: function (map, layers, latlng, n) {
		 n = typeof n === 'number' ? n : layers.length;

		 if (n < 1 || layers.length < 1) {
			  return null;
		 }

		 var results = [];
		 var distance, ll;

		 for (var i = 0, m = layers.length; i < m; i++) {
			  var layer = layers[i];
			  if (layer instanceof L.LayerGroup) {
					// recursive
					var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);
					results.push(subResult);
			  } else {
					// Single dimension, snap on points, else snap on closest
					if (typeof layer.getLatLng == 'function') {
						 ll = layer.getLatLng();
						 distance = L.GeometryUtil.distance(map, latlng, ll);
					}
					else {
						 ll = L.GeometryUtil.closest(map, layer, latlng);
						 if (ll) distance = ll.distance;  // Can return null if layer has no points.
					}
					results.push({layer: layer, latlng: ll, distance: distance});
			  }
		 }

		 results.sort(function(a, b) {
			  return a.distance - b.distance;
		 });

		 if (results.length > n) {
			  return results.slice(0, n);
		 } else  {
			  return results;
		 }
	},

	layersWithin: function(map, layers, latlng, radius) {
	  radius = typeof radius == 'number' ? radius : Infinity;

	  var results = [];
	  var ll = null;
	  var distance = 0;

	  for (var i = 0, n = layers.length; i < n; i++) {
		 var layer = layers[i];

		 if (typeof layer.getLatLng == 'function') {
			  ll = layer.getLatLng();
			  distance = L.GeometryUtil.distance(map, latlng, ll);
		 }
		 else {
			  ll = L.GeometryUtil.closest(map, layer, latlng);
			  if (ll) distance = ll.distance;  // Can return null if layer has no points.
		 }

		 if (ll && distance < radius) {
			  results.push({layer: layer, latlng: ll, distance: distance});
		 }
	  }

	  var sortedResults = results.sort(function(a, b) {
			return a.distance - b.distance;
	  });

	  return sortedResults;
	},

	closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {
		 tolerance = typeof tolerance == 'number' ? tolerance : Infinity;
		 withVertices = typeof withVertices == 'boolean' ? withVertices : true;

		 var result = L.GeometryUtil.closestLayer(map, layers, latlng);
		 if (!result || result.distance > tolerance)
			  return null;

		 // If snapped layer is linear, try to snap on vertices (extremities and middle points)
		 if (withVertices && typeof result.layer.getLatLngs == 'function') {
			  var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);
			  if (closest.distance < tolerance) {
					result.latlng = closest;
					result.distance = L.GeometryUtil.distance(map, closest, latlng);
			  }
		 }
		 return result;
	},

	interpolateOnPointSegment: function (pA, pB, ratio) {
		 return L.point(
			  (pA.x * (1 - ratio)) + (ratio * pB.x),
			  (pA.y * (1 - ratio)) + (ratio * pB.y)
		 );
	},

	interpolateOnLine: function (map, latLngs, ratio) {
		 latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;
		 var n = latLngs.length;
		 if (n < 2) {
			  return null;
		 }

		 // ensure the ratio is between 0 and 1;
		 ratio = Math.max(Math.min(ratio, 1), 0);

		 if (ratio === 0) {
			  return {
					latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),
					predecessor: -1
			  };
		 }
		 if (ratio == 1) {
			  return {
					latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),
					predecessor: latLngs.length - 2
			  };
		 }

		 // project the LatLngs as Points,
		 // and compute total planar length of the line at max precision
		 var maxzoom = map.getMaxZoom();
		 if (maxzoom === Infinity)
			  maxzoom = map.getZoom();
		 var pts = [];
		 var lineLength = 0;
		 for(var i = 0; i < n; i++) {
			  pts[i] = map.project(latLngs[i], maxzoom);
			  if(i > 0)
				 lineLength += pts[i-1].distanceTo(pts[i]);
		 }

		 var ratioDist = lineLength * ratio;

	  // follow the line segments [ab], adding lengths,
		 // until we find the segment where the points should lie on
	  var cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;
	  for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {
		  var pointA = pts[i], pointB = pts[i+1];

		  cumulativeDistanceToA = cumulativeDistanceToB;
		  cumulativeDistanceToB += pointA.distanceTo(pointB);
	  }

	  if (pointA == undefined && pointB == undefined) { // Happens when line has no length
		  var pointA = pts[0], pointB = pts[1], i = 1;
	  }

	  // compute the ratio relative to the segment [ab]
	  var segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;
	  var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);
	  return {
		  latLng: map.unproject(interpolatedPoint, maxzoom),
		  predecessor: i-1
	  };
	},

	locateOnLine: function (map, polyline, latlng) {
		 var latlngs = polyline.getLatLngs();
		 if (latlng.equals(latlngs[0]))
			  return 0.0;
		 if (latlng.equals(latlngs[latlngs.length-1]))
			  return 1.0;

		 var point = L.GeometryUtil.closest(map, polyline, latlng, false),
			  lengths = L.GeometryUtil.accumulatedLengths(latlngs),
			  total_length = lengths[lengths.length-1],
			  portion = 0,
			  found = false;
		 for (var i=0, n = latlngs.length-1; i < n; i++) {
			  var l1 = latlngs[i],
					l2 = latlngs[i+1];
			  portion = lengths[i];
			  if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.0001)) {
					portion += l1.distanceTo(point);
					found = true;
					break;
			  }
		 }
		 if (!found) {
			  throw "Could not interpolate " + latlng.toString() + " within " + polyline.toString();
		 }
		 return portion / total_length;
	},

	reverse: function (polyline) {
		 return L.polyline(polyline.getLatLngs().slice(0).reverse());
	},

	extract: function (map, polyline, start, end) {
		 if (start > end) {
			  return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);
		 }

		 // Bound start and end to [0-1]
		 start = Math.max(Math.min(start, 1), 0);
		 end = Math.max(Math.min(end, 1), 0);

		 var latlngs = polyline.getLatLngs(),
			  startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),
			  endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);
		 // Return single point if start == end
		 if (start == end) {
			  var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);
			  return [point.latLng];
		 }
		 // Array.slice() works indexes at 0
		 if (startpoint.predecessor == -1)
			  startpoint.predecessor = 0;
		 if (endpoint.predecessor == -1)
			  endpoint.predecessor = 0;
		 var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);
		 result.unshift(startpoint.latLng);
		 result.push(endpoint.latLng);
		 return result;
	},

	isBefore: function (polyline, other) {
		 if (!other) return false;
		 var lla = polyline.getLatLngs(),
			  llb = other.getLatLngs();
		 return (lla[lla.length-1]).equals(llb[0]);
	},

	isAfter: function (polyline, other) {
		 if (!other) return false;
		 var lla = polyline.getLatLngs(),
			  llb = other.getLatLngs();
		 return (lla[0]).equals(llb[llb.length-1]);
	},

	startsAtExtremity: function (polyline, other) {
		 if (!other) return false;
		 var lla = polyline.getLatLngs(),
			  llb = other.getLatLngs(),
			  start = lla[0];
		 return start.equals(llb[0]) || start.equals(llb[llb.length-1]);
	},

	computeAngle: function(a, b) {
		 return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);
	},

	computeSlope: function(a, b) {
		 var s = (b.y - a.y) / (b.x - a.x),
			  o = a.y - (s * a.x);
		 return {'a': s, 'b': o};
	},

	rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {
		 var maxzoom = map.getMaxZoom();
		 if (maxzoom === Infinity)
			  maxzoom = map.getZoom();
		 var angleRad = angleDeg*Math.PI/180,
			  pPoint = map.project(latlngPoint, maxzoom),
			  pCenter = map.project(latlngCenter, maxzoom),
			  x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,
			  y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;
		 return map.unproject(new L.Point(x2,y2), maxzoom);
	},

	bearing: function(latlng1, latlng2, is360) {
		 var rad = Math.PI / 180,
			  lat1 = latlng1.lat * rad,
			  lat2 = latlng2.lat * rad,
			  lon1 = latlng1.lng * rad,
			  lon2 = latlng2.lng * rad,
			  y = Math.sin(lon2 - lon1) * Math.cos(lat2),
			  x = Math.cos(lat1) * Math.sin(lat2) -
					Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

		 var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
		 return bearing <= 180 || is360 ? bearing : bearing-360;
	},

	destination: function(latlng, heading, distance) {
		 heading = (heading + 360) % 360;
		 var rad = Math.PI / 180,
			  radInv = 180 / Math.PI,
			  R = 6378137, // approximation of Earth's radius
			  lon1 = latlng.lng * rad,
			  lat1 = latlng.lat * rad,
			  rheading = heading * rad,
			  sinLat1 = Math.sin(lat1),
			  cosLat1 = Math.cos(lat1),
			  cosDistR = Math.cos(distance / R),
			  sinDistR = Math.sin(distance / R),
			  lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *
					sinDistR * Math.cos(rheading)),
			  lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *
					cosLat1, cosDistR - sinLat1 * Math.sin(lat2));
		 lon2 = lon2 * radInv;
		 lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;
		 return L.latLng([lat2 * radInv, lon2]);
	},

	angle: function(map, latlngA, latlngB) {
	  var pointA = map.latLngToContainerPoint(latlngA),
			pointB = map.latLngToContainerPoint(latlngB),
			angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;
	  angleDeg += angleDeg < 0 ? 360 : 0;
	  return angleDeg;
	},

	destinationOnSegment: function(map, latlngA, latlngB, distance) {
	  var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),
			latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);
	  return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);
	},

    latLng2Mercator : function(lnglat) {
        var PI = 3.141592653589793;
        var lng = Number(lnglat[0]), lat = Number(lnglat[1]),
            x = 20037508.34 * lng / 180,
            y = Math.log(Math.tan((90 + lat) * PI / 360)) / (PI / 180);
        return y = 20037508.34 * y / 180,
            [x = Number(x.toFixed(2)), y = Number(y.toFixed(2))];
    },
    mercator2LatLng  : function(lnglat) {
        var PI = 3.141592653589793;
        var x = Number(lnglat[0]) / 20037508.34 * 180,
            y = Number(lnglat[1]) / 20037508.34 * 180;
        return y = 180 / PI * (2 * Math.atan(Math.exp(y * PI / 180)) - PI / 2),
            [x = Number(x.toFixed(6)), y = Number(y.toFixed(6))];
    },
    baseDistance : function(t, o) {
        return Math.sqrt(Math.pow(t[0] - o[0], 2) + Math.pow(t[1] - o[1], 2))
    },
    isClockWise : function(t, o, e) {
        return (e[1] - t[1]) * (o[0] - t[0]) > (o[1] - t[1]) * (e[0] - t[0])
    },
    getNormal : function(t, o, e) {
        var r = t[0] - o[0],
            n = t[1] - o[1],
            g = Math.sqrt(r * r + n * n);
        r /= g, n /= g;
        var i = e[0] - o[0],
            s = e[1] - o[1],
            a = Math.sqrt(i * i + s * s);
        i /= a, s /= a;
        var l = r + i,
            u = n + s;
        return [l, u]
    },
    getBisectorNormals : function(t, o, e, r) {
        const ZERO_TOLERANCE =  1e-4
        var n = L.GeometryUtil.getNormal(o, e, r),
            g = Math.sqrt(n[0] * n[0] + n[1] * n[1]),
            i = n[0] / g,
            s = n[1] / g,
            a = L.GeometryUtil.baseDistance(o, e),
            l = L.GeometryUtil.baseDistance(e, r);
        if (g > ZERO_TOLERANCE) if (L.GeometryUtil.isClockWise(o, e, r)) {
            var u = t * a,
                c = e[0] - u * s,
                p = e[1] + u * i,
                h = [c, p];
            u = t * l, c = e[0] + u * s, p = e[1] - u * i;
            var d = [c, p]
        } else u = t * a, c = e[0] + u * s, p = e[1] - u * i, h = [c, p], u = t * l, c = e[0] - u * s, p = e[1] + u * i, d = [c, p];
        else c = e[0] + t * (o[0] - e[0]), p = e[1] + t * (o[1] - e[1]), h = [c, p], c = e[0] + t * (r[0] - e[0]), p = e[1] + t * (r[1] - e[1]), d = [c, p];
        return [h, d]
    },
    getCubicValue : function(t, o, e, r, n) {
        t = Math.max(Math.min(t, 1), 0);
        var g = 1 - t,
            i = t * t,
            s = i * t,
            a = g * g,
            l = a * g,
            u = l * o[0] + 3 * a * t * e[0] + 3 * g * i * r[0] + s * n[0],
            c = l * o[1] + 3 * a * t * e[1] + 3 * g * i * r[1] + s * n[1];
        return [u, c]
    },

    /**
     * 根据折线获取过控制点的曲线点集，首尾点不必相同
     * @param latlngs {Array} [[lng,lat]...]
     * @param closed {Boolean} 是否是闭合曲线，默认：true
     * @param t {Number} 曲度系数，默认：0.2
     * @returns {*[]}
     */
    getCurvePoints: function (latlngs,closed,t){
        if(latlngs.length < 3) return latlngs;
        closed = typeof closed == 'undefined' ? true : closed;
        t = t || 0.3;
        coords = latlngs.map(function (l){
            return L.GeometryUtil.latLng2Mercator(l);
        });
        coords.push(coords[0], coords[1]);
        for (var arr1 = [], arr2 = [], i = 0; i < coords.length - 2; i++) {
            var bisectorNormals = L.GeometryUtil.getBisectorNormals(t, coords[i], coords[i + 1], coords[i + 2]);
            arr1 = arr1.concat(bisectorNormals);
        }
        var len = arr1.length;
        arr1 = [arr1[len - 1]].concat(arr1.slice(0, len - 1));
        var count = closed ? (coords.length - 2) : (coords.length - 3);
        for (var j = 0; j < count; j++) {
            var p1 = coords[j], p2 = coords[j + 1];
            arr2.push(p1);
            for (var k = 0; k <= 100; k++) {
                var cubicValue = L.GeometryUtil.getCubicValue(k / 100, p1, arr1[2 * j], arr1[2 * j + 1], p2);
                arr2.push(cubicValue);
            }
            arr2.push(p2);
        }
        if(closed) arr2.push(arr2[0]);
        return arr2.map(function (c){
            return L.GeometryUtil.mercator2LatLng(c);
        });
    }
});


var UPNG = {};


UPNG.toRGBA8 = function(out)
{
    var w = out.width, h = out.height;
    if(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];

    var frms = [];
    if(out.frames[0].data==null) out.frames[0].data = out.data;

    var len = w*h*4, img = new Uint8Array(len), empty = new Uint8Array(len), prev=new Uint8Array(len);
    for(var i=0; i<out.frames.length; i++)
    {
        var frm = out.frames[i];
        var fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
        var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);

        if(i!=0) for(var j=0; j<len; j++) prev[j]=img[j];

        if     (frm.blend==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
        else if(frm.blend==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);

        frms.push(img.buffer.slice(0));

        if     (frm.dispose==0) {}
        else if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
        else if(frm.dispose==2) for(var j=0; j<len; j++) img[j]=prev[j];
    }
    return frms;
}
UPNG.toRGBA8.decodeImage = function(data, w, h, out)
{
    var area = w*h, bpp = UPNG.decode._getBPP(out);
    var bpl = Math.ceil(w*bpp/8);	// bytes per line

    var bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);
    var ctype = out.ctype, depth = out.depth;
    var rs = UPNG._bin.readUshort;

    //console.log(ctype, depth);
    var time = Date.now();

    if     (ctype==6) { // RGB + alpha
        var qarea = area<<2;
        if(depth== 8) for(var i=0; i<qarea;i+=4) {  bf[i] = data[i];  bf[i+1] = data[i+1];  bf[i+2] = data[i+2];  bf[i+3] = data[i+3]; }
        if(depth==16) for(var i=0; i<qarea;i++ ) {  bf[i] = data[i<<1];  }
    }
    else if(ctype==2) {	// RGB
        var ts=out.tabs["tRNS"];
        if(ts==null) {
            if(depth== 8) for(var i=0; i<area; i++) {  var ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];  }
            if(depth==16) for(var i=0; i<area; i++) {  var ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];  }
        }
        else {  var tr=ts[0], tg=ts[1], tb=ts[2];
            if(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];
                if(data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }
            if(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];
                if(rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }
        }
    }
    else if(ctype==3) {	// palette
        var p=out.tabs["PLTE"], ap=out.tabs["tRNS"], tl=ap?ap.length:0;
        //console.log(p, ap);
        if(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;
            for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
        }
        if(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;
            for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
        }
        if(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;
            for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
        }
        if(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }
    }
    else if(ctype==4) {	// gray + alpha
        if(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }
        if(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }
    }
    else if(ctype==0) {	// gray
        var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
        for(var y=0; y<h; y++) {
            var off = y*bpl, to = y*w;
            if     (depth== 1) for(var x=0; x<w; x++) {  var gr=255*((data[off+(x>>>3)]>>>(7 -((x&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
            else if(depth== 2) for(var x=0; x<w; x++) {  var gr= 85*((data[off+(x>>>2)]>>>(6 -((x&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
            else if(depth== 4) for(var x=0; x<w; x++) {  var gr= 17*((data[off+(x>>>1)]>>>(4 -((x&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
            else if(depth== 8) for(var x=0; x<w; x++) {  var gr=data[off+     x], al=(gr                 ==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
            else if(depth==16) for(var x=0; x<w; x++) {  var gr=data[off+(x<<1)], al=(rs(data,off+(x<<i))==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }
        }
    }
    //console.log(Date.now()-time);
    return bf;
}


UPNG.decode = function(buff)
{
    var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
    var out = {tabs:{}, frames:[]};
    var dd = new Uint8Array(data.length), doff = 0;	 // put all IDAT data into it
    var fd, foff = 0;	// frames

    var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
    for(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw "The input is not a PNG file!";

    while(offset<data.length)
    {
        var len  = bin.readUint(data, offset);  offset += 4;
        var type = bin.readASCII(data, offset, 4);  offset += 4;
        //console.log(type,len);

        if     (type=="IHDR")  {  UPNG.decode._IHDR(data, offset, out);  }
        else if(type=="CgBI")  {  out.tabs[type] = data.slice(offset,offset+4);  }
        else if(type=="IDAT") {
            for(var i=0; i<len; i++) dd[doff+i] = data[offset+i];
            doff += len;
        }
        else if(type=="acTL")  {
            out.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };
            fd = new Uint8Array(data.length);
        }
        else if(type=="fcTL")  {
            if(foff!=0) {  var fr = out.frames[out.frames.length-1];
                fr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;
            }
            var rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};
            var del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);
            var frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};
            //console.log(frm);
            out.frames.push(frm);
        }
        else if(type=="fdAT") {
            for(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];
            foff += len-4;
        }
        else if(type=="pHYs") {
            out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];
        }
        else if(type=="cHRM") {
            out.tabs[type] = [];
            for(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));
        }
        else if(type=="tEXt" || type=="zTXt") {
            if(out.tabs[type]==null) out.tabs[type] = {};
            var nz = bin.nextZero(data, offset);
            var keyw = bin.readASCII(data, offset, nz-offset);
            var text, tl=offset+len-nz-1;
            if(type=="tEXt") text = bin.readASCII(data, nz+1, tl);
            else {
                var bfr = UPNG.decode._inflate(data.slice(nz+2,nz+2+tl));
                text = bin.readUTF8(bfr,0,bfr.length);
            }
            out.tabs[type][keyw] = text;
        }
        else if(type=="iTXt") {
            if(out.tabs[type]==null) out.tabs[type] = {};
            var nz = 0, off = offset;
            nz = bin.nextZero(data, off);
            var keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;
            var cflag = data[off], cmeth = data[off+1];  off+=2;
            nz = bin.nextZero(data, off);
            var ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;
            nz = bin.nextZero(data, off);
            var tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;
            var text, tl=len-(off-offset);
            if(cflag==0) text  = bin.readUTF8(data, off, tl);
            else {
                var bfr = UPNG.decode._inflate(data.slice(off,off+tl));
                text = bin.readUTF8(bfr,0,bfr.length);
            }
            out.tabs[type][keyw] = text;
        }
        else if(type=="PLTE") {
            out.tabs[type] = bin.readBytes(data, offset, len);
        }
        else if(type=="hIST") {
            var pl = out.tabs["PLTE"].length/3;
            out.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));
        }
        else if(type=="tRNS") {
            if     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);
            else if(out.ctype==0) out.tabs[type] = rUs(data, offset);
            else if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];
            //else console.log("tRNS for unsupported color type",out.ctype, len);
        }
        else if(type=="gAMA") out.tabs[type] = bin.readUint(data, offset)/100000;
        else if(type=="sRGB") out.tabs[type] = data[offset];
        else if(type=="bKGD")
        {
            if     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];
            else if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];
            else if(out.ctype==3) out.tabs[type] = data[offset];
        }
        else if(type=="IEND") {
            break;
        }
        //else {  log("unknown chunk type", type, len);  }
        offset += len;
        var crc = bin.readUint(data, offset);  offset += 4;
    }
    if(foff!=0) {  var fr = out.frames[out.frames.length-1];
        fr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;
    }
    out.data = UPNG.decode._decompress(out, dd, out.width, out.height);

    delete out.compress;  delete out.interlace;  delete out.filter;
    return out;
}

UPNG.decode._decompress = function(out, dd, w, h) {
    var time = Date.now();
    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), buff = new Uint8Array((bpl+1+out.interlace)*h);
    if(out.tabs["CgBI"]) dd = UPNG.inflateRaw(dd,buff);
    else                 dd = UPNG.decode._inflate(dd,buff);
    //console.log(dd.length, buff.length);
    //console.log(Date.now()-time);

    var time=Date.now();
    if     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);
    else if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);
    //console.log(Date.now()-time);
    return dd;
}

UPNG.decode._inflate = function(data, buff) {  var out=UPNG["inflateRaw"](new Uint8Array(data.buffer, 2,data.length-6),buff);  return out;  }
UPNG.inflateRaw=function(){var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;
    if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;
    if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);
        var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;
        w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;
        h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;
                                                                                                        c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;
        d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);
        I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;
        if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);
        d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};
    H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};
    H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;
        if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);
            n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;
        while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};
    H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;
        var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];
            b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);
        while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;
                                                                                                 n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};
    H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};
    H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};
    H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;
        return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();
    (function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;
        V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;
        N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];
        N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);
        H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);
        n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()


UPNG.decode._readInterlace = function(data, out)
{
    var w = out.width, h = out.height;
    var bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);
    var img = new Uint8Array( h * bpl );
    var di = 0;

    var starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];
    var starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];
    var row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];
    var col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];

    var pass=0;
    while(pass<7)
    {
        var ri = row_increment[pass], ci = col_increment[pass];
        var sw = 0, sh = 0;
        var cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }
        var cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }
        var bpll = Math.ceil(sw*bpp/8);
        UPNG.decode._filterZero(data, out, di, sw, sh);

        var y=0, row = starting_row[pass];
        while(row<h)
        {
            var col = starting_col[pass];
            var cdi = (di+y*bpll)<<3;

            while(col<w)
            {
                if(bpp==1) {
                    var val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;
                    img[row*bpl + (col>>3)] |= (val << (7-((col&7)<<0)));
                }
                if(bpp==2) {
                    var val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;
                    img[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));
                }
                if(bpp==4) {
                    var val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;
                    img[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));
                }
                if(bpp>=8) {
                    var ii = row*bpl+col*cbpp;
                    for(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];
                }
                cdi+=bpp;  col+=ci;
            }
            y++;  row += ri;
        }
        if(sw*sh!=0) di += sh * (1 + bpll);
        pass = pass + 1;
    }
    return img;
}

UPNG.decode._getBPP = function(out) {
    var noc = [1,null,3,1,2,null,4][out.ctype];
    return noc * out.depth;
}

UPNG.decode._filterZero = function(data, out, off, w, h)
{
    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;
    bpp = Math.ceil(bpp/8);

    var i=0, di=1, type=data[off], x=0;

    if(type>1) data[off]=[0,0,1][type-2];
    if(type==3) for(x=bpp; x<bpl; x++) data[x+1] = (data[x+1] + (data[x+1-bpp]>>>1) )&255;

    for(var y=0; y<h; y++)  {
        i = off+y*bpl; di = i+y+1;
        type = data[di-1]; x=0;

        if     (type==0)   for(; x<bpl; x++) data[i+x] = data[di+x];
        else if(type==1) { for(; x<bpp; x++) data[i+x] = data[di+x];
            for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp]);  }
        else if(type==2) { for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl]);  }
        else if(type==3) { for(; x<bpp; x++) data[i+x] = (data[di+x] + ( data[i+x-bpl]>>>1));
            for(; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>>1) );  }
        else             { for(; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0));
            for(; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) );  }
    }
    return data;
}

UPNG.decode._paeth = function(a,b,c)
{
    var p = a+b-c, pa = (p-a), pb = (p-b), pc = (p-c);
    if (pa*pa <= pb*pb && pa*pa <= pc*pc)  return a;
    else if (pb*pb <= pc*pc)  return b;
    return c;
}

UPNG.decode._IHDR = function(data, offset, out)
{
    var bin = UPNG._bin;
    out.width  = bin.readUint(data, offset);  offset += 4;
    out.height = bin.readUint(data, offset);  offset += 4;
    out.depth     = data[offset];  offset++;
    out.ctype     = data[offset];  offset++;
    out.compress  = data[offset];  offset++;
    out.filter    = data[offset];  offset++;
    out.interlace = data[offset];  offset++;
}

UPNG._bin = {
    nextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },
    readUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },
    writeUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },
    readUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },
    writeUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },
    readASCII  : function(buff,p,l){  var s = "";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },
    writeASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },
    readBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },
    pad : function(n) { return n.length < 2 ? "0" + n : n; },
    readUTF8 : function(buff, p, l) {
        var s = "", ns;
        for(var i=0; i<l; i++) s += "%" + UPNG._bin.pad(buff[p+i].toString(16));
        try {  ns = decodeURIComponent(s); }
        catch(e) {  return UPNG._bin.readASCII(buff, p, l);  }
        return  ns;
    }
}
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)
{
    var w = Math.min(sw,tw), h = Math.min(sh,th);
    var si=0, ti=0;
    for(var y=0; y<h; y++)
        for(var x=0; x<w; x++)
        {
            if(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }
            else                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }

            if     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }
            else if(mode==1) {
                var fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa;
                var ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba;

                var ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);
                tb[ti+3] = 255*oa;
                tb[ti+0] = (fr+br*ifa)*ioa;
                tb[ti+1] = (fg+bg*ifa)*ioa;
                tb[ti+2] = (fb+bb*ifa)*ioa;
            }
            else if(mode==2){	// copy only differences, otherwise zero
                var fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2];
                var ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2];
                if(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }
                else {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }
            }
            else if(mode==3){	// check if can be blended
                var fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2];
                var ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2];
                if(fa==ba && fr==br && fg==bg && fb==bb) continue;
                //if(fa!=255 && ba!=0) return false;
                if(fa<220 && ba>20) return false;
            }
        }
    return true;
}

/**
 * 一些Gis可视化效果的集成
 *
 * Features :
 *      1. 渐变效果
 *      2. 发光效果
 *      3. 呼吸灯效果
 *
 * Update Note :
 *      + v1.5.5 : Created
 *      + v1.5.6 : 1. 增加设置填充模式方法-setPattern
 *                 2. 增加获取buffer ring方法-getBufferRings
 *
 * @class LW.Effect
 * @extends  L.Class
 * @constructor
 * @demo demo/effect/geo_shadow_gradient.html  {边界投影+渐变}
 * @demo demo/effect/geoBufferOuter.html  {buffer外框}
 * @demo demo/effect/tileMask_shadow.html  {瓦片遮罩+投影}
 * @demo demo/effect/geoGlow.html  {边界发光+呼吸灯}
 */
LW.Effect = L.Class.extend({
    defs:null,
    mapID:'map',

    getDefs:function (){
        if(!LW.Effect.defs){
            var svg = L.SVG.create('svg');
            svg.style.width = 0;
            var container = document.getElementById(LW.Effect.mapID) || document.body;
            container.appendChild(svg);
            LW.Effect.defs = svg.appendChild(L.SVG.create("defs"));
        }

        return LW.Effect.defs;
    },

    addStyle:function (style){
        var style1 = document.createElement('style');
        style1.innerHTML = style;
        document.head.appendChild(style1);
    },

    setAttributes:function (target,attributes){
        for(var key in attributes){
            target.setAttribute(key,attributes[key]);
        }
    },

    /**
     * 设置svg现象渐变
     * @param name {String} 效果名
     * @param colors {Array.<offset,color,opacity>} 渐变颜色
     *                      eg:[{offset:0,color:'#092259',opacity:1},
     *                          {offset:100,color:'#145cc9',opacity:1}]
     */
    setLinearGradient:function (name,colors){
        var defs = LW.Effect.getDefs();
        var grd = defs.appendChild(L.SVG.create("linearGradient"));
        LW.Effect.setAttributes(grd,{id:name, x1:"0%", y1:"0%", x2:"0%", y2:"100%"});
        for(var i=0;i<colors.length;i++){
            var item = colors[i];
            var stop = grd.appendChild(L.SVG.create("stop"));
            LW.Effect.setAttributes(stop,{offset:item.offset+'%',
                style:"stop-color:{0};stop-opacity:{1};".format(item.color,item.opacity||1)});
        }
    },

    /**
     * 设置svg外发光效果
     * @param name {String} 效果名
     * @param deviation {偏差} [option]
     */
    setOuterBlur:function (name,deviation){
        var defs = LW.Effect.getDefs();
        var filter = defs.appendChild(L.SVG.create("filter"));
        LW.Effect.setAttributes(filter,{id:name,x:"-10%",y:"-10%",width:"120%",height:"120%"});
        var blur = filter.appendChild(L.SVG.create("feGaussianBlur"));
        deviation = deviation || 4;
        LW.Effect.setAttributes(blur,{result:'blurOut',in:"SourceGraphic",stdDeviation:deviation});
        LW.Effect.addStyle('.{0} {filter: url(#{0});}'.format(name));
    },

    /**
     * 设置填充模式
     * @param type type :
     *      1. r_bias: 右斜线
     *      2. l_bias: 左斜线
     *      3. h_line: 横线
     *      4. v_line: 竖线
     * @param id
     * @param options {width,color,strokeWidth,fill}
     * @param defs
     */
    setPattern:function (type,id,options,defs){
        var patternFn= {
            'r_bias':function (pat,a,options) {
                if(options.fill) pat.appendChild(createRect(a,options.fill));
                var line1 = createLine(0,a,a,0,options.stroke,options.strokeWidth);
                pat.appendChild(line1);
                var line2 = createLine(-1,1,1,-1,options.stroke,options.strokeWidth);
                pat.appendChild(line2);
                var line3 = createLine(a-1,a+1,a+1,a-1,options.stroke,options.strokeWidth);
                pat.appendChild(line3);
            },
            'l_bias':function (pat,a,options) {
                if(options.fill) pat.appendChild(createRect(a,options.fill));
                var line1 = createLine(0,0,a,a,options.stroke,options.strokeWidth);
                pat.appendChild(line1);
                var line2 = createLine(-1,a-1,1,a+1,options.stroke,options.strokeWidth);
                pat.appendChild(line2);
                var line3 = createLine(a-1,-1,a+1,1,options.stroke,options.strokeWidth);
                pat.appendChild(line3);
            },
            'h_line': function(pat,a,options) {
                if(options.fill) pat.appendChild(createRect(a,options.fill));
                var line1 = createLine(0,a/2,a,a/2,options.stroke,options.strokeWidth);
                pat.appendChild(line1);
            },
            'v_line': function(pat,a,options) {
                if(options.fill) pat.appendChild(createRect(a,options.fill));
                var line1 = createLine(a/2,0,a/2,a,options.stroke,options.strokeWidth);
                pat.appendChild(line1);
            },

            createLine: function (x1, y1, x2, y2,color,strokeWidth) {
                var line = L.SVG.create('line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', strokeWidth);
                return line;
            },

            createRect: function (w,color){
                var rect = L.SVG.create('rect');
                rect.setAttribute('width', w);
                rect.setAttribute('height', w);
                rect.setAttribute('fill', color);
                return rect;
            }
        };

        if(patternFn.hasOwnProperty(type)){
            var defs = defs || LW.Effect.getDefs();
            var a = options.width || 10;
            var pat = L.SVG.create('pattern');
            pat.setAttribute('id', id);
            pat.setAttribute('width', a);
            pat.setAttribute('height', a);
            pat.setAttribute('patternUnits', 'userSpaceOnUse');
            defs.appendChild(pat);
            patternFn[type](pat,a,options);
        }


        function createLine(x1, y1, x2, y2,stroke,strokeWidth) {
            var line = L.SVG.create('line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', stroke);
            line.setAttribute('stroke-width', strokeWidth);
            return line;
        }

        function createRect(w,color){
            var rect = L.SVG.create('rect');
            rect.setAttribute('width', w);
            rect.setAttribute('height', w);
            rect.setAttribute('fill', color);
            return rect;
        }
    },

    /**
     * 呼吸灯
     * @param target
     * @param key {string} style key
     * @param values {Object} {min,max,gap}
     * @param timeGap 时间间隔
     */
    breathLight:function (target,key,values,timeGap){
        var num = 0,value = values.max;
        timeGap = timeGap || 100;
        var style = {};
        setInterval(function (){
            if(num<1000){
                style[key] = value-=values.gap;
                target.setStyle(style);
                if (value <= values.min) num=1000;
            }
            else{
                style[key] = value+=values.gap;
                target.setStyle(style);
                if(value>=values.max) num=0;
            }
            num++;
        },timeGap)
    },

    /**
     * 获取buffer ring 数据
     * 需要引用turf.js
     * @param geojson {object} geojson数据
     * @param radius {array} 多个环的半径
     */
    getBufferRings:function (geojson,radius){
        var coords = turf.polygon([geojson.features[0].geometry.coordinates[0]]);
        var buffers = [];
        radius.forEach(function (r){
            var buffered = turf.buffer(coords, r, "kilometers");
            buffered = turf.difference(buffered, coords);
            buffers.push( turf.featureCollection([buffered]))
        })
        return buffers;
    }
});

LW.Effect = LW.Effect.prototype;



/**
 * 地图经纬提示工具
 *
 * Features :
 *      1. 显示当前鼠标经纬
 *      2. 显示当前地图中心经纬
 *
 * @class L.Control.MousePosition
 * @extends L.Control
 * @example
 *          L.control.mousePosition({prefix:'鼠标所在位置：'}).addTo(map);
 */

L.Control.MousePosition = L.Control.extend({
    options: {
        /**
         * 显示位置
         * @property position
         * @type {string}
         * @default 'bottomright'
         */
        position: 'bottomright',

        /**
         * 显示分隔符
         * @property separator
         * @type {string}
         * @default ' : '
         */
        separator: ' : ',

        emptyString: 'Unavailable',

        /**
         * 是否经度在前显示
         * @property lngFirst
         * @type {boolean}
         * @default false
         */
        lngFirst: false,

        /**
         * 经纬度保留几位小数
         * @property numDigits
         * @type {int}
         * @default 5
         */
        numDigits: 5,

        /**
         * 经度格式
         * @property lngFormatter
         * @type {string}
         * @default undefined
         */
        lngFormatter: undefined,

        /**
         * 经度格式
         * @property latFormatter
         * @type {string}
         * @default undefined
         */
        latFormatter: undefined,

        /**
         * 显示前缀
         * @property prefix
         * @type {string}
         * @default ''
         */
        prefix: "鼠标位置：",

        centerPrefix:'地图中心：',

        elevationPrefix:'海拔高度：'
    },

    /**
     * @method setElevationModel
     * @param model {LW.GridModel}
     */
    setElevationModel:function (model) {
        this.elevationModel = model;
    },

    onAdd: function (map) {
        this._container = L.DomUtil.create('div', 'leaflet-control-mouseposition');
        this._mousePosition = L.DomUtil.create('p');
        this._container.appendChild(this._mousePosition);
        this._centerPosition = L.DomUtil.create('p');
        this._container.appendChild(this._centerPosition);
        this._elevation = L.DomUtil.create('p');
        this._container.appendChild(this._elevation);
        L.DomEvent.disableClickPropagation(this._container);
        map.on('mousemove', this._onMouseMove, this);
        map.on('drag', this._onCenterChange, this);
        map.on('zoomend', this._onCenterChange, this);
        //this._container.innerHTML=this.options.emptyString;
        return this._container;
    },

    onRemove: function (map) {
        map.off('mousemove', this._onMouseMove)
    },

    _onMouseMove: function (e) {
        // 当前鼠标经纬
        var lng = this.options.lngFormatter ? this.options.lngFormatter(e.latlng.lng) : L.Util.formatNum(e.latlng.lng, this.options.numDigits);
        var lat = this.options.latFormatter ? this.options.latFormatter(e.latlng.lat) : L.Util.formatNum(e.latlng.lat, this.options.numDigits);
        var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;
        this._mousePosition.innerText = this.options.prefix + ' ' + value;
        // 当前鼠标海拔
        if(this.elevationModel){
            var rank = this.elevationModel.getClosestGridByLatlng(L.latLng(lat,lng));
            var elevation = this.elevationModel.getGrid(rank.row,rank.column) || '';
            elevation = elevation!=''?Sun.Util.Math.toRoundFixed(elevation,2):'';
            this._elevation.innerText = this.options.elevationPrefix + ' ' + elevation+'米';
        }
    },
    _onCenterChange: function (e) {
        var latlng = this._map.getCenter();
        var lng = this.options.lngFormatter ? this.options.lngFormatter(latlng.lng) : L.Util.formatNum(latlng.lng, this.options.numDigits);
        var lat = this.options.latFormatter ? this.options.latFormatter(latlng.lat) : L.Util.formatNum(latlng.lat, this.options.numDigits);
        var value = this.options.lngFirst ? lng + this.options.separator + lat : lat + this.options.separator + lng;
        this._centerPosition.innerText = this.options.centerPrefix + ' ' + value;
    }

});

L.Map.mergeOptions({
    positionControl: false
});

L.Map.addInitHook(function () {
    if (this.options.positionControl) {
        this.positionControl = new L.Control.MousePosition();
        this.addControl(this.positionControl);
    }
});

L.control.mousePosition = function (options) {
    return new L.Control.MousePosition(options);
};


/**
 * mini地图
 *
 * Features :
 *      1. 小型地图控件，它将在角落创建一个小地图，该地图与设置了缩放偏移的主地图相同
 *
 * Update Note ：
 *      + v1.5.4 ：Created
 *
 * @class L.Control.MiniMap
 * @extends L.Control
 * @demo demo/map/miniMap.html  {瓦片 mini图}
 * @demo demo/map/miniMap_overlay.html  {overlay mini图}
 */
L.Control.MiniMap = L.Control.extend({

    includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,

    options: {
        /**
         * 控件位置，可选'bottomright'/'topleft'/'topright'/'bottomleft'
         * @property position
         * @type {int}
         * @default 'bottomright'
         */
        position: 'bottomright',
        /**
         * 缩放等级差，>0为放大等级差，<0为缩小等级差
         * @property zoomLevelOffset
         * @type {int}
         * @default -5
         */
        zoomLevelOffset: -5,
        /**
         * 是否展示固定的缩放等级
         * @property zoomLevelFixed
         * @type {boolean}
         * @default false
         */
        zoomLevelFixed: false,
        /**
         * 是否固定地图中心,false或传入地图中心经纬，如：[25,115]
         * @property centerFixed
         * @type {boolean|Array}
         * @default false
         */
        centerFixed: false,
        zoomAnimation: false,
        minimized: false,
        /**
         * mini图长度
         * @property width
         * @type {number}
         * @default 150
         */
        width: 150,
        /**
         * mini图宽度
         * @property height
         * @type {number}
         * @default 150
         */
        height: 150,
        /**
         * 主图映射范围指示矩形的样式属性
         * @property aimingRectOptions
         * @type {object}
         * @default {color: '#ff7800', weight: 1, interactive: false}
         */
        aimingRectOptions: {color: '#ff7800', weight: 1, interactive: false},
        shadowRectOptions: {color: '#000000', weight: 1, interactive: false, opacity: 0, fillOpacity: 0},
        // 是否展示切换按钮
        toggleDisplay: false,
        autoToggleDisplay: false,
        // 切换按钮长度
        collapsedWidth: 19,
        // 切换按钮宽度
        collapsedHeight: 19,
        strings: {hideText: 'Hide MiniMap', showText: 'Show MiniMap'},
        mapOptions: {}  // Allows definition / override of Leaflet map options.
    },

    // layer is the map layer to be shown in the minimap
    initialize: function (layer, options) {
        L.Util.setOptions(this, options);
        // Make sure the aiming rects are non-clickable even if the user tries to set them clickable (most likely by forgetting to specify them false)
        this.options.aimingRectOptions.interactive = false;
        this.options.shadowRectOptions.interactive = false;
        this._layer = layer;
    },

    onAdd: function (map) {

        this._mainMap = map;

        // Creating the container and stopping events from spilling through to the main map.
        this._container = L.DomUtil.create('div', 'leaflet-control-minimap');
        this._container.style.width = this.options.width + 'px';
        this._container.style.height = this.options.height + 'px';
        L.DomEvent.disableClickPropagation(this._container);
        L.DomEvent.on(this._container, 'mousewheel', L.DomEvent.stopPropagation);

        var mapOptions = {
            attributionControl: false,
            dragging: !this.options.centerFixed,
            zoomControl: false,
            zoomAnimation: this.options.zoomAnimation,
            autoToggleDisplay: this.options.autoToggleDisplay,
            touchZoom: this.options.centerFixed ? 'center' : !this._isZoomLevelFixed(),
            scrollWheelZoom: this.options.centerFixed ? 'center' : !this._isZoomLevelFixed(),
            doubleClickZoom: this.options.centerFixed ? 'center' : !this._isZoomLevelFixed(),
            boxZoom: !this._isZoomLevelFixed(),
            crs: map.options.crs
        };
        mapOptions = L.Util.extend(this.options.mapOptions, mapOptions);  // merge with priority of the local mapOptions object.

        this._miniMap = new L.Map(this._container, mapOptions);

        this._miniMap.addLayer(this._layer);

        // These bools are used to prevent infinite loops of the two maps notifying each other that they've moved.
        this._mainMapMoving = false;
        this._miniMapMoving = false;

        // Keep a record of this to prevent auto toggling when the user explicitly doesn't want it.
        this._userToggledDisplay = false;
        this._minimized = false;

        if (this.options.toggleDisplay) {
            this._addToggleButton();
        }

        this._miniMap.whenReady(L.Util.bind(function () {
            this._aimingRect = L.rectangle(this._mainMap.getBounds(), this.options.aimingRectOptions).addTo(this._miniMap);
            this._shadowRect = L.rectangle(this._mainMap.getBounds(), this.options.shadowRectOptions).addTo(this._miniMap);
            this._mainMap.on('moveend', this._onMainMapMoved, this);
            this._mainMap.on('move', this._onMainMapMoving, this);
            this._miniMap.on('movestart', this._onMiniMapMoveStarted, this);
            this._miniMap.on('move', this._onMiniMapMoving, this);
            this._miniMap.on('moveend', this._onMiniMapMoved, this);
        }, this));

        return this._container;
    },

    addTo: function (map) {
        L.Control.prototype.addTo.call(this, map);

        var center = this.options.centerFixed || this._mainMap.getCenter();
        this._miniMap.setView(center, this._decideZoom(true));
        this._setDisplay(this.options.minimized);
        return this;
    },

    onRemove: function (map) {
        this._mainMap.off('moveend', this._onMainMapMoved, this);
        this._mainMap.off('move', this._onMainMapMoving, this);
        this._miniMap.off('moveend', this._onMiniMapMoved, this);

        this._miniMap.removeLayer(this._layer);
    },

    changeLayer: function (layer) {
        this._miniMap.removeLayer(this._layer);
        this._layer = layer;
        this._miniMap.addLayer(this._layer);
    },

    _addToggleButton: function () {
        this._toggleDisplayButton = this.options.toggleDisplay ? this._createButton(
            '', this._toggleButtonInitialTitleText(), ('leaflet-control-minimap-toggle-display leaflet-control-minimap-toggle-display-' +
            this.options.position), this._container, this._toggleDisplayButtonClicked, this) : undefined;

        this._toggleDisplayButton.style.width = this.options.collapsedWidth + 'px';
        this._toggleDisplayButton.style.height = this.options.collapsedHeight + 'px';
    },

    _toggleButtonInitialTitleText: function () {
        if (this.options.minimized) {
            return this.options.strings.showText;
        } else {
            return this.options.strings.hideText;
        }
    },

    _createButton: function (html, title, className, container, fn, context) {
        var link = L.DomUtil.create('a', className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;

        var stop = L.DomEvent.stopPropagation;

        L.DomEvent
            .on(link, 'click', stop)
            .on(link, 'mousedown', stop)
            .on(link, 'dblclick', stop)
            .on(link, 'click', L.DomEvent.preventDefault)
            .on(link, 'click', fn, context);

        return link;
    },

    _toggleDisplayButtonClicked: function () {
        this._userToggledDisplay = true;
        if (!this._minimized) {
            this._minimize();
        } else {
            this._restore();
        }
    },

    _setDisplay: function (minimize) {
        if (minimize !== this._minimized) {
            if (!this._minimized) {
                this._minimize();
            } else {
                this._restore();
            }
        }
    },

    _minimize: function () {
        // hide the minimap
        if (this.options.toggleDisplay) {
            this._container.style.width = this.options.collapsedWidth + 'px';
            this._container.style.height = this.options.collapsedHeight + 'px';
            this._toggleDisplayButton.className += (' minimized-' + this.options.position);
            this._toggleDisplayButton.title = this.options.strings.showText;
        } else {
            this._container.style.display = 'none';
        }
        this._minimized = true;
        this._onToggle();
    },

    _restore: function () {
        if (this.options.toggleDisplay) {
            this._container.style.width = this.options.width + 'px';
            this._container.style.height = this.options.height + 'px';
            this._toggleDisplayButton.className = this._toggleDisplayButton.className
                .replace('minimized-'	+ this.options.position, '');
            this._toggleDisplayButton.title = this.options.strings.hideText;
        } else {
            this._container.style.display = 'block';
        }
        this._minimized = false;
        this._onToggle();
    },

    _onMainMapMoved: function (e) {
        if (!this._miniMapMoving) {
            var center = this.options.centerFixed || this._mainMap.getCenter();

            this._mainMapMoving = true;
            this._miniMap.setView(center, this._decideZoom(true));
            this._setDisplay(this._decideMinimized());
        } else {
            this._miniMapMoving = false;
        }
        this._aimingRect.setBounds(this._mainMap.getBounds());
    },

    _onMainMapMoving: function (e) {
        this._aimingRect.setBounds(this._mainMap.getBounds());
    },

    _onMiniMapMoveStarted: function (e) {
        if (!this.options.centerFixed) {
            var lastAimingRect = this._aimingRect.getBounds();
            var sw = this._miniMap.latLngToContainerPoint(lastAimingRect.getSouthWest());
            var ne = this._miniMap.latLngToContainerPoint(lastAimingRect.getNorthEast());
            this._lastAimingRectPosition = {sw: sw, ne: ne};
        }
    },

    _onMiniMapMoving: function (e) {
        if (!this.options.centerFixed) {
            if (!this._mainMapMoving && this._lastAimingRectPosition) {
                this._shadowRect.setBounds(new L.LatLngBounds(this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.sw), this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.ne)));
                this._shadowRect.setStyle({opacity: 1, fillOpacity: 0.3});
            }
        }
    },

    _onMiniMapMoved: function (e) {
        if (!this._mainMapMoving) {
            this._miniMapMoving = true;
            this._mainMap.setView(this._miniMap.getCenter(), this._decideZoom(false));
            this._shadowRect.setStyle({opacity: 0, fillOpacity: 0});
        } else {
            this._mainMapMoving = false;
        }
    },

    _isZoomLevelFixed: function () {
        var zoomLevelFixed = this.options.zoomLevelFixed;
        return this._isDefined(zoomLevelFixed) && this._isInteger(zoomLevelFixed);
    },

    _decideZoom: function (fromMaintoMini) {
        if (!this._isZoomLevelFixed()) {
            if (fromMaintoMini) {
                return this._mainMap.getZoom() + this.options.zoomLevelOffset;
            } else {
                var currentDiff = this._miniMap.getZoom() - this._mainMap.getZoom();
                var proposedZoom = this._miniMap.getZoom() - this.options.zoomLevelOffset;
                var toRet;

                if (currentDiff > this.options.zoomLevelOffset && this._mainMap.getZoom() < this._miniMap.getMinZoom() - this.options.zoomLevelOffset) {
                    // This means the miniMap is zoomed out to the minimum zoom level and can't zoom any more.
                    if (this._miniMap.getZoom() > this._lastMiniMapZoom) {
                        // This means the user is trying to zoom in by using the minimap, zoom the main map.
                        toRet = this._mainMap.getZoom() + 1;
                        // Also we cheat and zoom the minimap out again to keep it visually consistent.
                        this._miniMap.setZoom(this._miniMap.getZoom() - 1);
                    } else {
                        // Either the user is trying to zoom out past the mini map's min zoom or has just panned using it, we can't tell the difference.
                        // Therefore, we ignore it!
                        toRet = this._mainMap.getZoom();
                    }
                } else {
                    // This is what happens in the majority of cases, and always if you configure the min levels + offset in a sane fashion.
                    toRet = proposedZoom;
                }
                this._lastMiniMapZoom = this._miniMap.getZoom();
                return toRet;
            }
        } else {
            if (fromMaintoMini) {
                return this.options.zoomLevelFixed;
            } else {
                return this._mainMap.getZoom();
            }
        }
    },

    _decideMinimized: function () {
        if (this._userToggledDisplay) {
            return this._minimized;
        }

        if (this.options.autoToggleDisplay) {
            if (this._mainMap.getBounds().contains(this._miniMap.getBounds())) {
                return true;
            }
            return false;
        }

        return this._minimized;
    },

    _isInteger: function (value) {
        return typeof value === 'number';
    },

    _isDefined: function (value) {
        return typeof value !== 'undefined';
    },

    _onToggle: function () {
        L.Util.requestAnimFrame(function () {
            L.DomEvent.on(this._container, 'transitionend', this._fireToggleEvents, this);
            if (!L.Browser.any3d) {
                L.Util.requestAnimFrame(this._fireToggleEvents, this);
            }
        }, this);
    },

    _fireToggleEvents: function () {
        L.DomEvent.off(this._container, 'transitionend', this._fireToggleEvents, this);
        var data = { minimized: this._minimized };
        this.fire(this._minimized ? 'minimize' : 'restore', data);
        this.fire('toggle', data);
    }
});

L.Map.mergeOptions({
    miniMapControl: false
});

L.Map.addInitHook(function () {
    if (this.options.miniMapControl) {
        this.miniMapControl = (new L.Control.MiniMap()).addTo(this);
    }
});
/**
 * @class L.Control.MiniMap
 * @constructor
 * @param layer {L.Layer} 图层
 * @param options {object} 外部属性，可重设Properties
 * @returns {L.Control.MiniMap}
 */
L.control.minimap = function (layer, options) {
    return new L.Control.MiniMap(layer, options);
};



(function (){
    var mapWasDragEnabled,mapWasTapEnabled;

    function on (el, types, fn, context) {
        types.split(' ').forEach(function (type) {
            L.DomEvent.on(el, type, fn, context);
        })
    }

    function off (el, types, fn, context) {
        types.split(' ').forEach(function (type) {
            L.DomEvent.off(el, type, fn, context);
        })
    }

    function getRangeEvent (rangeInput) {
        return 'oninput' in rangeInput ? 'input' : 'change';
    }

    function cancelMapDrag () {
        mapWasDragEnabled = this._map.dragging.enabled();
        mapWasTapEnabled = this._map.tap && this._map.tap.enabled();
        this._map.dragging.disable();
        this._map.tap && this._map.tap.disable();
    }

    function uncancelMapDrag (e) {
        this._refocusOnMap(e);
        if (mapWasDragEnabled)
            this._map.dragging.enable();
        if (mapWasTapEnabled)
            this._map.tap.enable();
    }

    function asArray (arg) {
        return (arg === 'undefined') ? [] : Array.isArray(arg) ? arg : [arg]
    }

    /**
     * 图层卷帘控制器
     * Features :
     *      1. 可在x/y方向设置卷帘
     *      2. 可在y方向时设置图层提示名
     *
     * Update Note：
     *      + v1.5.5 : Created
     *
     * @class L.Control.SideBySide
     * @extends L.Control
     * @demo demo/map/side-by-side.html {卷帘}
     */
    L.Control.SideBySide = L.Control.extend({
        options: {
            /**
             * 滑块大小
             * @property thumbSize
             * @type {number}
             * @default 40
             */
            thumbSize: 40,
            padding: 0,
            /**
             * 滑动方向
             * @property sDir
             * @type {string}
             * @default 'x'
             */
            sDir:'x',
            leftLabel:null,
            rightLabel:null
        },

        initialize: function (leftLayers, rightLayers, options) {
            this.setLeftLayers(leftLayers);
            this.setRightLayers(rightLayers);
            L.setOptions(this, options);
        },

        getPosition: function () {
            var rangeValue = this._range.value
            var offset = (0.5 - rangeValue) * (2 * this.options.padding + this.options.thumbSize)
            var sDir = this.options.sDir;
            return this._map.getSize()[sDir] * rangeValue + offset;
        },

        setPosition: L.Util.falseFn(),

        includes: L.Evented.prototype || L.Mixin.Events,

        /**
         * 添加卷帘
         * @method addTo
         * @param map
         * @returns {L.Control.SideBySide}
         */
        addTo: function (map) {
            this.remove();
            this._map = map;

            var container = this._container = L.DomUtil.create('div', 'leaflet-sbs', map._controlContainer);
            if(this.options.sDir == 'y')
                container.setAttribute('orient','vertical');

            // 分割线
            this._divider = L.DomUtil.create('div', 'leaflet-sbs-divider', container);
            var leftLabel = this._leftLabel = L.DomUtil.create('p', 'sbs-p-left', this._divider);
            var rightLabel = this._rightLabel = L.DomUtil.create('p', 'sbs-p-right', this._divider);
            this.setLayerLabel(this.options.leftLabel,this.options.rightLabel);
            // 滑块
            var range = this._range = L.DomUtil.create('input', 'leaflet-sbs-range', container);
            range.type = 'range';
            range.min = 0;
            range.max = 1;
            range.step = 'any';
            range.value = 0.5;
            range.style.paddingLeft = range.style.paddingRight = this.options.padding + 'px';
            this._addEvents()
            this._updateLayers()
            return this
        },

        /**
         * 移除卷帘
         * @method remove
         * @param map
         * @returns {L.Control.SideBySide}
         */
        remove: function () {
            if (!this._map) {
                return this;
            }
            if (this._leftLayer)
                this._leftLayer.getElement().style.clip = '';
            if (this._rightLayer)
                this._rightLayer.getElement().style.clip = '';
            this._removeEvents();
            L.DomUtil.remove(this._container);

            this._map = null;

            return this;
        },

        /**
         * 设置图层的提示名。暂时只支持y方向
         * @param left {string}
         * @param right {string}
         */
        setLayerLabel:function (left,right){
            this.options.leftLabel = left;
            this.options.rightLabel = right;
            if(this._leftLabel && this._rightLabel){
                this._leftLabel.innerText = left ? left : '';
                this._leftLabel.style.display = left ? 'block' : 'none';
                this._rightLabel.innerText = right ? right : '';
                this._rightLabel.style.display = right ? 'block' : 'none';
            }
        },

        setLeftLayers: function (leftLayers) {
            this._leftLayers = asArray(leftLayers);
            this._updateLayers();
            return this;
        },

        setRightLayers: function (rightLayers) {
            this._rightLayers = asArray(rightLayers);
            this._updateLayers();
            return this;
        },

        _updateClip: function (e) {
            var map = this._map;
            if(!map) return;
            var nw = {x:0,y:0}
            var se = map.getSize();
            var sDir = this.options.sDir;
            var clip = nw[sDir] + this.getPosition();
            var divider = this.getPosition();

            var clipLeft,clipRight;
            if(sDir == 'x'){
                this._divider.style.left = divider + 'px';
                clipLeft = 'rect(' + [nw.y, clip, se.y, nw.x].join('px,') + 'px)';
                clipRight = 'rect(' + [nw.y, se.x, se.y, clip].join('px,') + 'px)';
            }
            else{
                this._divider.style.top = divider + 'px';
                clipLeft = 'rect(' + [nw.y, se.x, clip, nw.x].join('px,') + 'px)';
                clipRight = 'rect(' + [clip, se.x, se.y,nw.y].join('px,') + 'px)';
            }

            // this.fire('dividermove', {x: dividerX})
            if (this._leftLayer)
                this._leftLayer.getElement().style.clip = clipLeft;
            if (this._rightLayer)
                this._rightLayer.getElement().style.clip = clipRight;

            function getTranslate(target){
                var arr = target.style.transform.split(',');
                if(arr && arr.length>0){
                    return parseFloat(arr[0].replace('translate3d(',''));
                }
                return 0;
            }
        },

        _updateLayers: function () {
            if (!this._map) {
                return this;
            }
            var prevLeft = this._leftLayer;
            var prevRight = this._rightLayer;
            this._leftLayer = this._rightLayer = null;
            this._leftLayers.forEach(function (layer) {
                if (this._map.hasLayer(layer)) {
                    this._leftLayer = layer;
                }
            }, this)
            this._rightLayers.forEach(function (layer) {
                if (this._map.hasLayer(layer)) {
                    this._rightLayer = layer;
                }
            }, this)
            if (prevLeft !== this._leftLayer) {
                prevLeft && this.fire('leftlayerremove', {layer: prevLeft});
                this._leftLayer && this.fire('leftlayeradd', {layer: this._leftLayer});
            }
            if (prevRight !== this._rightLayer) {
                prevRight && this.fire('rightlayerremove', {layer: prevRight});
                this._rightLayer && this.fire('rightlayeradd', {layer: this._rightLayer});
            }
            this._updateClip();
        },

        _addEvents: function () {
            var range = this._range;
            var map = this._map;
            if (!map || !range) return;
            // map.on('move', this._updateClip, this);
            map.on('moveend', this._updateClip, this);
            map.on('layeradd layerremove', this._updateLayers, this);
            on(range, getRangeEvent(range), this._updateClip, this);
            on(range, L.Browser.touch ? 'touchstart' : 'mousedown', cancelMapDrag, this);
            on(range, L.Browser.touch ? 'touchend' : 'mouseup', uncancelMapDrag, this);
        },

        _removeEvents: function () {
            var range = this._range;
            var map = this._map;
            if (range) {
                off(range, getRangeEvent(range), this._updateClip, this);
                off(range, L.Browser.touch ? 'touchstart' : 'mousedown', cancelMapDrag, this);
                off(range, L.Browser.touch ? 'touchend' : 'mouseup', uncancelMapDrag, this);
            }
            if (map) {
                map.off('layeradd layerremove', this._updateLayers, this);
                map.off('move', this._updateClip, this);
            }
        }
    })

    /**
     * @class L.Control.SideBySide
     * @constructor
     * @param leftLayers 图层1
     * @param rightLayers 图层2
     * @param options {object} 外部属性，可重设Properties
     * @returns {*}
     */
    L.control.sideBySide = function (leftLayers, rightLayers, options) {
        return new L.Control.SideBySide(leftLayers, rightLayers, options);
    }
})();



/**
 * 坐标转换
 *
 * * Features :
 *      1. wsg84/百度/火星等坐标互转
 *      2. 直接单例引用。eg:LW.CoordConver.bd09_To_gps84
 *
 * Update Note :
 *      + v1.5.5 : Created,移除GPS.js
 *
 * @class LW.CoordConver
 */
(function (){

    var pi = 3.1415926535897932384626;
    var a = 6378245.0;
    var ee = 0.00669342162296594323;
    var x_pi = pi * 3000.0 / 180.0;
    var R = 6378137;

    function transform(lng, lat) {
        var dLat = transformLat(lng - 105.0, lat - 35.0);
        var dLng = transformLng(lng - 105.0, lat - 35.0);
        var radLat = lat / 180.0 * pi;
        var magic = Math.sin(radLat);
        magic = 1 - ee * magic * magic;
        var sqrtMagic = Math.sqrt(magic);
        dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);
        dLng = (dLng * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);
        var mgLat = lat + dLat;
        var mgLng = lng + dLng;
        var newCoord = {
            lng: mgLng,
            lat: mgLat
        };
        return newCoord;
    }

    function transformLat(x, y) {
        var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;
        ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;
        return ret;
    }

    function transformLng(x, y) {
        var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;
        ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0 * pi)) * 2.0 / 3.0;
        return ret;
    }
    LW.CoordConver = {

        /**
         * 百度转84
         * @method bd09_To_gps84
         * @param lng
         * @param lat
         * @returns {{lng: number, lat: number}}
         */
        bd09_To_gps84: function (lng, lat) {
            var gcj02 = this.bd09_To_gcj02(lng, lat);
            var map84 = this.gcj02_To_gps84(gcj02.lng, gcj02.lat);
            return map84;
        },
        /**
         * 84转百度
         * @method gps84_To_bd09
         * @param lng
         * @param lat
         * @returns {{lng: number, lat: number}}
         */
        gps84_To_bd09: function (lng, lat) {
            var gcj02 = this.gps84_To_gcj02(lng, lat);
            var bd09 = this.gcj02_To_bd09(gcj02.lng, gcj02.lat);
            return bd09;
        },
        /**
         * 84转火星
         * @method gps84_To_gcj02
         * @param lng
         * @param lat
         * @returns {{lng: number, lat: number}}
         */
        gps84_To_gcj02: function (lng, lat) {
            var dLat = transformLat(lng - 105.0, lat - 35.0);
            var dLng = transformLng(lng - 105.0, lat - 35.0);
            var radLat = lat / 180.0 * pi;
            var magic = Math.sin(radLat);
            magic = 1 - ee * magic * magic;
            var sqrtMagic = Math.sqrt(magic);
            dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);
            dLng = (dLng * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);
            var mgLat = lat + dLat;
            var mgLng = lng + dLng;
            var newCoord = {
                lng: mgLng,
                lat: mgLat
            };
            return newCoord;
        },
        /**
         * 火星转84
         * @method gcj02_To_gps84
         * @param lng
         * @param lat
         * @returns {{lng: number, lat: number}}
         */
        gcj02_To_gps84: function (lng, lat) {
            var coord = transform(lng, lat);
            var lontitude = lng * 2 - coord.lng;
            var latitude = lat * 2 - coord.lat;
            var newCoord = {
                lng: lontitude,
                lat: latitude
            };
            return newCoord;
        },
        /**
         * 火星转百度
         * @method gcj02_To_bd09
         * @param lng
         * @param lat
         * @returns {{lng: number, lat: number}}
         */
        gcj02_To_bd09: function (x, y) {
            var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * x_pi);
            var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * x_pi);
            var bd_lng = z * Math.cos(theta) + 0.0065;
            var bd_lat = z * Math.sin(theta) + 0.006;
            var newCoord = {
                lng: bd_lng,
                lat: bd_lat
            };
            return newCoord;
        },
        /**
         * 百度转火星
         * @method bd09_To_gcj02
         * @param lng
         * @param lat
         * @returns {{lng: number, lat: number}}
         */
        bd09_To_gcj02: function (bd_lng, bd_lat) {
            var x = bd_lng - 0.0065;
            var y = bd_lat - 0.006;
            var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);
            var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);
            var gg_lng = z * Math.cos(theta);
            var gg_lat = z * Math.sin(theta);
            var newCoord = {
                lng: gg_lng,
                lat: gg_lat
            };
            return newCoord;
        },
    }

})();

/**
 * TileLayer增加地图纠偏功能
 *
 * Features :
 *      1. 类型说明：Geoq-智图，GaoDe-高德，Google-谷歌，百度-Baidu，OSM-OSM，TianDiTu-天地图
 *      2. 坐标说明：智图、高德、谷歌为火星坐标-gcj02，Baidu为百度坐标-bd09，OSM、TianDiTu、Mapbox为wgs84坐标-wgs84
 *      3. 用法：options.tileType设置为1中的类型。eg:{tileType:'Geoq'}
 * Update Note：
 *      + v1.5.5 : Created
 *
 * @class L.TileLayer
 */
L.tileLayer = function (url, options) {
    options = options || {};
    if(options.tileType)
        options.coordType = getCoordType(options.tileType);
    return new L.TileLayer(url, options);

    //获取坐标类型
    function getCoordType(type) {
        var zbName = "wgs84"
        switch (type) {
            case "Geoq":
            case "GaoDe":
            case "Google":
                zbName = "gcj02";
                break;
            case "Baidu":
                zbName = "bd09";
                break;
            case "OSM":
            case "TianDiTu":
                zbName = "wgs84";
                break;
        }
        return zbName;
    }
};

L.GridLayer.include({
    _setZoomTransform: function (level, _center, zoom) {
        var center = _center;
        if (center != undefined && this.options) {
            if (this.options.coordType == 'gcj02') {
                center = LW.CoordConver.gps84_To_gcj02(_center.lng, _center.lat);
            } else if (this.options.corrdType == 'bd09') {
                center = LW.CoordConver.gps84_To_bd09(_center.lng, _center.lat);
            }
        }
        var scale = this._map.getZoomScale(zoom, level.zoom),
            translate = level.origin.multiplyBy(scale)
            .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

        if (L.Browser.any3d) {
            L.DomUtil.setTransform(level.el, translate, scale);
        } else {
            L.DomUtil.setPosition(level.el, translate);
        }
    },
    _getTiledPixelBounds: function (_center) {
        var center = _center;
        if (center != undefined && this.options) {
            if (this.options.coordType == 'gcj02') {
                center = LW.CoordConver.gps84_To_gcj02(_center.lng, _center.lat);
            } else if (this.options.corrdType == 'bd09') {
                center = LW.CoordConver.gps84_To_bd09(_center.lng, _center.lat);
            }
        }
        var map = this._map,
            mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
            scale = map.getZoomScale(mapZoom, this._tileZoom),
            pixelCenter = map.project(center, this._tileZoom).floor(),
            halfSize = map.getSize().divideBy(scale * 2);

        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    }
})


/**
 * @module Model
 */

/**
 * 分级模型
 *
 * 该模型的作用为在海量点应用的时候，可根据不同的地图等级计算在该等级上的展示的点
 *
 * Features :
 *      1. 根据指定像素进行网格化，一个网格显示一个站点。
 *      2. 当站点为自动站点时，
 *          （1）国家站固定模式：
 *               国家站永远展示
 *          （2）国家站不固定模式：
 *               并且当指定像素格点内里面出现多个站点时，显示优先级为：国家站（省->市->县）->区域站
 *      3. 当站点展示等级并列时，展示指定值最大/最小的点 或  距离格点左上角最近的点 或 随机展示
 *      4. 一次性计算所有地图等级的格点
 *
 * Update Note：
 *      + v1.5.0-alpha ：Created
 *
 * @class LW.LODModel
 * @extends L.Class
 * @constructor
 * @demo demo/model/grading.html  {自动站分级}
 */

LW.LODModel=L.Class.extend({
    options:{
        /**
         * 网格大小
         * @property cellSize
         * @type {int}
         * @default 60
         */
        cellSize:60,
        /**
         * 计算的最大等级
         * @property maxZoom
         * @type {int}
         * @default 13
         */
        maxZoom:13,
        /**
         * 计算的最小等级
         * @property minZoom
         * @type {int}
         * @default 0
         */
        minZoom:0,
        /**
         * 值字段
         * @property valueField
         * @type {string}
         * @default null
         */
        valueField:null,
        /**
         * 经度字段
         * @property lonField
         * @type {string}
         * @default STATIONLON
         */
        lonField:"STATIONLON",
        /**
         * 纬度字段
         * @property latField
         * @type {string}
         * @default STATIONLAT
         */
        latField:"STATIONLAT",
        /**
         * 升降序标识 desc/asc
         * @property order
         * @type {string}
         * @default desc
         */
        order:"desc",
        /**
         * 是否自动站
         * @property isZdz
         * @type {Boolean}
         * @default true
         */
        isZdz:true,
        /**
         * 权重模式
         *
         * 说明：
         *      1. 当weightMode=-1时 网格内的站点随机出现
         *      2. 当weightMode=0时  网格内的站点出现最大值或最小值   此时valueField(值参数)、order（升降序）需配置
         *      3. 当weightMode=1时，网格内的站点出现离格点左上角最近的点，此时valueField(值参数)、order（升降序）失效
         * @property weightMode
         * @type {int}
         * @default 0
         */
        weightMode:0,
        /**
         * 固定的边界
         *
         * 快速查找latLngBounds的方法:
         *      1. latLngBounds参数暂时不传入,或传入null
         *      2. 取出所有站点(全国站、区域站、周边站)的值传入数据模型，
         *      3. 在控制台将输出latLngBounds的提示，如：分级显示提示：GradingModel._latlngBounds:LatLng(34.45, 115.2833) LatLng(29.7167, 119.4167)
         *      4. 将输出的经纬作为latLngBounds参数传入模型中
         * @property latLngBounds
         * @type {Array|L.LatLngBounds}
         * @default null
         */
        latLngBounds:null,
        /**
         * 当地图超过所配置的最大等级时，展示所有点(包括无效点，例如无经纬度的点)
         * @property maxShowAll
         * @type {Boolean}
         * @default false
         */
        maxShowAll:false,
        /**
         * 展示出现在固定边界外的点
         * @property showOutBounds
         * @type {Boolean}
         * @default true
         */
        showOutBounds:true,
        /**
         * 固定国家站
         *
         * 说明：
         *      1. 当isZdz=true时：
         *          （1）fixCountryStations=true 国家站永远展示
         *          （2）fixCountryStations=false 优先展示国家站（省->市->县）->区域站
         *      2. 当isZdz=false时：
         *          fixCountryStations属性失效
         * @property fixCountryStations
         * @type {Boolean}
         * @default true
         */
        fixCountryStations:true,
        /**
         * 属性[fixField]=true的站点不参与分级
         */
        fixField:null,
        /**
         * 权重
         */
        weightField:null
    },
    initialize:function (map,options) {
        L.setOptions(this, options);
        var that=this,i;
        this._map=map;

        this._cellData=new Array(20);
        this._resultData=new Array(20);
        for(i=0;i<this._resultData.length;i++)
        {
            that._resultData[i]=[];
        }
        if(this.options.latLngBounds)
           this._latlngBounds=this.options.latLngBounds
    },
    /**
     * 设置数据
     * @param data
     */
    setData:function (data) {
        var that=this;
        var latlngs=[],i,order,zdzWeight;
        this.alldata=_.clone(data);
        this.outlatlngs=[];
        this._cellData=new Array(20);
        this._resultData=new Array(20);
        for(i=0;i<this._resultData.length;i++)
        {
            that._resultData[i]=[];
        }

        data=_.filter(data,function (item) {
            if(item[that.options.latField]==null||item[that.options.lonField]==null)
                return false;
            else {
                item.latlng=L.latLng(item[that.options.latField],item[that.options.lonField]);
                if(that.options.fixField&&item[that.options.fixField]){
                    item.minZoom=0;
                    item.maxZoom=18;
                    that.outlatlngs.push(item);
                    return false
                }
                if(that.options.latLngBounds!=null){
                    if(that.options.latLngBounds.contains(item.latlng))
                        return true;
                    else{
                        that.outlatlngs.push(item);
                        return false;
                    }
                }
                else
                    return true;
            }
        });

        order=this.options.order=="desc"?-1:1;
        data.forEach(function (item) {
            //item.latlng=L.latLng(item[that.options.latField],item[that.options.lonField]);
            item.showWeight=(that.options.valueField!=null&&item[that.options.valueField]!=null)?0:60000;
            item.maxZoom=18;
            item.minZoom=that.options.maxZoom;
            if(that._hasValueOrder()){
                item.showWeight+=order*item[that.options.valueField];
            }
            if(that.options.isZdz){
                zdzWeight=that._getZdzWeight(item);
                zdzWeight!=0?item.isCountryStation=true:item.isCountryStation=false;
                item.showWeight+=zdzWeight;
            }
            if(that.options.weightField&&item[that.options.weightField])
                item.showWeight-=item[that.options.weightField]*10000;
            latlngs.push(item.latlng);
        })
        this._sourceData=data;
        this._latlngBounds=this.options.latLngBounds||L.latLngBounds(latlngs);
        if(!this.options.latLngBounds&&this._latlngBounds.isValid())
            console.info("分级显示提示：GradingModel._latlngBounds:"+this._latlngBounds.getNorthWest()
                + " "+this._latlngBounds.getSouthEast());

        if(that.outlatlngs.length>1){
            console.warn("分级显示警告：经纬度边界配置可能有错误，其中有"+that.outlatlngs.length+"个站点不在经纬度边界范围内");
        }

    },

    _sortByZoom:function (zoom) {
        var rows=this._cellData[zoom].length;
        var columns,j,k,item,l,m,i=zoom;
        for(j=0;j<rows;j++)
        {
            columns=this._cellData[i][j].length;
            for(k=0;k<columns;k++)
            {
                if(this._cellData[i][j][k]!=null){
                    this._cellData[i][j][k]=_.sortBy(this._cellData[i][j][k],function (item) {
                        return  item["showWeight"+i];
                    })
                    item=this._cellData[i][j][k][0];
                    if(item.minZoom>i)
                        item.minZoom=i;
                    this._resultData[i].push(item);

                    if(this.options.isZdz&&this.options.fixCountryStations){
                        l=this._cellData[i][j][k].length;
                        for(m=1;m<l;m++)
                        {
                            item=this._cellData[i][j][k][m];
                            if(item.isCountryStation){
                                if(item.minZoom>i)
                                    item.minZoom=i;
                                this._resultData[i].push(item);
                            }
                            else{
                                break;
                            }
                        }
                    }
                }
            }
        }

    },

    /**
     * 返回数据
     * @param lvl
     * @return {*}
     */
    getData:function (zoom) {
        zoom=Math.floor(zoom);
        if(zoom<this.options.minZoom)
            zoom=this.options.minZoom;
        else if(zoom>this.options.maxZoom)
            return this.options.maxShowAll?this.alldata:((this.options.latLngBounds!=null&&this.options.showOutBounds)?this._sourceData.concat(this.outlatlngs):this._sourceData);

        if(this._resultData[zoom].length==0){
            this._createZoomData(zoom);
            this._sortByZoom(zoom);
        }
        return (this.options.latLngBounds!=null&&this.options.showOutBounds)?this._resultData[zoom].concat(this.outlatlngs):this._resultData[zoom];
    },
    _hasValueOrder:function () {
        return this.options.weightMode==0&&this.options.valueField!=null&&this.options.valueField!="";
    },
    /**
     * 返回自动站显示权重值
     * @param item
     * @private
     */
    _getZdzWeight:function (item) {
        var indexOf=-1;
        if(item["STATIONLEVEL_XZ"]!=null&&item["STATIONLEVEL_XZ"]!=""){
            indexOf=item["STATIONLEVEL_XZ"].indexOf("1");
        }
        if(indexOf==0)
            return -500000;
        else if(indexOf==1)
            return -400000;
        else if(indexOf==2)
            return -300000;
        else if(item["STATIONLEVEL_TYPE"]=="011"||item["STATIONLEVEL_TYPE"]=="012"||item["STATIONLEVEL_TYPE"]=="013")
            return -200000;
        else
            return 0;
    },
    /**
     * 创建单等级数据
     * @param lvl
     * @private
     */
    _createZoomData:function (zoom) {
        var that=this,i;
        var leftTopPoint=this._map.project(this._latlngBounds.getNorthWest(),zoom);
        var rightBottomPoint=this._map.project(this._latlngBounds.getSouthEast(),zoom);
        var rowNum=Math.ceil((rightBottomPoint.y-leftTopPoint.y)/this.options.cellSize);
        var columnNum=Math.ceil((rightBottomPoint.x-leftTopPoint.x)/this.options.cellSize);
        this._cellData[zoom]=new Array(rowNum);
        for(i=0;i<rowNum;i++)
        {
            that._cellData[zoom][i]=new Array(columnNum);
        }
        this._sourceData.forEach(function (item) {
            var p=that._getPosByPoint(item,zoom,leftTopPoint);
            if(p==null)
                return;
            if(that._cellData[zoom][p.y][p.x]==null){
                that._cellData[zoom][p.y][p.x]=[];
            }
            that._cellData[zoom][p.y][p.x].push(item);
        })
    },

    /**
     * 返回指定点的行、列位置
     * @private
     * @return  p.x 列  p.y 行
     */
    _getPosByPoint:function (item,zoom,leftTopPoint) {
        if(item.latlng==null)
            return null;
        var p=this._map.project(item.latlng,zoom);
        var w=p.x-leftTopPoint.x;
        var h=p.y-leftTopPoint.y;
        item["showWeight"+zoom]=item.showWeight;
        if(this.options.weightMode==1)
            item["showWeight"+zoom]+=this._getDisWeight(w,h,this.options.cellSize);
        return L.point(parseInt(w/this.options.cellSize),parseInt(h/this.options.cellSize))
    },
    /**
     * 计算距离权重
     * @param w
     * @param h
     * @param size
     * @private
     */
    _getDisWeight:function (w,h,size) {
        return Math.sqrt(Math.pow(w%size,2)+Math.pow(h%size,2));
    }
});


/**
 * 数据模型
 * @module Model
 */

/**
 * 网格模型
 *
 * Features :
 *      1. 包含风和非风类网格模型
 *      2. 非风类按数据精度存储值，风类在由uv分量转为speed和dir时转为数据精度
 *      3. 模型变换：基础变换、比例变换、权重变换、落区工具、风向变换
 *
 * Update Note：
 *      + v1.1.0-dev ：Created
 *      + v1.4.2 : 增加可以根据区域掩码网格，在设置数据或者编辑变换时只针对指定区域操作
 *      + v1.4.6 : 增加validRange的配置，在transform_base时判定超出validRange的发出invalidApply事件，并不应用无效格
 *      + v1.4.8 : 增加风类型参考数据只应用风速的功能
 *      + v1.5.2 : 1. transform_base增加fx参数，可判断单格是否应用变换
 *                 2. 增加是否只显示异常值的配置-abnormalOnly
 *                 3. 权重变化增加定制或增减的变化参数
 *      + v1.5.5 : 1. 增加是否仅展示区域内的网格的配置，属性为onlyRegionVisible
 *                 2. transform_windBuffer的缓冲区路径只有一个点的处理
 *
 * @class LW.GridModel
 * @extends L.Evented
 */
LW.GridModel = L.Evented.extend({
    options:{
        /**
         * 数据源类型 可为nc/json/gridInt
         * @property dataType
         * @type {string}
         * @default 'nc'
         */
        dataType:"nc",

        /**
         * 在风类型时，是否在创建网格的时候生成风速网格，主要用于GradientGlLayer的uv数据展示
         */
        dataSpeed:false,

        /**
         * 是否是风的模型
         * @property wind
         * @type {Boolean}
         * @default false
         */
        wind:false,

        /**
         * 是否是数值连贯的数据,主要用于图例数据区别
         * @property continuity
         * @type {Boolean}
         * @default true
         */
        continuous:true,

        /**
         * 区域掩码网格，一维网格，可通过Sun.Util.Grid.getRegionGrid方法生成；
         * 同一项目若是固定的网格经纬，推荐生成一次后，保存成文件，后续直接使用
         * @property regionGrid
         * @type {Array}
         * @default null
         */
        regionGrid:null,

        /**
         * 是否仅展示区域内的网格
         * @property onlyRegionVisible
         * @type {Boolean}
         * @default false
         */
        onlyRegionVisible:false,

        /**
         * 值的有效范围 eg:[min,max],[-20,20],[0,600] 包含min,max
         * @property validRange
         * @type {null|Array}
         * @default null
         */
        validRange:null,

        /**
         * 只展示异常值，该属性为true时网格item为{value:x,abnormal:true}的才展示，否则不展示
         */
        abnormalOnly:false,

        //[Deprecated]
        showFineGrid:false,//是否展示精细网格
        fineGridOptions:{
            nlat:0.01,
            nlon:0.01,
            bounds:null
        }
    },

    initialize : function (options) {
        L.setOptions(this,options);
    },

    /**
     * 设置数据
     * @method setData
     * @param source
     * @param applyRegions {Array} [可选] 设置应用的区域。一维网格，存储应用区域的key,[1,5,..]
     *          若设定区域时，指定区域对应的网格设置新的数据，非该指定的区域，保留原先网格值，需要有设置好的options.regionGrid
     * @param keepValidGrid {Boolean} [可选] 是否保留原先网格的有效值，若新数据的某个网格为无效值时，保留原先网格值
     * @param applyWindSpeed {Boolean} [可选] 该参数用于options.wind为true,但应用的数据只希望应用风速时使用
     * @param fireTransform {Boolean|undefined}
     */
    setData : function (source,applyRegions,keepValidGrid,applyWindSpeed,fireTransform) {
        this.source = source;
        this.applyRegions = applyRegions;
        this.keepValidGrid = keepValidGrid;
        this.applyWindSpeed = applyWindSpeed;
        this.dataPrecision = 1;
        // 数据处理
        if(this.options.dataType=='nc'){
            if(!applyWindSpeed){
                this.ncReader = new Sun.NCReader(source);
                this.data = Sun.Util.Data.changeGridNcToJson(this.ncReader);
            }
            else{
                var data = Sun.Util.Data.changeGridNcToJson(source);
                this.data.data = data.data;
            }
        }
        else if(this.options.dataType == 'gridInt'){
            if(!this.gridIntReader)
                this.gridIntReader = new Sun.GridInt16Reader();
            this.data = this.gridIntReader.readData(source);
            this.dataPrecision = this.data.DataPrecision;
        }
        else if(this.options.dataType=='json')
            this.data = source;
        // this.valueField = this.data.elementCode;
        if(this.options.wind && !applyWindSpeed){
            this.dataU = this.data.data[0];
            this.dataV = this.data.data[1];
        }
        this.data.latSign = this.data.nlat>0?1:-1;
        this.bounds = L.latLngBounds([[this.data.startlat, this.data.startlon], [this.data.endlat, this.data.endlon]]);
        // 创建网格
        this._buildGrid();

        // 发送transform事件
        fireTransform = typeof fireTransform === 'undefined' ? true : fireTransform;
        if(fireTransform)
            this._fireTransform();
    },

    _fireTransform:function () {
        // 是否展示精细网格[Deprecated]
        // if(this.options.showFineGrid){
        //     var fgOpt = this.options.fineGridOptions;
        //     this.fineGridData = this.getFineGrid(fgOpt.nlat,fgOpt.nlon,fgOpt.bounds);
        // }

        /**
         * 网格数据改变时会发出transfrom，图层可以根据需要，侦听该事件刷新图层
         * @event transform
         */
        this.fire('transform');
    },

    resetDataByGrid:function () {
        if(this.applyWindSpeed)
            this.data.data = [[],[]];
        for (var row_i = 0, p=0; row_i < this.data.latsize; row_i++) {
            for (var column_i = 0; column_i < this.data.lonsize; column_i++, p++) {
                var gItem = this.grid[row_i][column_i];
                gItem = typeof gItem == 'object' && gItem.hasOwnProperty('value') ? gItem.value :gItem;
                // gItem = gItem.covered ? gItem.value :gItem;
                if(this.options.wind){
                    this.data.data[0][p] = gItem[0];
                    this.data.data[1][p] = gItem[1];
                }
                else
                    this.data.data[p] = gItem;
            }
        }
    },

    /**
     * 获取数据
     * @method getData
     * @param returnType {string} json/nc
     */
    getData: function (returnType) {
        returnType = returnType || 'json';
        this.resetDataByGrid();
        if(returnType=='json')
            return this.data;
        else if(returnType=='nc')
            return this.ncReader.getNewBuffer(this.data,this.options.wind);
    },

    /**
     * 获取nc数据的属性
     * @param field
     * @returns {*}
     */
    getAttribute: function (field) {
        if(this.ncReader)
            return this.ncReader.getAttribute(field);
    },

    /**
     * 设置nc数据的数据
     * @param field
     * @param value
     */
    setAttribute: function (field,value) {
        if(this.ncReader)
            this.ncReader.setAttribute(field,value);
    },

    resetGrid: function (grid) {
        this.grid = grid;
        this._fireTransform();
    },

    _buildGrid: function () {
        var grid_bk = this.applyRegions || this.keepValidGrid || this.applyWindSpeed ? Sun.Util.Data.deepClone(this.grid) : null;

        var self = this;
        var rows = this.data.latsize,columns = this.data.lonsize;
        this.grid = new Array(rows);
        var isWind = this.data.GridType == 11 && this.options.dataSpeed;
        if(isWind)//Tip: 若是GridInt16的11类数据，计算出网格风速用于gl渲染的纹理
            var speed = new Int16Array(rows*columns);
        for (var row_i = 0,p = 0; row_i < rows; row_i++) {
            var row = new Array(columns);
            for (var column_i = 0; column_i < columns; column_i++, p++) {
                var item = getItem(p);
                row[column_i] = item;
                if(isWind)
                    speed[p] = this.isInvalid(item)?this.data.invalidValue:
                        Sun.Util.Weather.wind_getWindByUV(item,1).speed*this.dataPrecision;
            }
            this.grid[row_i] = row;
        }

        if(isWind)
            this.data.speed = speed;

        function getItem(p) {
            var item = self.applyWindSpeed?self.data.data[p]:self._getItem(p);
            if(grid_bk){
                if(self.applyRegions && self.options.regionGrid){//应用指定区域的网格为新数据，此外的网格为原先数据
                    var reg = self.options.regionGrid[p];
                    if(self.applyRegions.indexOf(reg)===-1)//若该网格的为非指定区域的网格，则用原先的网格，不变
                        item = grid_bk[row_i][column_i];
                }
                else if(self.keepValidGrid && grid_bk && self.isInvalid(item)) {//如果保留有效网格，且该网格为无效值用原先网格
                    item = grid_bk[row_i][column_i];
                }
                else if(self.applyWindSpeed){// 只应用风速
                    var bk = grid_bk[row_i][column_i];
                    var wValue = Sun.Util.Weather.wind_getWindByUV(bk);
                    item = Sun.Util.Weather.wind_getUVByWind(item,wValue.dir,1);
                }
            }

            return item;

        }
    },

    /**
     * 设置区域,regions为null/undefined时为不限定指定区域
     * @method setRegions
     * @param regions {Array|null|undefined} eg:[5,8] | null
     */
    setRegions:function(regions){
        this.regions = regions;
    },

    /**
     * 设置有效值范围，即设置options.validRange
     * @method setValidRange
     * @param range
     */
    setValidRange:function(range){
        this.options.validRange = range;
    },

    isEditable:function(grid,idx){
        var regionGrid = this.options.regionGrid;
        if(this.isHide(grid,null,null,idx))
            return false;
        else if(regionGrid && this.regions) {// 网格不在指定的区域内，无需编辑
            var inRegion = this.regions.indexOf(regionGrid[idx]) !== -1;
            if (!inRegion) return false;
        }
        return true;
    },

    isHide:function (value,row,column,idx) {
        var fixedValue = this.data.fixedValue;// fixedValue的用处？
        if(value.covered)// 网格被其他网格覆盖的
            return true;
        else if(this.options.abnormalOnly)// 改属性时只展示abnormal为true的值
            return !value.abnormal;
        else{
            if(this.options.onlyRegionVisible && this.regions){// 是否只展示指定区域中的值
                var regionGrid = this.options.regionGrid;
                var idx = !isNaN(idx) ? idx : this.getIdxByRank(row,column);
                if(regionGrid && !isNaN(idx) && this.regions.indexOf(regionGrid[idx]) == -1)
                    return true;
            }
            if(this.options.wind)
                return value[0] == fixedValue || value[1] == fixedValue;
            else
                return value == fixedValue;
        }
    },

    isInvalid:function (value) {
        var invalidValue = this.data.invalidValue;
        // if(Sun.Util.Common.isValid(value)){
        if(value!=null){
            if(this.options.wind)
                return value[0] == invalidValue || value[1] == invalidValue;
            else
                return value == invalidValue;
        }
        else
            return true;
    },

    inValidRange:function(value){
        var range = this.options.validRange;
        if(!range)
            return true;
        else{
            if(this.options.wind)
                return value[0]>=range[0] && value[0]<=range[1] && value[1]>=range[0] && value[1]<=range[1];
            else
                return value>=range[0] && value<=range[1];
        }
    },

    _getItem: function (i) {
        var pcs = this.dataPrecision;
        if(this.data){
            var value,u,v,invalid = this.data.invalidValue;
            if(this.options.wind)
                return u=this.dataU[i],v = this.dataV[i],u==invalid||v==invalid ? [u,v] : [u/pcs, v/pcs];
            else
                return value = this.data.data[i],value == invalid ? value : value/pcs;
            // return this.options.wind ?[this.dataU[i]/pcs, this.dataV[i]/pcs]:this.data.data[i]/pcs;
        }
    },

    /**
     * 获取指定网格点的经纬
     * @method getCellLatLng
     * @param row
     * @param column
     * @private
     */
    getCellLatLng: function (row, column) {
        var data = this.data;
        return L.latLng(data.startlat + data.nlat * row, data.startlon + data.nlon * column);
    },

    _getPrecisionValue:function (value) {
        var p = this.data.precision||0;
        if(L.Util.isArray(value))
            return value;
            // return [Sun.Util.Math.toRoundFixed(value[0],p),Sun.Util.Math.toRoundFixed(value[1],p)];
        else
            return Sun.Util.Math.toRoundFixed(value,p);
    },

    // TODO:grid item 应该直接存object，里面包含value,valid,abnormal,hide,uv,dir等属性
    _getValidValue:function (value) {
        var _value,invalidValue = this.data.invalidValue,fixedValue = this.data.fixedValue;
        value = value.value || value;
        if(this.options.wind){
            _value = [];
            _value[0] =  valid(value[0]);
            _value[1] =  valid(value[1]);
        }
        else
            _value = valid(value);
        return _value;

        function valid(v) {
            return v == invalidValue || v == fixedValue? 0: v;
        }
    },

    /**
     * 获取其他间隔的网格数据，抽稀或者加密操作
     * @method getDataByInterval
     * @param nlat
     * @param nlon
     * @param bounds
     * @returns {object}
     */
    getDataByInterval:function (nlat,nlon,bounds) {
        var source = this.data;
        var data = {nlat:nlat,nlon:nlon,precision:source.precision,elementCode:source.elementCode,
            invalidValue:source.invalidValue,latSign:source.latSign,version:source.version,title:source.title};
        if(bounds)
            bounds = L.latLngBounds(bounds);
        else
            bounds = L.latLngBounds([source.startlat,source.startlon],[source.endlat,source.endlon]);
        var x0 = data.startlon = bounds.getWest();
        var y0 = data.startlat = bounds.getSouth();
        var latsize = data.latsize = Math.round((bounds.getNorth()-bounds.getSouth())/nlat+1);
        var lonsize = data.lonsize = Math.round((bounds.getEast()-bounds.getWest())/nlon+1);
        data.endlon = bounds.getEast();
        data.endlat = bounds.getNorth();

        var gridData = this.options.wind ? [[],[]] : [];
        for (var row_i = 0,p=0; row_i < latsize; row_i++) {
            var lat = y0 + nlat * row_i;
            for (var column_i = 0; column_i < lonsize; column_i++,p++) {
                var lng = x0 + nlon * column_i;
                var rank = this.getClosestGridByLatlng(L.latLng([lat,lng]));
                var value;
                if(Math.floor(rank.row) === rank.row && Math.floor(rank.column) === rank.column)
                    value = this.getGrid(rank.row,rank.column)
                else {
                    var f_row = Math.floor(rank.row), c_row = f_row + 1;
                    var f_column = Math.floor(rank.column), c_column = f_column + 1;
                    var g00 = this.getGrid(f_row,f_column);
                    var g10 = this.getGrid(c_row,f_column);
                    var g01 = this.getGrid(f_row,c_column);
                    var g11 = this.getGrid(c_row,c_column);
                    value = this._bilinearInterpolation(rank.row - f_row, rank.column - f_column, g00, g10, g01, g11);
                    if(!this.options.wind)
                        value = Sun.Math.round(value,data.precision)
                    else{
                        value[0]= Sun.Math.round(value[0],data.precision+1);
                        value[1] = Sun.Math.round(value[1],data.precision+1);
                    }
                }
                if(!this.options.wind)
                    gridData[p] = value;
                else{
                    gridData[0][p] = value[0];
                    gridData[1][p] = value[1];
                }
            }
        }
        data.data = gridData;

        return data;
    },

    get4GridsIndexByLatlng:function (latlng) {
        var rank = this._getRankByLatlng(latlng);
        var f_row = Math.floor(rank.row), c_row = f_row + 1;
        var f_column = Math.floor(rank.column), c_column = f_column + 1;
        return {f_row:f_row,c_row:c_row,f_column:f_column,c_column:c_column};
    },

    /**
     * 获取某经纬度最近的网格
     * @method getClosestGridByLatlng
     * @param latlng {L.LatLng} 经纬度
     * @param leftbottom {boolean} [optional] 是否按照 “左下” 规则渲染的网格
     * @param interval {number} 网格间隔，不传时默认为数据中的nlon/nlat,可传原始数据nlon/nlat的整数据倍间隔
     * @returns {{row: number, column: number}}
     */
    getClosestGridByLatlng:function (latlng,leftbottom,interval) {
        var rank = this._getRankByLatlng(latlng,interval);
        var times = typeof interval == 'undefined' ? 1 : interval/this.data.nlon;
        var mathFun = leftbottom ? 'floor' : 'round';
        var grid = {row:Math[mathFun](rank.row),column:Math[mathFun](rank.column)};
        return grid;
    },

    _getRankByLatlng:function (latlng,interval) {
        var x0 = this.data.startlon, y0 = this.data.startlat;
        var dx = interval || this.data.nlon, dy = interval * this.data.latSign || this.data.nlat;
        var row = (latlng.lat - y0) / dy;
        var column = (latlng.lng - x0) / dx;
        return {row: row, column: column};
    },

    _getLatlngByRank:function (row,column) {
        var x0 = this.data.startlon, y0 = this.data.startlat;
        var dx = this.data.nlon, dy = this.data.nlat;
        var lat = dy * row + y0 , lng = dx * column + x0;
        return L.latLng(lat,lng);
    },

    getRankByBounds:function (latlngBounds){
        var xs = parseFloat(this.data.lonsize)-1,ys = parseFloat(this.data.latsize)-1;
        var se = this.get4GridsIndexByLatlng(latlngBounds.getSouthEast());
        var nw = this.get4GridsIndexByLatlng(latlngBounds.getNorthWest());
        var row_min = Math.min(se.f_row,nw.f_row),
            row_max = Math.max(se.c_row,nw.c_row),
            column_min = Math.min(se.f_column,nw.f_column),
            column_max = Math.max(se.c_column,nw.c_column);
        row_min  = row_min < 0 ? 0 : row_min;
        row_max  = row_max > ys ? ys : row_max;
        column_min  = column_min < 0 ? 0 : column_min;
        column_max  = column_max > xs ? xs : column_max;
        return {row_min:row_min,row_max:row_max,column_min:column_min,column_max:column_max};
    },

    /**
     * 根据经纬度获取该点根据双线性插值得到的值
     * @method getInterpolation
     * @param lat {number}
     * @param lng {number}
     * @return {number|Array|null}
     */
    getInterpolation:function(lat,lng,valueFn){
        var self = this;
        var rank = this._getRankByLatlng({lat:lat,lng:lng});
        var idx4 = this.get4GridsIndexByLatlng({lat:lat,lng:lng});
        var g00 = this.getGrid(idx4.f_row,idx4.f_column);
        var g10 = this.getGrid(idx4.f_row,idx4.c_column);
        var g01 = this.getGrid(idx4.c_row,idx4.f_column);
        var g11 = this.getGrid(idx4.c_row,idx4.c_column);

        if(this.isInvalid(g00) || this.isInvalid(g01) || this.isInvalid(g10) || this.isInvalid(g11))
            return null;
        else
            return this._bilinearInterpolation(rank.column - idx4.f_column, rank.row - idx4.f_row,
                _getValue(g00), _getValue(g10), _getValue(g01), _getValue(g11));

        function _getValue(grid) {
            // return grid.covered ? grid.value : grid;
            return valueFn ? valueFn(grid) : grid;
        }
    },

    _bilinearInterpolation: function (x, y, g00, g10, g01, g11) {
        if(this.options.wind){
            var u = this._bilinearInterpolate(x, y, g00[0], g10[0], g01[0], g11[0]);
            var v = this._bilinearInterpolate(x, y, g00[1], g10[1], g01[1], g11[1]);
            return [u, -v, Math.sqrt(u * u + v * v)];
        }
        else
            return this._bilinearInterpolate(x, y, g00, g10, g01, g11);
    },

    _bilinearInterpolate: function (x, y, g00, g10, g01, g11) {
        var rx = (1 - x);
        var ry = (1 - y);
        return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;
    },

    /**
     * 根据Rank获取其在一维网格中的索引
     * @method getIdxByRank
     * @param row {int}
     * @param column {int}
     * @returns {*}
     */
    getIdxByRank:function (row,column) {
        return parseInt(column)+row*this.data.lonsize;
    },
    /**
     * 根据索引获取Rank
     * @method getRankByIdx
     * @param idx {int}
     * @returns {*}
     */
    getRankByIdx: function(idx){
        var x0 = this.data.lonsize;
        var row = Math.floor(idx/x0), column = idx%x0;
        return {row:row,column:column};
    },

    /**
     * 判断所给的row，column指向的格点是否在网格内
     * @method inGrid
     * @param row {int}
     * @param column {int}
     * @returns {boolean}
     */
    inGrid:function (row,column) {
        return row>=0 && row<this.data.latsize && column>=0 && column<this.data.lonsize;
    },

    /**
     * 根据所给的row，column获得指向的格点
     * @method getGrid
     * @param row {int}
     * @param column {int}
     * @returns {number|array|null}
     */
    getGrid:function (row,column) {
        return this.inGrid(row,column)?this.grid[row][column] : null;
    },

    /**
     * 设置指定格点的值
     * @method setGridItem
     * @param row {int}
     * @param column {int}
     * @param value {Number|Array.<Number>} 值
     * @param fireTransform {Boolean} 是否触发渲染
     */
    setGridItem: function (row,column,value,fireTransform) {
        if(this.inGrid(row,column)){
            if(!this.options.wind)
                this.grid[row][column] = value;
            else{
                if(L.Util.isArray(value) && value.length==2)
                    this.grid[row][column] = value;
                else{
                    var uv = this.grid[row][column];
                    var wind = Sun.Util.Weather.wind_getWindByUV(uv);
                    this.grid[row][column] = Sun.Util.Weather.wind_getUVByWind(value,wind.dir,1);
                }
            }
            if(fireTransform)
                this._fireTransform();
        }
    },

    /**
     * 遍历指定的格点Item
     * @method eachItems
     * @param fun {Function} 回调
     * @param context {LW.GridModel} this
     * @param indexes {String} 指定的格点，格式为"row_column,row_column",eg:"3_5,4_2"
     */
    eachItems:function (fun, context, indexes) {
        for(var i=0;i<indexes.length;i++) {
            var index = indexes[i].split('_');
            var row = index[0], column = index[1];
            fun(context,row,column,context.getIdxByRank(row,column),i);
        }
    },

    /**
     * 遍历所有格点
     * @method eachGrid
     * @param fun {Function} 回调
     * @param context {LW.GridModel} this
     */
    eachGrid:function (fun, context) {
        for(var row_i=0,i=0;row_i<context.grid.length;row_i++){
            var row = context.grid[row_i];
            for(var column_i=0;column_i<row.length;column_i++,i++){
                fun(context,row_i,column_i,i);
            }
        }
    },

    /**
     * 获取指定网格或所有网格内的最大最小值
     * @method getMinMaxOfGrids
     * @param indexes {string} 'all'/"3_5,4_2"
     * @returns {{min: *, max: *}}
     */
    getMinMaxOfGrids:function (indexes) {
        var s_min,s_max;
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        forFun(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                var value = self._getValidValue(_grid);
                if (self.options.wind)
                    value = Sun.Util.Weather.wind_getWindByUV(value).speed;
                if (typeof s_min == 'undefined')
                    s_min = s_max = value;
                else {
                    if (value < s_min) s_min = value;
                    if (value > s_max) s_max = value;
                }
            }
        },this,indexes);

        return {min:Sun.Util.Math.toRoundFixed(s_min,1),max:Sun.Util.Math.toRoundFixed(s_max,1)};
    },

    //---改变模型数据---//
    /**
     * 基础变换 -- 支持加、减、等运算
     * @method transform_base
     * @param indexes {Array|String} 需要需要的索引 eg:[]||'all'
     * @param type {string} plus/sub/equal
     * @param value {number}
     * @param range [optional] {Array} null/[NaN,10]/[10,20]
     * @param fx [optional] {function} 用网格值和网格索引判断指定网格是否按指定规则应用的方法
     *                      eg: function(gValue,row,column,idx) {return true/false;}
     */
    transform_base: function (indexes,type,value,range,fx) {
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        var invalidValues=[];
        forFun(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                var gValue = self._getValidValue(_grid);
                if(self.options.wind){
                    var wValue = Sun.Util.Weather.wind_getWindByUV(gValue);
                    gValue = wValue.speed;
                }

                if(!fx || (fx && fx(gValue,row,column,idx))){
                    if(isChanging(gValue,range)) {
                        switch (type) {
                            case 'plus':
                                gValue += value;
                                break;
                            case 'sub':
                                gValue -= value;
                                break;
                            case 'equal':
                                gValue = value;
                                break;
                        }
                        if (self.options.wind) {
                            var uv = Sun.Util.Weather.wind_getUVByWind(gValue, wValue.dir,0,2);//Tip:若只保留一位，计算过程会有精度误差
                            gValue = [uv.u, uv.v];
                        }
                        if(self.inValidRange(gValue))
                            self.grid[row][column] = self._getPrecisionValue(gValue);
                        else if(invalidValues.length<5)
                            invalidValues.push({value:gValue,latlng:self._getLatlngByRank(row,column)})
                    }
                }
            }
        },this,indexes);
        if(invalidValues.length>0)
            this.fire('invalidApply',invalidValues);
        this._fireTransform();

        function isChanging(value,range) {
            if(range==null)
                return true;
            if(L.Util.isArray(range)){
                if(isNaN(range[0]))
                    return value<=range[1];
                else if (isNaN(range[1]))
                    return value>=range[0];
                else
                    return value>=range[0] && value<=range[1];
            }
        }
    },

    /**
     * 比例变换 -- 按原先值在最大最小值中的比例，变换为新的传入最大最小值中的比例
     * @method transform_ratio
     * @param indexes {Array|String} 需要需要的索引 eg:[]||'all'
     * @param min {number} 最小值
     * @param max {number} 最大值
     * @param sMinMax{Object} 这些网格原始的最大最小值
     */
    transform_ratio: function (indexes,min,max,sMinMax) {
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        // 获取原数据的最大最小值
        sMinMax = sMinMax || this.getMinMaxOfGrids(indexes);
        var s_min = sMinMax.min,s_max = sMinMax.max;

        // 按新比例分配
        // (s_v-s_min)/(s_max-s_v) = (v-min)/(max-v) = ratio;
        //  ---> v = (ratio*max+min)/(ratio+1);
        forFun(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                var s_v = self._getValidValue(_grid), v;
                if (self.options.wind) {
                    var wValue = Sun.Util.Weather.wind_getWindByUV(s_v);
                    s_v = wValue.speed;
                }
                if (s_v == s_min) v = min;
                else if (s_v == s_max) v = max;
                else {
                    var ratio = (s_v - s_min) / (s_max - s_v);
                    v = (ratio * max + min) / (ratio + 1);
                }

                if (self.options.wind) {
                    var uv = Sun.Util.Weather.wind_getUVByWind(v, wValue.dir);
                    v = [uv.u, uv.v];
                }
                self.grid[row][column] = self._getPrecisionValue(v);
            }
        },this,indexes);
        this._fireTransform();
    },

    /**
     * 简单的函数变换
     * @param indexes {Array|String} 需要需要的索引 eg:[]||'all'
     * @param fx {Function} eg:function(value){return a*value+b};
     */
    transform_fx:function(indexes,fx){
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        forFun(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                if(!self.isInvalid(_grid)){
                    var gValue = self._getValidValue(_grid);
                    if(self.options.wind){
                        var wValue = Sun.Util.Weather.wind_getWindByUV(gValue);
                        gValue = wValue.speed;
                    }

                    // 按函数变换
                    gValue = fx(gValue,row,column,idx);

                    if (self.options.wind) {
                        var uv = Sun.Util.Weather.wind_getUVByWind(gValue, wValue.dir);
                        gValue = [uv.u, uv.v];
                    }
                    self.grid[row][column] = self._getPrecisionValue(gValue);
                }
            }
        },this,indexes);
        this._fireTransform();
    },

    /**
     * 权重变换 -- 在指定圈内根据离散点和圈值为指定网格插值
     * @method transform_ratio
     * @param indexes {Array} 需要需要的索引
     * @param ring {Object} 圈值及圈的控制点 eg:{value:20,latlngs:[]}
     * @param weightPoints {Array} 权重点集 eg:[{value:35,latlng:[]},...]
     * @param pow {int} 反距离插值的幂
     * @param type {string} 赋值类型。fixed|plus
     */
    transform_weight: function (indexes,ring,weightPoints,pow,isPlus) {
        pow = pow || 1;
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        forFun(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                // 插值圈上离插值点最近的控制点，并加入加权点集
                var latlng = self.getCellLatLng(row, column);
                var min_latlng = self._findClosePointInRing(latlng, ring);

                // 用加权点集，插值
                var points = weightPoints.concat({value: ring.value, latlng: min_latlng});
                var value = self._idw(latlng, points, pow);

                if (self.options.wind)
                    value = self._getGridUVOfNewSpeed(self.grid[row][column], value);
                else if(isPlus)
                    value = self._getValidValue(_grid) + value;
                self.grid[row][column] = self._getPrecisionValue(value);
            }
        },this,indexes);
        this._fireTransform();
    },

    /**
     * 落区网格化
     * @method transform_isoline
     * @param rings {Array} 落区 eg:[{value:20,latlngs:[]},...]
     * @param weightPoints {Array} 权重点集 eg:[{value:35,latlng:[]},...]
     */
    transform_isoline:function (rings,weightPoints) {
        var continuous = this.options.continuous;
        // 判断落区关系
        this._setRingRelationShip(rings);
        // 跟落区
        var roots = [];
        rings.forEach(function (item) {
            if(item.pid===-1)
                roots.push(item);
        });
        // 判断落区和点集关系
        if(continuous) {//非连续的无需权重点计算
            this._setPointRelationShipInRing(weightPoints, roots, rings);
            var outRingPoint = [];
            weightPoints.forEach(function (p) {
                if(p.pid == -1) outRingPoint.push(p);
            });
        }

        this.eachGrid(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                var gValue, idwPoints = [];
                var latlng = self.getCellLatLng(row, column);
                var pid = self._getPidOfRingByLatlng(latlng, roots, rings);
                if (continuous) {
                    if (pid === -1) {// 所有跟节点外
                        roots.forEach(function (item) {
                            var m_latlng = self._findClosePointInRing(latlng, item);
                            idwPoints.push({value: item.value, latlng: m_latlng});
                        });
                        outRingPoint.forEach(function (p) {
                            idwPoints.push({value: p.value, latlng: p.latlng});
                        });
                        gValue = self._idw(latlng, idwPoints);
                    }
                    else {
                        var pRing = rings[pid];
                        pRing.cid.forEach(function (item) {
                            if (typeof item == 'number') {
                                var ring = rings[item];
                                var m_latlng = self._findClosePointInRing(latlng, ring);
                                idwPoints.push({value: ring.value, latlng: m_latlng});
                            }
                            else if (typeof item == 'object')
                                idwPoints.push({value: item.value, latlng: item.latlng});
                        });
                        idwPoints.push({value: pRing.value, latlng: self._findClosePointInRing(latlng, pRing)});
                        gValue = self._idw(latlng, idwPoints);
                    }
                }
                else
                    gValue = pid === -1 ? self.data.invalidValue : rings[pid].value;


                if (self.options.wind)
                    gValue = self._getGridUVOfNewSpeed(self.grid[row][column], gValue);
                if (pid != -1)
                    self.grid[row][column] = self._getPrecisionValue(gValue);
            }
        },this);
        this._fireTransform();
    },

    // 将原先的风格点值风速更新
    _getGridUVOfNewSpeed: function (gridUV,speed,isPlus) {
        var wValue = Sun.Util.Weather.wind_getWindByUV(gridUV);
        return Sun.Util.Weather.wind_getUVByWind(isPlus?(wValue.speed+speed):speed,wValue.dir,1,this.data.precision);
    },

    _idw:function (latlng,points,pow) {
        pow = pow || 1;
        var sgData = [],w=0;
        for(var n = 0;n<points.length;n++){
            var item = points[n];
            var d = Math.sqrt(Math.pow(latlng.lat - item.latlng.lat,2)+Math.pow(latlng.lng - item.latlng.lng,2));
            d = Math.pow(1 / d, pow);
            sgData.push({d: d, value: item.value});
            w += d;
        }

        var value = 0;
        for (var s = 0; s < sgData.length; s++) {
            var sg = sgData[s];
            value += sg.d / w * sg.value;
        }
        return value;
    },

    // 查找圈上最近的点
    _findClosePointInRing:function (latlng,ring) {
        var min_d,min_latlng;
        for(var m = 0;m<ring.latlngs.length;m++){
            var loc = ring.latlngs[m];
            var md = Math.sqrt(Math.pow(latlng.lat - loc.lat,2)+Math.pow(latlng.lng - loc.lng,2));
            if(m==0) {
                min_d = md;
                min_latlng = loc;
            }
            else if(min_d>md) {
                min_d = md;
                min_latlng = loc;
            }
        }
        return min_latlng;
    },

    // 设置落区关系
    _setRingRelationShip:function (rings) {
        // 初始化关系
        for(var k=0;k<rings.length;k++){
            var ring = rings[k];
            ring.id = k;
            ring.cid = [];
            ring.pid = -1;
        }
        for(var i=0;i<rings.length;i++){
            var line0 = rings[i];
            var p0 = line0.latlngs[0];
            for (var j = i + 1; j < rings.length; j++){
                var line1 = rings[j];
                var p1 = line1.latlngs[0];
                if (Sun.Util.Geometry.latlngInPolygon(p0, line1.latlngs)) {
                    // line0在line1里面
                    if (line0.pid===-1) {
                        line0.pid = j;
                        line1.cid.push(i);
                    }
                    else {
                        // 如果line0已经有parent，则比较line1与line0原parent（line2）的关系
                        // 如果line1在line2中，line0的parent变成line1，line2删掉line0这个child，多一个line1这个child
                        var line2 = rings[line0.pid];
                        if (Sun.Util.Geometry.latlngInPolygon(p1, line2.latlngs)) {
                            line2.cid.splice(line2.cid.indexOf(i), 1);
                            line0.pid = j;
                            line1.cid.push(i);
                        }
                    }
                }
                else if (Sun.Util.Geometry.latlngInPolygon(p1, line0.latlngs)) {
                    if (line0.pid===-1) {
                        line1.pid = i;
                        line0.cid.push(j);
                    }
                    else {
                        line2 = rings[line1.pid];
                        if (Sun.Util.Geometry.latlngInPolygon(p0, line2.latlngs)) {
                            line2.cid.splice(line2.cid.indexOf(j), 1);
                            line1.pid = i;
                            line0.cid.push(j);
                        }
                    }
                }
            }
        }
    },

    // 设置点与落区的关系
    _setPointRelationShipInRing:function (points,roots,rings) {
        for(var i=0;i<points.length;i++){
            var p = points[i];
            p.pid = this._getPidOfRingByLatlng(p.latlng,roots,rings);
            if(p.pid !== -1)
                rings[p.pid].cid.push(p);
        }
    },

    // 通过经纬度查找圈的Pid
    _getPidOfRingByLatlng:function (latlng,roots,rings) {
        var pid = -1;
        for (var i = 0; i < roots.length; i++){
            var line = roots[i];
            setPointPid(latlng,line);
        }
        return pid;

        function setPointPid(latlng,line) {
            if (Sun.Util.Geometry.latlngInPolygon(latlng, line.latlngs)) {
                // 点在line圈内
                if(line.cid &&　line.cid.length>0){
                    // 判断点是否在line子圈内
                    for(var k=0;k<line.cid.length;k++){
                        var cid = line.cid[k];
                        if(typeof cid == 'number'){
                            var line2 = rings[cid];
                            setPointPid(latlng,line2);
                        }
                    }
                    if(pid===-1)
                        pid = line.id;
                }
                else
                    pid = line.id;
            }
        }
    },

    /**
     * 区域权重工具
     * @method transform_areaWeight
     * @param indexes {Array|String} 需要需要的索引 eg:[]||'all'
     * @param values
     * @param bgPercent {Number} 百分比(0-1之间的数值)
     */
    transform_areaWeight:function (indexes,values,bgPercent) {
        this.eachItems(function(self, row, column, idx,i){
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                var value = values[i];
                var gValue = self._getValidValue(_grid);

                if(self.options.wind){
                    var wValue = Sun.Util.Weather.wind_getWindByUV(gValue);
                    gValue = wValue.speed;
                }
                if(bgPercent)
                    value += gValue*bgPercent;

                if(self.options.wind){
                    var uv = Sun.Util.Weather.wind_getUVByWind(value,wValue.dir);
                    value = [uv.u,uv.v];
                }

                self.grid[row][column] = self._getPrecisionValue(value);
            }
        },this,indexes);
        this._fireTransform();
    },

    /**
     * 区域移动
     * @method transform_areaMove
     * @param oldArea
     * @param newArea
     * @param oldIdx
     * @param newIdx
     */
    transform_areaMove:function (oldArea,newArea,oldIdx,newIdx) {
        var l1 = oldArea[0],l2 = newArea[0];
        var invalidValue = this.data.invalidValue;
        var dLat = l1.lat-l2.lat,dLng = l1.lng-l2.lng;
        var newGrid = [];
        var invaildItem = this.options.wind?[invalidValue,0]:invalidValue;
        this.eachItems(function(self, row, column){
            var latlng = self._getLatlngByRank(row,column);
            var s_latlng = L.latLng(latlng.lat+dLat,latlng.lng+dLng);
            var rank = self.getClosestGridByLatlng(s_latlng);
            if(Sun.Util.Geometry.latlngInPolygon(s_latlng,oldArea)){
                //前对照点在旧区域中，用改点的格点值覆盖新点
                var grid = self.inGrid(rank.row,rank.column)?self.grid[rank.row][rank.column]:invaildItem;
                newGrid.push([row,column,grid]);
            }
        },this,newIdx);
        for(var i=0;i<newGrid.length;i++){
            var item = newGrid[i];
            if(this.inGrid(item[0],item[1]))
                this.grid[item[0]][item[1]] = item[2];
        }
        this.eachItems(function(self, row, column){
            var latlng = self._getLatlngByRank(row,column);
            if(!Sun.Util.Geometry.latlngInPolygon(latlng,newArea))//前对照点不在新区域中，则改点变为无效值
                self.grid[row][column] = invaildItem;
        },this,oldIdx);

        this._fireTransform();
    },

    /**
     * 风向改变
     * @method transform_windDir
     * @param indexes {Array} 需要需要的索引
     * @param dir {number} 风向值
     */
    transform_windDir: function (indexes,dir) {
        if(!this.options.wind)
            return;
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        forFun(function(self, row, column,idx){
            var _grid = self.grid[row][column];
            if(!self.isHide(_grid,row,column)){
                var gValue = self._getValidValue(_grid);
                var wValue = Sun.Util.Weather.wind_getWindByUV(gValue, self.data.precision);
                self.grid[row][column] = Sun.Util.Weather.wind_getUVByWind(wValue.speed, dir, 1, self.data.precision+1);
            }
        },this,indexes);
        this._fireTransform();
    },

    /**
     * 风向缓冲区
     * @method transform_windBuffer
     * @param indexes
     * @param trackData
     * @param map
     */
    transform_windBuffer: function (indexes,trackData,map) {
        if(!this.options.wind)
            return;
        var forFun = indexes == 'all' ? this.eachGrid: this.eachItems;
        forFun(function (self,row,column,idx) {
            var _grid = self.grid[row][column];
            if(self.isEditable(_grid,idx)){
                var gValue = self._getValidValue(_grid);
                var latlng = self._getLatlngByRank(row, column);
                var dir = trackData && trackData.length>1 ? getDir(latlng) : 0;
                var wValue = Sun.Util.Weather.wind_getWindByUV(gValue, self.data.precision);
                self.grid[row][column] = Sun.Util.Weather.wind_getUVByWind(wValue.speed, dir, 1, self.data.precision+1);
            }
        },this,indexes);
        this._fireTransform();

        function getDir(gridLatlng) {
            var min_d=-1,min_i=-1;
            for(var i=0;i<trackData.length-1;i++){
                var l1 = trackData[i];
                var l2 = trackData[i+1];
                var l = L.latLng(l1.lat+(l2.lat-l1.lat)/2,l1.lng+(l2.lng-l1.lng)/2);
                var d = l.distanceTo(gridLatlng);
                if(min_d==-1 || d<min_d){
                    min_d = d;
                    min_i = i;
                }
            }
            if(min_i!=-1){
                var startP = map.latLngToContainerPoint(trackData[min_i]),
                    endP = map.latLngToContainerPoint(trackData[min_i+1]);
                var dir = Math.atan2(endP.y - startP.y, endP.x  - startP.x) * 180 / Math.PI - 90;
                return dir;
            }
        }
    }
});


LW.GridModelManager = L.Evented.extend({
    options:{
        wind:false,
        cover:true
    },

    initialize : function (options) {
        L.setOptions(this,options);
    },

    setData : function (source) {
        this.source = source;
        this.ncReader = new Sun.NCReader(new Uint8Array(source));
        this.data = Sun.Util.Data.changeGridNcToJson(this.ncReader);
        // console.log(this.data);

        this.gridModels = {};
        this.areaLvlKeys = {area0:'',area1:'',area2:[]};
        for(var key in this.data.data){
            var item = this.data.data[key];
            var gridMdl = new LW.GridModel({dataType:"json",wind:this.options.wind});
            gridMdl.setData(item);
            this.gridModels[key] = gridMdl;

            if(item.dataLevel == 2)
                this.areaLvlKeys.area2.push(key);
            else{
                this.areaLvlKeys['area'+item.dataLevel] = key;
                if(item.dataLevel == 0)
                    this.bounds = gridMdl.bounds;
            }
        }
        var key0 = this.areaLvlKeys.area0;
        this.prefKey = key0.slice(0,key0.lastIndexOf('_')+1);

        if(this.options.cover)
            this._signCoverGrids();
        this.editedKeys=[];
        this._fireTransform();
    },

    getData:function () {
        var self = this;
        this.editedKeys.forEach(function (key) {
            if(self.options.wind){
                var uKey = key.replace('uv','u'),vKey = key.replace('uv','v');
                self.ncReader.setVariableAttribute(uKey,'DataChange',"1");
                self.ncReader.setVariableAttribute(vKey,'DataChange',"1");
            }
            else
                self.ncReader.setVariableAttribute(key,'DataChange',"1");
            self.gridModels[key].resetDataByGrid();
        });

        return this.ncReader.getNewBuffer(this.data,this.options.wind);
    },

    getKeyNo:function (key) {
        return key.slice(key.lastIndexOf('_')+1);
    },

    _fireTransform:function () {
        this.fire('transform');
    },

    // 标志重叠的格点
    _signCoverGrids:function () {
        var areaLvlKeys = this.areaLvlKeys,self = this;
        signGrid(areaLvlKeys.area0,areaLvlKeys.area1);
        this.areaLvlKeys.area2.forEach(function (item) {
            signGrid(areaLvlKeys.area1,item);
        });

        function signGrid(key_l,key_s) {
            var gridMdl_L = self.gridModels[key_l];
            var data = self.data.data[key_s];
            var bound = L.latLngBounds([[data.startlat-0.001,data.startlon]],[data.endlat,data.endlon]);
            var indexes = Sun.Util.Geometry.getGridInBounds(self.data.data[key_l],gridMdl_L.grid,bound);
            gridMdl_L.eachItems(function (self,row,column) {
                var value = gridMdl_L.grid[row][column];
                var latlng = gridMdl_L._getLatlngByRank(row,column);
                gridMdl_L.grid[row][column] = {covered:true,value:value,latlng:latlng,sGridKey:key_s};
            },gridMdl_L,indexes);
        }
    },

    getInterpolation:function(lat,lng){
        var lvlKeys = this.areaLvlKeys,gridModels = this.gridModels;
        for(var i=0;i<lvlKeys.area2.length;i++){
            var key = lvlKeys.area2[i];
            var gridModel = gridModels[key];
            if(contains(gridModel.bounds,lat,lng))
                return gridModel.getInterpolation(lat,lng);
        }
        var grid1 = gridModels[lvlKeys.area1];
        if(contains(grid1.bounds,lat,lng))
            return grid1.getInterpolation(lat,lng,valueFn);
        else{
            var grid0 = gridModels[lvlKeys.area0];
            return grid0.getInterpolation(lat,lng,valueFn);
        }

        function valueFn(grid) {
            return grid.covered ? getSGrid(grid) : grid;
        }

        function getSGrid(grid) {
            var model = gridModels[grid.sGridKey];
            var rank = model.getClosestGridByLatlng(grid.latlng);
            return model.getGrid(rank.row,rank.column);
        }

        function contains(bounds,lat, lng) {
            return (lat >= bounds.getSouth()) && (lat <= bounds.getNorth()) &&
                (lng >= bounds.getWest()) && (lng <= bounds.getEast());
        }
    },

    getGridData:function () {
        var grid = {isGrid:true,grid:{},editedKeys:this.editedKeys};
        for(var key in this.gridModels){
            var model = this.gridModels[key];
            grid.grid[key] = model.grid;
        }
        return grid;
    },

    resetGrid: function (grid,editedKeys) {
        this.editedKeys = editedKeys;
        for(var key in grid){
            var gridModel = this.gridModels[key];
            gridModel.resetGrid(grid[key]);
        }
        this._fireTransform();
    },


    getGridModel: function(key){
        return this.gridModels[this.prefKey+key];
    },

    /**
     * 获取某经纬度最近的网格
     * @method getClosestGridByLatlng
     * @param latlng {L.LatLng} 经纬度
     * @param leftbottom {boolean} [optional]
     * @returns {{row: number, column: number}}
     */
    getClosestGridByLatlng:function (latlng,leftbottom) {
        var self = this;
        if(self.data){
            var key,keys = this.areaLvlKeys.area2.concat([this.areaLvlKeys.area1,this.areaLvlKeys.area0]);
            for(var i=0;i<keys.length;i++){
                key = getKey(keys[i]);
                if(key) break;
            }
            if(key){
                var model = this.gridModels[key];
                var rank = model._getRankByLatlng(latlng);
                var mathFun = leftbottom ? 'floor' : 'round';
                var grid = {row:Math[mathFun](rank.row),column:Math[mathFun](rank.column)};
                grid.key = this.getKeyNo(key);
                return grid;
            }
        }

        function getKey(key) {
            var data = self.data.data[key];
            var bound = L.latLngBounds([[data.startlat,data.startlon]],[data.endlat+data.nlat,data.endlon+data.nlon]);
            return bound.contains(latlng) ? key : null;
        }
    },

    /**
     * 遍历指定的格点Item
     * @param fn
     * @param latlngs
     */
    eachGrid:function (fn,latlngs) {
        var self = this;
        for(var key in this.data.data){
            var item = this.data.data[key],bound;
            var model = self.gridModels[key],indexes=null;
            var keyNo = self.getKeyNo(key);
            if(latlngs.center && latlngs.radius){ // 圆形
                var center = latlngs.center, radius = latlngs.radius;
                var d1 = center.distanceTo([item.startlat,item.startlon]);
                var d2 = center.distanceTo([item.endlat,item.endlon]);
                if(d1<radius && d2<radius)
                    indexes = 'all';
                else{
                    bound = L.latLngBounds([item.startlat,item.startlon],[item.endlat,item.endlon]);
                    if(bound.intersects(latlngs.bounds) || bound.contains(latlngs.bounds))
                        indexes = Sun.Util.Geometry.getGridInCircle(model.data,model.grid,latlngs.bounds,center,radius,'index');
                }
            }
            else if(latlngs.bounds && latlngs.keys){
                if(latlngs.keys.indexOf(keyNo)!==-1)
                    indexes = 'all';
                else{
                    indexes = [];
                    var _indexes;
                    latlngs.bounds.forEach(function (bound) {
                        if(bound.keys.indexOf(keyNo)!==-1){//判断边界是否与这个网格有交集
                            _indexes = Sun.Util.Geometry.getGridInBounds(model.data,model.grid,bound.bound,'index');
                            indexes = indexes.concat(_indexes);
                        }
                    });
                    for(var i=0;i<latlngs.latlngs.length;i++){
                        var _latlngs = latlngs.latlngs[i];
                        _indexes = getIdxByLatlngs(item,model,_latlngs);
                        if(_indexes === 'all'){
                            indexes = _indexes;
                            break;
                        }
                        else if(_indexes)
                            indexes = indexes.concat(_indexes);
                    }
                }
            }
            else{ // 多边形
                indexes = getIdxByLatlngs(item,model,latlngs);
                // bound = [[item.startlat,item.startlon],[item.startlat,item.endlon],
                //     [item.endlat,item.endlon],[item.endlat,item.startlon]];
                // if(Sun.Util.Geometry.polygon1InPolygon2(bound,latlngs))
                //     indexes = 'all';
                // if(Sun.Util.Geometry.polygon1OverlapPolygon2(latlngs,bound)||Sun.Util.Geometry.polygon1InPolygon2(latlngs,bound))
                //     indexes = Sun.Util.Geometry.getGridsInPolygon(model.data,model.grid,latlngs,'index');
            }

            if(indexes) fn(indexes,key,model);
        }

        function getIdxByLatlngs(item,model,latlngs) {
            var bound = [[item.startlat,item.startlon],[item.startlat,item.endlon],
                [item.endlat,item.endlon],[item.endlat,item.startlon]];
            var idxes;
            if(Sun.Util.Geometry.polygon1InPolygon2(bound,latlngs))
                idxes = 'all';
            if(Sun.Util.Geometry.polygon1OverlapPolygon2(latlngs,bound)||Sun.Util.Geometry.polygon1InPolygon2(latlngs,bound))
                idxes = Sun.Util.Geometry.getGridsInPolygon(model.data,model.grid,latlngs,'index');
            return idxes;
        }
    },

    eachModel:function(fn){
        for(var key in this.gridModels){
            var model = this.gridModels[key];
            fn(model,this.getKeyNo(key));
        }
    },

    // 获取区域内的最大最小值
    getMinMaxOfGrids:function (latlngs) {
        var min,max;
        this.eachGrid(function (indexes,key,model) {
            var mValue = model.getMinMaxOfGrids(indexes);
            if(mValue.min<min || isNaN(min)) min = mValue.min;
            if(mValue.max>max || isNaN(max)) max = mValue.max;
        },latlngs);
        return {min:min,max:max};
    },

    /**
     * 应用指定经纬度最近的左下网格的变换，因为多网格的模型是按照左下对齐方式显示网格，而不是居中显示
     * @param latlng
     * @param selectValue {number} 选中的值
     */
    selectGrid: function(latlng,selectValue){
        var grid = this.getClosestGridByLatlng(latlng,true);
        var model = this.getGridModel(grid.key);
        var value = model.getGrid(grid.row,grid.column);
        value = value == selectValue ? this.data.invalidValue : selectValue ;
        model.transform_base([grid.row+'_'+grid.column],'equal',value);
        this._fireTransform();
    },

    /**
     * 变换
     * @param fn {String|Function} GridModel中的transform方法名：transform_base|transform_ratio|
     * @param latlngs {Array} 选择网格的经纬度
     * @param args {Array} GridModel中transform方法的参数
     * @param fireTransform {Boolean} 是否出发变换改变展示
     */
    transform:function (fn,latlngs,args,fireTransform) {
        var self = this;
        this.eachGrid(function (indexes,key,model) {
            var _args = [indexes].concat(args);
            typeof fn == 'function' ? fn.apply(model,_args) : model[fn].apply(model,_args);

            if(self.editedKeys.indexOf(key)==-1)
                self.editedKeys.push(key);
        },latlngs,args);
        if(typeof fireTransform=='undefined' || fireTransform)
            this._fireTransform();
    },

    transformByBoundsAndKey:function (fn,boundsAndKey,args) {
        var self = this,prefix = self.prefKey;
        boundsAndKey.keys.forEach(function (key) {
            key = prefix + key;
            var model = self.gridModels[key];
            var _args = ['all'].concat(args);
            model[fn].apply(model,_args);
            if(self.editedKeys.indexOf(key)==-1)
                self.editedKeys.push(key);
        });
        boundsAndKey.bounds.forEach(function (bounds) {
            var keys = bounds.keys.map(function (key) {return prefix + key;});
            var editKeys = keys.concat([self.areaLvlKeys.area0,self.areaLvlKeys.area1]);
            editKeys.forEach(function (key) {
                var model = self.gridModels[key];
                var indexes = Sun.Util.Geometry.getGridInBounds(model.data,model.grid,bounds.bound,'index');
                var _args = [indexes].concat(args);
                model[fn].apply(model,_args);

                if(self.editedKeys.indexOf(key)==-1)
                    self.editedKeys.push(key);
            })
        });
        if(boundsAndKey.latlngs){
            boundsAndKey.latlngs.forEach(function (latlngs) {
                self.transform(fn,latlngs,args,false);
            });
        }
        this._fireTransform();
    },

    getIndexesByBoundsAndKey:function (boundsAndKey) {
        var self = this,prefix = self.prefKey;
        boundsAndKey.keys.forEach(function (key) {
            key = prefix + key;
            var model = self.gridModels[key];
            var _args = ['all'].concat(args);
            model[fn].apply(model,_args);
            if(self.editedKeys.indexOf(key)==-1)
                self.editedKeys.push(key);
        });
        boundsAndKey.bounds.forEach(function (bounds) {
            var keys = bounds.keys.map(function (key) {return prefix + key;});
            var editKeys = keys.concat([self.areaLvlKeys.area0,self.areaLvlKeys.area1]);
            editKeys.forEach(function (key) {
                var model = self.gridModels[key];
                var indexes = Sun.Util.Geometry.getGridInBounds(model.data,model.grid,bounds.bound,'index');
                var _args = [indexes].concat(args);
                model[fn].apply(model,_args);

                if(self.editedKeys.indexOf(key)==-1)
                    self.editedKeys.push(key);
            })
        });
        if(boundsAndKey.latlngs){
            boundsAndKey.latlngs.forEach(function (latlngs) {
                self.transform(fn,latlngs,args,false);
            });
        }
    }
});

/*
 * Lambert projection
 * EPSG:24600.
 */
L.Projection.Lambert = {
    lon0: 110 / 180 * Math.PI, // lon0,lat0为投影坐标(0,0)对应的经纬值,lon0投影意义为垂直经线
    lat0: 30 / 180 * Math.PI,
    lat1: 30 / 180 * Math.PI, // 第一纬度
    lat2: 60 / 180 * Math.PI, // 第二纬度

    bounds: L.bounds([0, -1], [360, 180]),

    create: function () {

        this.n = Math.log(Math.cos(this.lat1) / Math.cos(this.lat2)) /
            Math.log(Math.tan(Math.PI / 4 + this.lat2 / 2) / Math.tan(Math.PI / 4 + this.lat1 / 2));
        this.f = Math.cos(this.lat1) * Math.pow(Math.tan(Math.PI / 4 + this.lat1 / 2), this.n) / this.n;
        this.r0 = this.f / Math.pow(Math.tan(Math.PI / 4 + this.lat0 / 2), this.n);

        return this;
    },

    project: function (latlng) {
        var p = L.point(Math.PI * latlng.lng / 180, Math.PI * latlng.lat / 180);
        var r = this.f / Math.pow(Math.tan(Math.PI / 4 + p.y / 2), this.n);

        var x = r * Math.sin(this.n * (p.x - this.lon0));
        var y = r * Math.cos(this.n * (p.x - this.lon0)) - this.r0;

        return new L.Point(x, y);
    },

    unproject: function (point) {
        var n1;
        if (this.n < 0)
            n1 = -1;
        else if (this.n == 0)
            n1 = 0;
        else
            n1 = 1;

        var r = n1 * Math.sqrt(point.x * point.x + (this.r0 + point.y) * (this.r0 + point.y));
        var w = Math.atan2(point.x, this.r0 + point.y);

        var x = this.lon0 + w / this.n;
        var y = 2 * Math.atan(Math.pow(this.f / r, 1 / this.n)) - 0.5 * Math.PI;

        return new L.LatLng(180 * y / Math.PI, 180 * x / Math.PI);
    }
};

/**
 * 地理信息
 * @module Geo
 */

/**
 * L.CRS.EPSG24600
 *
 * Features :
 *      1. 兰伯特投影的crs
 *      2. 用法：map配置属性：{crs: L.CRS.EPSG24600}
 *      3. 瓦片图层需配置属性：{noWrap: true}
 *
 * @class L.CRS.EPSG24600
 * @extends L.CRS.Earth
 */

L.CRS.EPSG24600 = L.extend({}, L.CRS.Earth, {
    code: 'EPSG:24600',
    projection: L.Projection.Lambert.create(),

    transformation: (function () {
        // 1/256*64=0.25
        return new L.Transformation(0.25, 0, 0.25, 0);
    }())
});

/**
 * @module Layer.Tile
 */
(function(){
    var originalInitTile = L.GridLayer.prototype._initTile;
    L.GridLayer.include({
        _initTile: function (tile) {
            originalInitTile.call(this, tile);

            if(!this.options.unfix){
                var tileSize = this.getTileSize();

                tile.style.width = tileSize.x + 1 + 'px';
                tile.style.height = tileSize.y + 1 + 'px';
            }
        }
    });
})();

/**
 * WMTS服务的瓦片图层
 *
 * Update Note：
 *      + v1.5.3 ：Created
 * @class L.TileLayer.WMTS
 * @extends  L.TileLayer
 */
L.TileLayer.WMTS = L.TileLayer.extend({
    defaultWmtsParams: {
        service: 'WMTS',
        request: 'GetTile',
        version: '1.0.0',
        layer: '',
        style: '',
        tilematrixset: '',
        format: 'image/jpeg',
        /**
         * 矩阵id,用于区别 web麦卡托(''/'3857')和国家2000('4326')
         * @property matrixId
         * @type {String}
         * @default ''
         */
        matrixId:''
    },

    initialize: function (url, options) { // (String, Object)
        this._url = url;
        var lOptions= {};
        var cOptions = Object.keys(options);
        cOptions.forEach(function (element){
            lOptions[element.toLowerCase()]=options[element];
        });
        var wmtsParams = L.extend({}, this.defaultWmtsParams);
        var tileSize = lOptions.tileSize || this.options.tileSize;
        if (lOptions.detectRetina && L.Browser.retina) {
            wmtsParams.width = wmtsParams.height = tileSize * 2;
        } else {
            wmtsParams.width = wmtsParams.height = tileSize;
        }
        for (var i in lOptions) {
            // all keys that are in defaultWmtsParams options go to WMTS params
            if (wmtsParams.hasOwnProperty(i) && i!="matrixIds") {
                wmtsParams[i] = lOptions[i];
            }
        }
        this.wmtsParams = wmtsParams;
        this.matrixIds = options.matrixId=='4326'?this.get4326Matrix():this.getDefaultMatrix();
        L.setOptions(this, options);
    },

    onAdd: function (map) {
        this._crs = this.options.crs || map.options.crs;
        L.TileLayer.prototype.onAdd.call(this, map);
    },

    getTileUrl: function (coords) { // (Point, Number) -> String
        var tileSize = this.options.tileSize;
        var nwPoint = coords.multiplyBy(tileSize);
        nwPoint.x+=1;
        nwPoint.y-=1;
        var sePoint = nwPoint.add(new L.Point(tileSize, tileSize));
        var zoom = this._tileZoom;
        var nw = this._crs.project(this._map.unproject(nwPoint, zoom));
        var se = this._crs.project(this._map.unproject(sePoint, zoom));
        tilewidth = se.x-nw.x;
        var ident = this.matrixIds[zoom].identifier;
        // var tilematrix = this.wmtsParams.tilematrixset + ":" + ident;
        var tilematrix = ident;
        var X0 = this.matrixIds[zoom].topLeftCorner.lng;
        var Y0 = this.matrixIds[zoom].topLeftCorner.lat;
        var tilecol=Math.floor((nw.x-X0)/tilewidth);
        var tilerow=-Math.floor((nw.y-Y0)/tilewidth);
        var url = L.Util.template(this._url, {s: this._getSubdomain(coords)});
        return url + L.Util.getParamString(this.wmtsParams, url) + "&tilematrix=" + tilematrix + "&tilerow=" + tilerow +"&tilecol=" + tilecol;
    },

    setParams: function (params, noRedraw) {
        L.extend(this.wmtsParams, params);
        if (!noRedraw) {
            this.redraw();
        }
        return this;
    },

    getDefaultMatrix : function () {
        /**
         * the matrix3857 represents the projection
         * for in the IGN WMTS for the google coordinates.
         */
        var matrixIds3857 = new Array(22);
        for (var i= 0; i<22; i++) {
            matrixIds3857[i]= {
                identifier    : "" + i,
                // topLeftCorner : new L.LatLng(20037508.3428,-20037508.3428)
                topLeftCorner : new L.LatLng(20037508.34278, -20037508.34278)
            };
        }
        return matrixIds3857;
    },
    get4326Matrix : function (){
        /**
         * the matrix4326 represents the projection
         * for in the IGN WMTS for the google coordinates.
         */
        var matrixIds4326 = new Array(22);
        for (var i= 0; i<22; i++) {
            matrixIds4326[i]= {
                identifier    : "" + i,
                topLeftCorner : new L.LatLng(90,-180)  //修改代码
            };
        }
        return matrixIds4326;
    }
});

L.tileLayer.wmts = function (url, options) {
    return new L.TileLayer.WMTS(url, options);
};

/**
 * 可设置遮罩的瓦片图层
 *
 * Update Note：
 *      + v1.5.3 : Created
 *      + v1.5.4 : 1. 修复瓦片地址为无效地址展示裂图的问题
 *                 2. 修复瓦片移除后再添加无法显示的问题
 *                 3. 修复遮罩无法设置线宽的问题
 *      + v1.5.5 : 1. 增加可以截图的功能，需要截图时crossOrigin需为true
 *                 2. 优化crossOrigin为true时，图片重复转换为base64的问题
 *                 3. 多个tilemask用同一个mask时，某个tilemask移除，其他的tilemask也无法展示的问题修复
 *      + v1.5.6 : 1. crossOrigin为false时，无效地址展示裂图的问题修复
 *
 * @class L.TileLayer.Mask
 * @extends  L.TileLayer
 * @demo demo/tile/tileMask.html  {瓦片遮罩}
 */
L.TileLayer.Mask = L.TileLayer.extend({
    options: {
        /**
         * 是否跨域。需要截图时需要开启此属性，无需截图时请关闭该属性
         * @property crossOrigin
         * @type {boolean}
         * @default false
         */
        crossOrigin: false
    },
    _initContainer: function() {
        if (this._container) return;
        var rootGroup = this._map.getRenderer(this)._rootGroup;
        var container = this._container = rootGroup.appendChild(L.SVG.create("g"));

        this.id = 'leaflet-tilelayer-mask-' + L.stamp(this.options.maskGeoJson);

        if (!this._clipPath && !this.options.maskGeoJson.added) {
            var defs = rootGroup.appendChild(L.SVG.create("defs"));
            var clipPath  = this._clipPath = defs.appendChild(L.SVG.create("mask"));
            defs.appendChild(clipPath);
            this._clipPath.setAttribute('id', this.id);
            this._updateClipPath();
        }

        container.setAttribute('mask', 'url(#' + this.id + ')');
    },
    _updateClipPath: function (clipPath,maskGeoJson) {
        clipPath = clipPath || this._clipPath;
        maskGeoJson = maskGeoJson || this.options.maskGeoJson;
        if (maskGeoJson && maskGeoJson instanceof L.GeoJSON) {
            var _layers = maskGeoJson._layers;
            for (i in _layers) {
                var path = _layers[i]._path;
                path.setAttribute('clip-rule','evenodd');
                path.setAttribute('fill-opacity',1);
                path.setAttribute('stroke-opacity',1);
                clipPath.appendChild(path);
            }
            maskGeoJson.added = true;
        }
    },
    _updateLevels: function() {

        var zoom = this._tileZoom;
        if (zoom === undefined)
            return undefined;

        for (var z in this._levels) {
            if (!this._levels[z].el.firstChild && z !== zoom) {
                L.DomUtil.remove(this._levels[z].el);
                this._removeTilesAtZoom(z);
                delete this._levels[z];
            }
        }

        var level = this._levels[zoom];
        if (!level) {
            var map = this._map;
            level = {
                el: this._container.appendChild(L.SVG.create("g")),
                origin: map.project(map.unproject(map.getPixelOrigin()), zoom).round(),
                zoom: zoom
            };
            this._setZoomTransform(level, map.getCenter(), map.getZoom());
            L.Util.falseFn(level.el.offsetWidth);
            this._levels[zoom] = level;
        }
        this._level = level;
        return level;
    },
    _addTile: function(coords, container) {
        var tilePos = this._getTilePos(coords);
        var tileSize = this.getTileSize();
        var key = this._tileCoordsToKey(coords);
        var url = this.getTileUrl(this._wrapCoords(coords));

        var tile = container.appendChild(L.SVG.create("image"));
        tile.setAttribute("width", tileSize.x);
        tile.setAttribute("height", tileSize.y);
        // tile.setAttribute("width", tileSize.x+1);
        // tile.setAttribute("height", tileSize.y+1);
        tile.setAttribute("x", tilePos.x);
        tile.setAttribute("y", tilePos.y);
        tile.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", '');
        var crossOrigin = this.options.crossOrigin;

        if(crossOrigin)
            LW.ResourceCache.getImageBase64(url,function (base64){
                tile.setAttribute('xlink:href',base64);
            });
        else
            LW.ResourceCache.getImage(url,function (){
                tile.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
            })
            // tile.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);

        this._tiles[key] = {
            el: tile,
            coords: coords,
            current: true
        };
    },
    getEvents: function () {
        var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
        };

        if (!this.options.updateWhenIdle) {
            // update tiles on move, but not more often than once per given interval
            if (!this._onMove) {
                this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
            }

            events.move = this._onMove;
        }

        if (this._zoomAnimated) {
            // events.zoomanim = this._animateZoom;
        }

        return events;
    },
    resetMask:function (maskGeoJson) {
        var enabled = !!maskGeoJson;
        if (maskGeoJson && maskGeoJson instanceof  L.GeoJSON) {
            this.options.maskGeoJson = maskGeoJson;
            if(this._clipPath){
                Sun.Util.Common.removeAllChildren(this._clipPath);
                this._updateClipPath();
            }
        }
        if(this._container)
            this._container.setAttribute('mask', enabled?'url(#' + this.id + ')':'none');
    }
});

/**
 * @class L.TileLayer.Mask
 * @constructor
 * @param url {String} 瓦片图地址
 * @param options {object} 外部属性，可重设Properties
 * @returns {L.TileLayer.Mask}
 */
L.tileLayer.mask = function(url, options) {
    return new L.TileLayer.Mask(url, options);
};


(function () {
    function __$strToBlobUri(str, mime, isBinary) {
        try {
            return window.URL.createObjectURL(new Blob([Uint8Array.from(str.split('').map(function (c) {
                return c.charCodeAt(0)
            }))], {type: mime}));
        } catch (e) {
            return "data:" + mime + (isBinary ? ";base64," : ",") + str;
        }
    }

    var read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? (nBytes - 1) : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity)
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    };

    var write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
        var i = isLE ? 0 : (nBytes - 1);
        var d = isLE ? 1 : -1;
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {
        }

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {
        }

        buffer[offset + i - d] |= s * 128;
    };

    var index$1 = {
        read: read,
        write: write
    };

    var index = Pbf;

    var ieee754 = index$1;

    function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
    }

    Pbf.Varint = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
    Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
    Pbf.Bytes = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
    Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

    Pbf.prototype = {
        destroy: function () {
            this.buf = null;
        },

        // === READING =================================================================

        readFields: function (readField, result, end) {
            var this$1 = this;

            end = end || this.length;

            while (this.pos < end) {
                var val = this$1.readVarint(),
                    tag = val >> 3,
                    startPos = this$1.pos;

                this$1.type = val & 0x7;
                readField(tag, result, this$1);

                if (this$1.pos === startPos) {
                    this$1.skip(val);
                }
            }
            return result;
        },

        readMessage: function (readField, result) {
            return this.readFields(readField, result, this.readVarint() + this.pos);
        },

        readFixed32: function () {
            var val = readUInt32(this.buf, this.pos);
            this.pos += 4;
            return val;
        },

        readSFixed32: function () {
            var val = readInt32(this.buf, this.pos);
            this.pos += 4;
            return val;
        },

        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

        readFixed64: function () {
            var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
            this.pos += 8;
            return val;
        },

        readSFixed64: function () {
            var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
            this.pos += 8;
            return val;
        },

        readFloat: function () {
            var val = ieee754.read(this.buf, this.pos, true, 23, 4);
            this.pos += 4;
            return val;
        },

        readDouble: function () {
            var val = ieee754.read(this.buf, this.pos, true, 52, 8);
            this.pos += 8;
            return val;
        },

        readVarint: function (isSigned) {
            var buf = this.buf,
                val, b;

            b = buf[this.pos++];
            val = b & 0x7f;
            if (b < 0x80) {
                return val;
            }
            b = buf[this.pos++];
            val |= (b & 0x7f) << 7;
            if (b < 0x80) {
                return val;
            }
            b = buf[this.pos++];
            val |= (b & 0x7f) << 14;
            if (b < 0x80) {
                return val;
            }
            b = buf[this.pos++];
            val |= (b & 0x7f) << 21;
            if (b < 0x80) {
                return val;
            }
            b = buf[this.pos];
            val |= (b & 0x0f) << 28;

            return readVarintRemainder(val, isSigned, this);
        },

        readVarint64: function () { // for compatibility with v2.0.1
            return this.readVarint(true);
        },

        readSVarint: function () {
            var num = this.readVarint();
            return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
        },

        readBoolean: function () {
            return Boolean(this.readVarint());
        },

        readString: function () {
            var end = this.readVarint() + this.pos,
                str = readUtf8(this.buf, this.pos, end);
            this.pos = end;
            return str;
        },

        readBytes: function () {
            var end = this.readVarint() + this.pos,
                buffer = this.buf.subarray(this.pos, end);
            this.pos = end;
            return buffer;
        },

        // verbose for performance reasons; doesn't affect gzipped size

        readPackedVarint: function (arr, isSigned) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readVarint(isSigned));
            }
            return arr;
        },
        readPackedSVarint: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readSVarint());
            }
            return arr;
        },
        readPackedBoolean: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readBoolean());
            }
            return arr;
        },
        readPackedFloat: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readFloat());
            }
            return arr;
        },
        readPackedDouble: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readDouble());
            }
            return arr;
        },
        readPackedFixed32: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readFixed32());
            }
            return arr;
        },
        readPackedSFixed32: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readSFixed32());
            }
            return arr;
        },
        readPackedFixed64: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readFixed64());
            }
            return arr;
        },
        readPackedSFixed64: function (arr) {
            var this$1 = this;

            var end = readPackedEnd(this);
            arr = arr || [];
            while (this.pos < end) {
                arr.push(this$1.readSFixed64());
            }
            return arr;
        },

        skip: function (val) {
            var type = val & 0x7;
            if (type === Pbf.Varint) {
                while (this.buf[this.pos++] > 0x7f) {
                }
            } else if (type === Pbf.Bytes) {
                this.pos = this.readVarint() + this.pos;
            } else if (type === Pbf.Fixed32) {
                this.pos += 4;
            } else if (type === Pbf.Fixed64) {
                this.pos += 8;
            } else {
                throw new Error('Unimplemented type: ' + type);
            }
        },

        // === WRITING =================================================================

        writeTag: function (tag, type) {
            this.writeVarint((tag << 3) | type);
        },

        realloc: function (min) {
            var length = this.length || 16;

            while (length < this.pos + min) {
                length *= 2;
            }

            if (length !== this.length) {
                var buf = new Uint8Array(length);
                buf.set(this.buf);
                this.buf = buf;
                this.length = length;
            }
        },

        finish: function () {
            this.length = this.pos;
            this.pos = 0;
            return this.buf.subarray(0, this.length);
        },

        writeFixed32: function (val) {
            this.realloc(4);
            writeInt32(this.buf, val, this.pos);
            this.pos += 4;
        },

        writeSFixed32: function (val) {
            this.realloc(4);
            writeInt32(this.buf, val, this.pos);
            this.pos += 4;
        },

        writeFixed64: function (val) {
            this.realloc(8);
            writeInt32(this.buf, val & -1, this.pos);
            writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
            this.pos += 8;
        },

        writeSFixed64: function (val) {
            this.realloc(8);
            writeInt32(this.buf, val & -1, this.pos);
            writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
            this.pos += 8;
        },

        writeVarint: function (val) {
            val = +val || 0;

            if (val > 0xfffffff || val < 0) {
                writeBigVarint(val, this);
                return;
            }

            this.realloc(4);

            this.buf[this.pos++] = val & 0x7f | (val > 0x7f ? 0x80 : 0);
            if (val <= 0x7f) {
                return;
            }
            this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0);
            if (val <= 0x7f) {
                return;
            }
            this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0);
            if (val <= 0x7f) {
                return;
            }
            this.buf[this.pos++] = (val >>> 7) & 0x7f;
        },

        writeSVarint: function (val) {
            this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },

        writeBoolean: function (val) {
            this.writeVarint(Boolean(val));
        },

        writeString: function (str) {
            str = String(str);
            this.realloc(str.length * 4);

            this.pos++; // reserve 1 byte for short string length

            var startPos = this.pos;
            // write the string directly to the buffer and see how much was written
            this.pos = writeUtf8(this.buf, str, this.pos);
            var len = this.pos - startPos;

            if (len >= 0x80) {
                makeRoomForExtraLength(startPos, len, this);
            }

            // finally, write the message length in the reserved place and restore the position
            this.pos = startPos - 1;
            this.writeVarint(len);
            this.pos += len;
        },

        writeFloat: function (val) {
            this.realloc(4);
            ieee754.write(this.buf, val, this.pos, true, 23, 4);
            this.pos += 4;
        },

        writeDouble: function (val) {
            this.realloc(8);
            ieee754.write(this.buf, val, this.pos, true, 52, 8);
            this.pos += 8;
        },

        writeBytes: function (buffer) {
            var this$1 = this;

            var len = buffer.length;
            this.writeVarint(len);
            this.realloc(len);
            for (var i = 0; i < len; i++) {
                this$1.buf[this$1.pos++] = buffer[i];
            }
        },

        writeRawMessage: function (fn, obj) {
            this.pos++; // reserve 1 byte for short message length

            // write the message directly to the buffer and see how much was written
            var startPos = this.pos;
            fn(obj, this);
            var len = this.pos - startPos;

            if (len >= 0x80) {
                makeRoomForExtraLength(startPos, len, this);
            }

            // finally, write the message length in the reserved place and restore the position
            this.pos = startPos - 1;
            this.writeVarint(len);
            this.pos += len;
        },

        writeMessage: function (tag, fn, obj) {
            this.writeTag(tag, Pbf.Bytes);
            this.writeRawMessage(fn, obj);
        },

        writePackedVarint: function (tag, arr) {
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function (tag, arr) {
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function (tag, arr) {
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function (tag, arr) {
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function (tag, arr) {
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function (tag, arr) {
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function (tag, arr) {
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function (tag, arr) {
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function (tag, arr) {
            this.writeMessage(tag, writePackedSFixed64, arr);
        },

        writeBytesField: function (tag, buffer) {
            this.writeTag(tag, Pbf.Bytes);
            this.writeBytes(buffer);
        },
        writeFixed32Field: function (tag, val) {
            this.writeTag(tag, Pbf.Fixed32);
            this.writeFixed32(val);
        },
        writeSFixed32Field: function (tag, val) {
            this.writeTag(tag, Pbf.Fixed32);
            this.writeSFixed32(val);
        },
        writeFixed64Field: function (tag, val) {
            this.writeTag(tag, Pbf.Fixed64);
            this.writeFixed64(val);
        },
        writeSFixed64Field: function (tag, val) {
            this.writeTag(tag, Pbf.Fixed64);
            this.writeSFixed64(val);
        },
        writeVarintField: function (tag, val) {
            this.writeTag(tag, Pbf.Varint);
            this.writeVarint(val);
        },
        writeSVarintField: function (tag, val) {
            this.writeTag(tag, Pbf.Varint);
            this.writeSVarint(val);
        },
        writeStringField: function (tag, str) {
            this.writeTag(tag, Pbf.Bytes);
            this.writeString(str);
        },
        writeFloatField: function (tag, val) {
            this.writeTag(tag, Pbf.Fixed32);
            this.writeFloat(val);
        },
        writeDoubleField: function (tag, val) {
            this.writeTag(tag, Pbf.Fixed64);
            this.writeDouble(val);
        },
        writeBooleanField: function (tag, val) {
            this.writeVarintField(tag, Boolean(val));
        }
    };

    function readVarintRemainder(l, s, p) {
        var buf = p.buf,
            h, b;

        b = buf[p.pos++];
        h = (b & 0x70) >> 4;
        if (b < 0x80) {
            return toNum(l, h, s);
        }
        b = buf[p.pos++];
        h |= (b & 0x7f) << 3;
        if (b < 0x80) {
            return toNum(l, h, s);
        }
        b = buf[p.pos++];
        h |= (b & 0x7f) << 10;
        if (b < 0x80) {
            return toNum(l, h, s);
        }
        b = buf[p.pos++];
        h |= (b & 0x7f) << 17;
        if (b < 0x80) {
            return toNum(l, h, s);
        }
        b = buf[p.pos++];
        h |= (b & 0x7f) << 24;
        if (b < 0x80) {
            return toNum(l, h, s);
        }
        b = buf[p.pos++];
        h |= (b & 0x01) << 31;
        if (b < 0x80) {
            return toNum(l, h, s);
        }

        throw new Error('Expected varint not more than 10 bytes');
    }

    function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ?
            pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }

    function toNum(low, high, isSigned) {
        if (isSigned) {
            return high * 0x100000000 + (low >>> 0);
        }
        return ((high >>> 0) * 0x100000000) + (low >>> 0);
    }

    function writeBigVarint(val, pbf) {
        var low, high;

        if (val >= 0) {
            low = (val % 0x100000000) | 0;
            high = (val / 0x100000000) | 0;
        } else {
            low = ~(-val % 0x100000000);
            high = ~(-val / 0x100000000);

            if (low ^ 0xffffffff) {
                low = (low + 1) | 0;
            } else {
                low = 0;
                high = (high + 1) | 0;
            }
        }

        if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
            throw new Error('Given varint doesn\'t fit into 10 bytes');
        }

        pbf.realloc(10);

        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
    }

    function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 0x7f | 0x80;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 0x7f;
    }

    function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 0x07) << 4;

        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 0x80 : 0);
        if (!high) {
            return;
        }
        pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
        if (!high) {
            return;
        }
        pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
        if (!high) {
            return;
        }
        pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
        if (!high) {
            return;
        }
        pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);
        if (!high) {
            return;
        }
        pbf.buf[pbf.pos++] = high & 0x7f;
    }

    function makeRoomForExtraLength(startPos, len, pbf) {
        var extraLen =
            len <= 0x3fff ? 1 :
                len <= 0x1fffff ? 2 :
                    len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

        // if 1 byte isn't enough for encoding message length, shift the data to the right
        pbf.realloc(extraLen);
        for (var i = pbf.pos - 1; i >= startPos; i--) {
            pbf.buf[i + extraLen] = pbf.buf[i];
        }
    }

    function writePackedVarint(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeVarint(arr[i]);
        }
    }

    function writePackedSVarint(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeSVarint(arr[i]);
        }
    }

    function writePackedFloat(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeFloat(arr[i]);
        }
    }

    function writePackedDouble(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeDouble(arr[i]);
        }
    }

    function writePackedBoolean(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeBoolean(arr[i]);
        }
    }

    function writePackedFixed32(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeFixed32(arr[i]);
        }
    }

    function writePackedSFixed32(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeSFixed32(arr[i]);
        }
    }

    function writePackedFixed64(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeFixed64(arr[i]);
        }
    }

    function writePackedSFixed64(arr, pbf) {
        for (var i = 0; i < arr.length; i++) {
            pbf.writeSFixed64(arr[i]);
        }
    }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

    function readUInt32(buf, pos) {
        return ((buf[pos]) |
            (buf[pos + 1] << 8) |
            (buf[pos + 2] << 16)) +
            (buf[pos + 3] * 0x1000000);
    }

    function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = (val >>> 8);
        buf[pos + 2] = (val >>> 16);
        buf[pos + 3] = (val >>> 24);
    }

    function readInt32(buf, pos) {
        return ((buf[pos]) |
            (buf[pos + 1] << 8) |
            (buf[pos + 2] << 16)) +
            (buf[pos + 3] << 24);
    }

    function readUtf8(buf, pos, end) {
        var str = '';
        var i = pos;

        while (i < end) {
            var b0 = buf[i];
            var c = null; // codepoint
            var bytesPerSequence =
                b0 > 0xEF ? 4 :
                    b0 > 0xDF ? 3 :
                        b0 > 0xBF ? 2 : 1;

            if (i + bytesPerSequence > end) {
                break;
            }

            var b1, b2, b3;

            if (bytesPerSequence === 1) {
                if (b0 < 0x80) {
                    c = b0;
                }
            } else if (bytesPerSequence === 2) {
                b1 = buf[i + 1];
                if ((b1 & 0xC0) === 0x80) {
                    c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                    if (c <= 0x7F) {
                        c = null;
                    }
                }
            } else if (bytesPerSequence === 3) {
                b1 = buf[i + 1];
                b2 = buf[i + 2];
                if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                    c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                    if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                        c = null;
                    }
                }
            } else if (bytesPerSequence === 4) {
                b1 = buf[i + 1];
                b2 = buf[i + 2];
                b3 = buf[i + 3];
                if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                    c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                    if (c <= 0xFFFF || c >= 0x110000) {
                        c = null;
                    }
                }
            }

            if (c === null) {
                c = 0xFFFD;
                bytesPerSequence = 1;

            } else if (c > 0xFFFF) {
                c -= 0x10000;
                str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
                c = 0xDC00 | c & 0x3FF;
            }

            str += String.fromCharCode(c);
            i += bytesPerSequence;
        }

        return str;
    }

    function writeUtf8(buf, str, pos) {
        for (var i = 0, c, lead; i < str.length; i++) {
            c = str.charCodeAt(i); // code point

            if (c > 0xD7FF && c < 0xE000) {
                if (lead) {
                    if (c < 0xDC00) {
                        buf[pos++] = 0xEF;
                        buf[pos++] = 0xBF;
                        buf[pos++] = 0xBD;
                        lead = c;
                        continue;
                    } else {
                        c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                        lead = null;
                    }
                } else {
                    if (c > 0xDBFF || (i + 1 === str.length)) {
                        buf[pos++] = 0xEF;
                        buf[pos++] = 0xBF;
                        buf[pos++] = 0xBD;
                    } else {
                        lead = c;
                    }
                    continue;
                }
            } else if (lead) {
                buf[pos++] = 0xEF;
                buf[pos++] = 0xBF;
                buf[pos++] = 0xBD;
                lead = null;
            }

            if (c < 0x80) {
                buf[pos++] = c;
            } else {
                if (c < 0x800) {
                    buf[pos++] = c >> 0x6 | 0xC0;
                } else {
                    if (c < 0x10000) {
                        buf[pos++] = c >> 0xC | 0xE0;
                    } else {
                        buf[pos++] = c >> 0x12 | 0xF0;
                        buf[pos++] = c >> 0xC & 0x3F | 0x80;
                    }
                    buf[pos++] = c >> 0x6 & 0x3F | 0x80;
                }
                buf[pos++] = c & 0x3F | 0x80;
            }
        }
        return pos;
    }

    var index$5 = Point$1;

    function Point$1(x, y) {
        this.x = x;
        this.y = y;
    }

    Point$1.prototype = {
        clone: function () {
            return new Point$1(this.x, this.y);
        },

        add: function (p) {
            return this.clone()._add(p);
        },
        sub: function (p) {
            return this.clone()._sub(p);
        },
        mult: function (k) {
            return this.clone()._mult(k);
        },
        div: function (k) {
            return this.clone()._div(k);
        },
        rotate: function (a) {
            return this.clone()._rotate(a);
        },
        matMult: function (m) {
            return this.clone()._matMult(m);
        },
        unit: function () {
            return this.clone()._unit();
        },
        perp: function () {
            return this.clone()._perp();
        },
        round: function () {
            return this.clone()._round();
        },

        mag: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },

        equals: function (p) {
            return this.x === p.x &&
                this.y === p.y;
        },

        dist: function (p) {
            return Math.sqrt(this.distSqr(p));
        },

        distSqr: function (p) {
            var dx = p.x - this.x,
                dy = p.y - this.y;
            return dx * dx + dy * dy;
        },

        angle: function () {
            return Math.atan2(this.y, this.x);
        },

        angleTo: function (b) {
            return Math.atan2(this.y - b.y, this.x - b.x);
        },

        angleWith: function (b) {
            return this.angleWithSep(b.x, b.y);
        },

        // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
        angleWithSep: function (x, y) {
            return Math.atan2(
                this.x * y - this.y * x,
                this.x * x + this.y * y);
        },

        _matMult: function (m) {
            var x = m[0] * this.x + m[1] * this.y,
                y = m[2] * this.x + m[3] * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _add: function (p) {
            this.x += p.x;
            this.y += p.y;
            return this;
        },

        _sub: function (p) {
            this.x -= p.x;
            this.y -= p.y;
            return this;
        },

        _mult: function (k) {
            this.x *= k;
            this.y *= k;
            return this;
        },

        _div: function (k) {
            this.x /= k;
            this.y /= k;
            return this;
        },

        _unit: function () {
            this._div(this.mag());
            return this;
        },

        _perp: function () {
            var y = this.y;
            this.y = this.x;
            this.x = -y;
            return this;
        },

        _rotate: function (angle) {
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x = cos * this.x - sin * this.y,
                y = sin * this.x + cos * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        }
    };

// constructs Point from an array if necessary
    Point$1.convert = function (a) {
        if (a instanceof Point$1) {
            return a;
        }
        if (Array.isArray(a)) {
            return new Point$1(a[0], a[1]);
        }
        return a;
    };

    var Point = index$5;

    var vectortilefeature = VectorTileFeature$2;

    function VectorTileFeature$2(pbf, end, extent, keys, values) {
        // Public
        this.properties = {};
        this.extent = extent;
        this.type = 0;

        // Private
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys;
        this._values = values;

        pbf.readFields(readFeature, this, end);
    }

    function readFeature(tag, feature, pbf) {
        if (tag == 1) {
            feature.id = pbf.readVarint();
        } else if (tag == 2) {
            readTag(pbf, feature);
        } else if (tag == 3) {
            feature.type = pbf.readVarint();
        } else if (tag == 4) {
            feature._geometry = pbf.pos;
        }
    }

    function readTag(pbf, feature) {
        var end = pbf.readVarint() + pbf.pos;

        while (pbf.pos < end) {
            var key = feature._keys[pbf.readVarint()],
                value = feature._values[pbf.readVarint()];
            feature.properties[key] = value;
        }
    }

    VectorTileFeature$2.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

    VectorTileFeature$2.prototype.loadGeometry = function () {
        var pbf = this._pbf;
        pbf.pos = this._geometry;

        var end = pbf.readVarint() + pbf.pos,
            cmd = 1,
            length = 0,
            x = 0,
            y = 0,
            lines = [],
            line;

        while (pbf.pos < end) {
            if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }

            length--;

            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();

                if (cmd === 1) { // moveTo
                    if (line) {
                        lines.push(line);
                    }
                    line = [];
                }

                line.push(new Point(x, y));

            } else if (cmd === 7) {

                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
                if (line) {
                    line.push(line[0].clone()); // closePolygon
                }

            } else {
                throw new Error('unknown command ' + cmd);
            }
        }

        if (line) {
            lines.push(line);
        }

        return lines;
    };

    VectorTileFeature$2.prototype.bbox = function () {
        var pbf = this._pbf;
        pbf.pos = this._geometry;

        var end = pbf.readVarint() + pbf.pos,
            cmd = 1,
            length = 0,
            x = 0,
            y = 0,
            x1 = Infinity,
            x2 = -Infinity,
            y1 = Infinity,
            y2 = -Infinity;

        while (pbf.pos < end) {
            if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen & 0x7;
                length = cmdLen >> 3;
            }

            length--;

            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (x < x1) {
                    x1 = x;
                }
                if (x > x2) {
                    x2 = x;
                }
                if (y < y1) {
                    y1 = y;
                }
                if (y > y2) {
                    y2 = y;
                }

            } else if (cmd !== 7) {
                throw new Error('unknown command ' + cmd);
            }
        }

        return [x1, y1, x2, y2];
    };

    VectorTileFeature$2.prototype.toGeoJSON = function (x, y, z) {
        var size = this.extent * Math.pow(2, z),
            x0 = this.extent * x,
            y0 = this.extent * y,
            coords = this.loadGeometry(),
            type = VectorTileFeature$2.types[this.type],
            i, j;

        function project(line) {
            for (var j = 0; j < line.length; j++) {
                var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
                line[j] = [
                    (p.x + x0) * 360 / size - 180,
                    360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
                ];
            }
        }

        switch (this.type) {
            case 1:
                var points = [];
                for (i = 0; i < coords.length; i++) {
                    points[i] = coords[i][0];
                }
                coords = points;
                project(coords);
                break;

            case 2:
                for (i = 0; i < coords.length; i++) {
                    project(coords[i]);
                }
                break;

            case 3:
                coords = classifyRings(coords);
                for (i = 0; i < coords.length; i++) {
                    for (j = 0; j < coords[i].length; j++) {
                        project(coords[i][j]);
                    }
                }
                break;
        }

        if (coords.length === 1) {
            coords = coords[0];
        } else {
            type = 'Multi' + type;
        }

        var result = {
            type: "Feature",
            geometry: {
                type: type,
                coordinates: coords
            },
            properties: this.properties
        };

        if ('id' in this) {
            result.id = this.id;
        }

        return result;
    };

// classifies an array of rings into polygons with outer rings and holes

    function classifyRings(rings) {
        var len = rings.length;

        if (len <= 1) {
            return [rings];
        }

        var polygons = [],
            polygon,
            ccw;

        for (var i = 0; i < len; i++) {
            var area = signedArea(rings[i]);
            if (area === 0) {
                continue;
            }

            if (ccw === undefined) {
                ccw = area < 0;
            }

            if (ccw === area < 0) {
                if (polygon) {
                    polygons.push(polygon);
                }
                polygon = [rings[i]];

            } else {
                polygon.push(rings[i]);
            }
        }
        if (polygon) {
            polygons.push(polygon);
        }

        return polygons;
    }

    function signedArea(ring) {
        var sum = 0;
        for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            sum += (p2.x - p1.x) * (p1.y + p2.y);
        }
        return sum;
    }

    var VectorTileFeature$1 = vectortilefeature;

    var vectortilelayer = VectorTileLayer$2;

    function VectorTileLayer$2(pbf, end) {
        // Public
        this.version = 1;
        this.name = null;
        this.extent = 4096;
        this.length = 0;

        // Private
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];

        pbf.readFields(readLayer, this, end);

        this.length = this._features.length;
    }

    function readLayer(tag, layer, pbf) {
        if (tag === 15) {
            layer.version = pbf.readVarint();
        } else if (tag === 1) {
            layer.name = pbf.readString();
        } else if (tag === 5) {
            layer.extent = pbf.readVarint();
        } else if (tag === 2) {
            layer._features.push(pbf.pos);
        } else if (tag === 3) {
            layer._keys.push(pbf.readString());
        } else if (tag === 4) {
            layer._values.push(readValueMessage(pbf));
        }
    }

    function readValueMessage(pbf) {
        var value = null,
            end = pbf.readVarint() + pbf.pos;

        while (pbf.pos < end) {
            var tag = pbf.readVarint() >> 3;

            value = tag === 1 ? pbf.readString() :
                tag === 2 ? pbf.readFloat() :
                    tag === 3 ? pbf.readDouble() :
                        tag === 4 ? pbf.readVarint64() :
                            tag === 5 ? pbf.readVarint() :
                                tag === 6 ? pbf.readSVarint() :
                                    tag === 7 ? pbf.readBoolean() : null;
        }

        return value;
    }

// return feature `i` from this layer as a `VectorTileFeature`
    VectorTileLayer$2.prototype.feature = function (i) {
        if (i < 0 || i >= this._features.length) {
            throw new Error('feature index out of bounds');
        }

        this._pbf.pos = this._features[i];

        var end = this._pbf.readVarint() + this._pbf.pos;
        return new VectorTileFeature$1(this._pbf, end, this.extent, this._keys, this._values);
    };

    var VectorTileLayer$1 = vectortilelayer;

    var vectortile = VectorTile$1;

    function VectorTile$1(pbf, end) {
        this.layers = pbf.readFields(readTile, {}, end);
    }

    function readTile(tag, layers, pbf) {
        if (tag === 3) {
            var layer = new VectorTileLayer$1(pbf, pbf.readVarint() + pbf.pos);
            if (layer.length) {
                layers[layer.name] = layer;
            }
        }
    }

    var VectorTile = vectortile;


    var Symbolizer = L.Class.extend({
        render: function (renderer, style) {
            this._renderer = renderer;
            this.options = style;
            renderer._initPath(this);
            renderer._updateStyle(this);
        },
        updateStyle: function (renderer, style) {
            this.options = style;
            renderer._updateStyle(this);
        },

        _getPixelBounds: function () {
            var parts = this._parts;
            var bounds = L.bounds([]);
            for (var i = 0; i < parts.length; i++) {
                var part = parts[i];
                for (var j = 0; j < part.length; j++) {
                    bounds.extend(part[j]);
                }
            }

            var w = this._clickTolerance(),
                p = new L.Point(w, w);

            bounds.min._subtract(p);
            bounds.max._add(p);

            return bounds;
        },
        _clickTolerance: L.Path.prototype._clickTolerance,
    });

    var PolyBase = {
        _makeFeatureParts: function (feat, pxPerExtent) {
            var rings = feat.geometry;
            var coord;

            this._parts = [];
            for (var i = 0; i < rings.length; i++) {
                var ring = rings[i];
                var part = [];
                for (var j = 0; j < ring.length; j++) {
                    coord = ring[j];
                    // Protobuf vector tiles return {x: , y:}
                    // Geojson-vt returns [,]
                    part.push(L.point(coord).scaleBy(pxPerExtent));
                }
                this._parts.push(part);
            }
        },

        makeInteractive: function () {
            this._pxBounds = this._getPixelBounds();
        }
    };

    var PointSymbolizer = L.CircleMarker.extend({
        includes: Symbolizer.prototype,

        statics: {
            iconCache: {}
        },

        initialize: function (feature, pxPerExtent) {
            this.properties = feature.properties;
            this._makeFeatureParts(feature, pxPerExtent);
        },

        render: function (renderer, style) {
            Symbolizer.prototype.render.call(this, renderer, style);
            this._radius = style.radius || L.CircleMarker.prototype.options.radius;
            this._updatePath();
        },

        _makeFeatureParts: function (feat, pxPerExtent) {
            var coord = feat.geometry[0];
            if (typeof coord[0] === 'object' && 'x' in coord[0]) {
                // Protobuf vector tiles return [{x: , y:}]
                this._point = L.point(coord[0]).scaleBy(pxPerExtent);
                this._empty = L.Util.falseFn;
            } else {
                // Geojson-vt returns [,]
                this._point = L.point(coord).scaleBy(pxPerExtent);
                this._empty = L.Util.falseFn;
            }
        },

        makeInteractive: function () {
            this._updateBounds();
        },

        updateStyle: function (renderer, style) {
            this._radius = style.radius || this._radius;
            this._updateBounds();
            return Symbolizer.prototype.updateStyle.call(this, renderer, style);
        },

        _updateBounds: function () {
            var icon = this.options.icon;
            if (icon) {
                var size = L.point(icon.options.iconSize),
                    anchor = icon.options.iconAnchor ||
                        size && size.divideBy(2, true),
                    p = this._point.subtract(anchor);
                this._pxBounds = new L.Bounds(p, p.add(icon.options.iconSize));
            } else {
                L.CircleMarker.prototype._updateBounds.call(this);
            }
        },

        _updatePath: function () {
            if (this.options.icon) {
                this._renderer._updateIcon(this);
            } else {
                L.CircleMarker.prototype._updatePath.call(this);
            }
        },

        _getImage: function () {
            if (this.options.icon) {
                var url = this.options.icon.options.iconUrl,
                    img = PointSymbolizer.iconCache[url];
                if (!img) {
                    var icon = this.options.icon;
                    img = PointSymbolizer.iconCache[url] = icon.createIcon();
                }
                return img;
            } else {
                return null;
            }

        },

        _containsPoint: function (p) {
            var icon = this.options.icon;
            if (icon) {
                return this._pxBounds.contains(p);
            } else {
                return L.CircleMarker.prototype._containsPoint.call(this, p);
            }
        }
    });

    var LineSymbolizer = L.Polyline.extend({
        includes: [Symbolizer.prototype, PolyBase],

        initialize: function (feature, pxPerExtent) {
            this.properties = feature.properties;
            this._makeFeatureParts(feature, pxPerExtent);
        },

        render: function (renderer, style) {
            style.fill = false;
            Symbolizer.prototype.render.call(this, renderer, style);
            this._updatePath();
        },

        updateStyle: function (renderer, style) {
            style.fill = false;
            Symbolizer.prototype.updateStyle.call(this, renderer, style);
        },
    });

    var FillSymbolizer = L.Polygon.extend({
        includes: [Symbolizer.prototype, PolyBase],

        initialize: function (feature, pxPerExtent) {
            this.properties = feature.properties;
            this._makeFeatureParts(feature, pxPerExtent);
        },

        render: function (renderer, style) {
            Symbolizer.prototype.render.call(this, renderer, style);
            this._updatePath();
        }
    });

    /**
     * L.VectorGrid 矢量瓦片图层
     *
     * Update Note：
     *      + v1.5.6 : Created
     * @class L.VectorGrid
     * @extends L.GridLayer
     */
    L.VectorGrid = L.GridLayer.extend({
        options: {

            /**
             * 渲染器
             * @property rendererFactory
             * @default L.canvas.tile
             */
            rendererFactory: L.canvas.tile,

            /**
             * 瓦片样式
             * @property vectorTileLayerStyles
             * @default {}
             */
            vectorTileLayerStyles: {},

            /**
             * 是否可交互
             * @property interactive
             * @default false
             */
            interactive: false,

            // 🍂option getFeatureId: Function = undefined
            // A function that, given a vector feature, returns an unique identifier for it, e.g.
            // `function(feat) { return feat.properties.uniqueIdField; }`.
            // Must be defined for `setFeatureStyle` to work.

            /**
             * layer的顺序,如果有该属性，按属性的顺序绘制,eg:['town','county','city','prov']
             * @property order
             * @default null
             */
            order:null,

            /**
             * 是否像素修复，矢量图层不需要增加1px修复，否则有些填色时，会有线条叠加
             */
            unfix:true
        },

        initialize: function (options) {
            L.setOptions(this, options);
            L.GridLayer.prototype.initialize.apply(this, arguments);
            if (this.options.getFeatureId) {
                this._vectorTiles = {};
                this._overriddenStyles = {};
                this.on('tileunload', function (e) {
                    var key = this._tileCoordsToKey(e.coords),
                        tile = this._vectorTiles[key];

                    if (tile && this._map) {
                        tile.removeFrom(this._map);
                    }
                    delete this._vectorTiles[key];
                }, this);
            }
            this._dataLayerNames = {};
        },

        createTile: function (coords, done) {
            var storeFeatures = this.options.getFeatureId;

            var tileSize = this.getTileSize();
            var renderer = this.options.rendererFactory(coords, tileSize, this.options);

            var vectorTilePromise = this._getVectorTilePromise(coords);

            if (storeFeatures) {
                this._vectorTiles[this._tileCoordsToKey(coords)] = renderer;
                renderer._features = {};
            }

            // 设置vector Tile 样式
            vectorTilePromise.then(function renderTile(vectorTile) {
                var keys = Object.keys(vectorTile.layers);
                var interactive = this.options.interactive;
                if(this.options.order){
                    // 如果有指定的layer顺序。用指定的顺序。并仅设置当前layers的最底下图层响应交互事件
                    var order = this.options.order;
                    if(interactive){
                        for(var o = 0;o<order.length;o++){
                            if(keys.indexOf(order[o])!=-1){
                                var interactiveKey = order[o];
                                break;
                            }
                        }
                    }
                    keys = order;
                }
                else{
                    // Tip: mapbox 由于water,landuse需要叠加再道路下，所以需要重新排序下。
                    var waterIdx = keys.indexOf('water'), landuseIdx = keys.indexOf('landuse');
                    keys = keys.filter(function (key) {
                        return key != 'water' && key != 'landuse'
                    });
                    if (waterIdx != -1) keys.unshift('water');
                    if (landuseIdx != -1) keys.unshift('landuse');
                }

                for (var m = 0; m < keys.length; m++) {
                    var layerName = keys[m];
                    // for (var layerName in vectorTile.layers) {
                    this._dataLayerNames[layerName] = true;
                    var layer = vectorTile.layers[layerName];
                    if(layer){
                        if(interactive && interactiveKey)
                            interactive = interactive && layerName == interactiveKey;
                        var pxPerExtent = this.getTileSize().divideBy(layer.extent);

                        var layerStyle = this.options.vectorTileLayerStyles[layerName] ||
                            L.Path.prototype.options;

                        for (var i = 0; i < layer.features.length; i++) {
                            var feat = layer.features[i];
                            var id;

                            var styleOptions = layerStyle;
                            if (storeFeatures) {
                                id = this.options.getFeatureId(feat);
                                var styleOverride = this._overriddenStyles[id];
                                if (styleOverride) {
                                    if (styleOverride[layerName]) {
                                        styleOptions = styleOverride[layerName];
                                    } else {
                                        styleOptions = styleOverride;
                                    }
                                }
                            }

                            // --> 样式配置
                            if (styleOptions instanceof Function) {
                                styleOptions = styleOptions(feat.properties, coords.z, feat.type,feat);
                            }

                            if (styleOptions instanceof Array) {
                                for (var k = 0; k < styleOptions.length; k++) {
                                    var item = styleOptions[k];
                                    if("classes" in item) {
                                        if (item.classes.indexOf(feat.properties.class) != -1 &&
                                            (!item.type || (item.type && item.type.indexOf(feat.properties.type) != -1))) {
                                            styleOptions = item.options;
                                            var zooms = item.zooms;
                                            if (zooms && (coords.z < zooms[0] || coords.z > zooms[zooms.length - 1]))
                                                styleOptions = [];
                                            else if (styleOptions instanceof Function) {
                                                styleOptions = styleOptions(feat.properties, coords.z, feat.type);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            if (!(styleOptions instanceof Array)) {
                                styleOptions = [styleOptions];
                            }

                            if (!styleOptions.length) {
                                continue;
                            }
                            // <--

                            var featureLayer = this._createLayer(feat, pxPerExtent,interactive);

                            for (var j = 0; j < styleOptions.length; j++) {
                                var style = L.extend({}, L.Path.prototype.options, styleOptions[j]);
                                featureLayer.render(renderer, style);
                                featureLayer.layerName = layerName;
                                featureLayer.feat = feat;
                                renderer._addPath(featureLayer);
                            }

                            featureLayer.options.interactive = interactive;
                            if (interactive) {
                                featureLayer.makeInteractive();
                            }

                            if (storeFeatures) {
                                renderer._features[id] = {
                                    layerName: layerName,
                                    feature: featureLayer
                                };
                            }
                        }
                    }
                }
                if (this._map != null) {
                    renderer.addTo(this._map);
                }
                L.Util.requestAnimFrame(done.bind(coords, null, null));
            }.bind(this));

            return renderer.getContainer();
        },

        /**
         * 重置样式
         * @method resetStyle
         */
        resetStyle:function (){
            var map = this._map;
            this._removeAllTiles();
            this._setView(map.getCenter(), map.getZoom(), true);
        },

        setFeatureStyle: function (id, layerStyle) {
            this._overriddenStyles[id] = layerStyle;

            for (var tileKey in this._vectorTiles) {
                var tile = this._vectorTiles[tileKey];
                var features = tile._features;
                var data = features[id];
                if (data) {
                    var feat = data.feature;

                    var styleOptions = layerStyle;
                    if (layerStyle[data.layerName]) {
                        styleOptions = layerStyle[data.layerName];
                    }

                    this._updateStyles(feat, tile, styleOptions);
                }
            }
            return this;
        },

        resetFeatureStyle: function (id) {
            delete this._overriddenStyles[id];

            for (var tileKey in this._vectorTiles) {
                var tile = this._vectorTiles[tileKey];
                var features = tile._features;
                var data = features[id];
                if (data) {
                    var feat = data.feature;
                    var styleOptions = this.options.vectorTileLayerStyles[data.layerName] ||
                        L.Path.prototype.options;
                    this._updateStyles(feat, tile, styleOptions);
                }
            }
            return this;
        },

        getDataLayerNames: function () {
            return Object.keys(this._dataLayerNames);
        },

        _updateStyles: function (feat, renderer, styleOptions) {
            styleOptions = (styleOptions instanceof Function) ?
                styleOptions(feat.properties, renderer.getCoord().z) :
                styleOptions;

            if (!(styleOptions instanceof Array)) {
                styleOptions = [styleOptions];
            }

            for (var j = 0; j < styleOptions.length; j++) {
                var style = L.extend({}, L.Path.prototype.options, styleOptions[j]);
                feat.updateStyle(renderer, style);
            }
        },

        _createLayer: function (feat, pxPerExtent, /*layerStyle,*/interactive) {
            var layer;
            switch (feat.type) {
                case 1:
                // layer = new PointSymbolizer(feat, pxPerExtent);
                // break;
                case 2:
                    layer = new LineSymbolizer(feat, pxPerExtent);
                    break;
                case 3:
                    layer = new FillSymbolizer(feat, pxPerExtent);
                    break;
            }

            if (interactive && layer) {
                layer.addEventParent(this);
            }

            return layer;
        },
    });

    L.vectorGrid = function (options) {
        return new L.VectorGrid(options);
    };

    /**
     *
     * 矢量瓦片图层-PBF数据图层
     *
     * Update Note：
     *      + v1.5.6 : Created
     * @class L.VectorGrid.Protobuf
     * @extends L.VectorGrid
     * @demo demo/tile/vectorTile_mapbox.html  {mapbox矢量瓦片}
     * @demo demo/tile/vectorTile_custom.html  {自定义矢量瓦片}
     * @demo demo/tile/vectorTile_mapbox_custom.html  {mapbox+自定义矢量瓦片}
     */
    L.VectorGrid.Protobuf = L.VectorGrid.extend({

        options: {
            subdomains: 'abc',	// Like L.TileLayer
            //
            // 🍂option fetchOptions: Object = {}
            // options passed to `fetch`, e.g. {credentials: 'same-origin'} to send cookie for the current domain
            fetchOptions: {}
        },

        initialize: function (url, options) {
            // Inherits options from geojson-vt!
// 		this._slicer = geojsonvt(geojson, options);
            this._url = url;
            L.VectorGrid.prototype.initialize.call(this, options);
        },

        setUrl: function (url, noRedraw) {
            this._url = url;
            if (!noRedraw) {
                this.redraw();
            }
            return this;
        },

        _getSubdomain: L.TileLayer.prototype._getSubdomain,

        _getVectorTilePromise: function (coords) {
            var data = {
                s: this._getSubdomain(coords),
                x: coords.x,
                y: coords.y,
                z: coords.z
// 			z: this._getZoomForUrl()	/// TODO: Maybe replicate TileLayer's maxNativeZoom
            };
            if (this._map && !this._map.options.crs.infinite) {
                var invertedY = this._globalTileRange.max.y - coords.y;
                if (this.options.tms) { // Should this option be available in Leaflet.VectorGrid?
                    data['y'] = invertedY;
                }
                data['-y'] = invertedY;
            }

            var tileUrl = L.Util.template(this._url, L.extend(data, this.options));

            return fetch(tileUrl, this.options.fetchOptions).then(function (response) {

                if (!response.ok) {
                    return {layers: []};
                }

                return response.blob().then(function (blob) {
// 				console.log(blob);

                    var reader = new FileReader();
                    return new Promise(function (resolve) {
                        reader.addEventListener("loadend", function () {
                            // reader.result contains the contents of blob as a typed array

                            // blob.type === 'application/x-protobuf'
                            var pbf = new index(reader.result);
// 						console.log(pbf);
                            return resolve(new VectorTile(pbf));

                        });
                        reader.readAsArrayBuffer(blob);
                    });
                });
            }).then(function (json) {

// 			console.log('Vector tile:', json.layers);
// 			console.log('Vector tile water:', json.layers.water);	// Instance of VectorTileLayer

                // Normalize feature getters into actual instanced features
                if(Object.keys(json.layers).length > 0) {
                    for (var layerName in json.layers) {
                        var feats = [];

                        for (var i = 0; i < json.layers[layerName].length; i++) {
                            var feat = json.layers[layerName].feature(i);
                            feat.geometry = feat.loadGeometry();
                            feats.push(feat);
                        }

                        json.layers[layerName].features = feats;
                    }
                }

                return json;
            });
        }
    });


    /**
     * @class L.VectorGrid.Protobuf
     * @constructor
     * @param url {string}
     * @param options {object} 外部属性，可重设Properties
     * @returns {LW.CsBaseLayer}
     */
    L.vectorGrid.protobuf = function (url, options) {
        return new L.VectorGrid.Protobuf(url, options);
    };

    var workerCode = __$strToBlobUri("'use strict';\n\nvar simplify_1 = simplify$1;\n\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nfunction simplify$1(points, tolerance) {\n\n    var sqTolerance = tolerance * tolerance,\n        len = points.length,\n        first = 0,\n        last = len - 1,\n        stack = [],\n        i, maxSqDist, sqDist, index;\n\n    // always retain the endpoints (1 is the max value)\n    points[first][2] = 1;\n    points[last][2] = 1;\n\n    // avoid recursion by using a stack\n    while (last) {\n\n        maxSqDist = 0;\n\n        for (i = first + 1; i < last; i++) {\n            sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n            if (sqDist > maxSqDist) {\n                index = i;\n                maxSqDist = sqDist;\n            }\n        }\n\n        if (maxSqDist > sqTolerance) {\n            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate\n            stack.push(first);\n            stack.push(index);\n            first = index;\n\n        } else {\n            last = stack.pop();\n            first = stack.pop();\n        }\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, a, b) {\n\n    var x = a[0], y = a[1],\n        bx = b[0], by = b[1],\n        px = p[0], py = p[1],\n        dx = bx - x,\n        dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n\nvar convert_1 = convert$1;\n\nvar simplify = simplify_1;\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nfunction convert$1(data, tolerance) {\n    var features = [];\n\n    if (data.type === 'FeatureCollection') {\n        for (var i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], tolerance);\n        }\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, tolerance);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, tolerance);\n    }\n    return features;\n}\n\nfunction convertFeature(features, feature, tolerance) {\n    if (feature.geometry === null) {\n        // ignore features with null geometry\n        return;\n    }\n\n    var geom = feature.geometry,\n        type = geom.type,\n        coords = geom.coordinates,\n        tags = feature.properties,\n        i, j, rings, projectedRing;\n\n    if (type === 'Point') {\n        features.push(create(tags, 1, [projectPoint(coords)]));\n\n    } else if (type === 'MultiPoint') {\n        features.push(create(tags, 1, project(coords)));\n\n    } else if (type === 'LineString') {\n        features.push(create(tags, 2, [project(coords, tolerance)]));\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            projectedRing = project(coords[i], tolerance);\n            if (type === 'Polygon') { projectedRing.outer = (i === 0); }\n            rings.push(projectedRing);\n        }\n        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));\n\n    } else if (type === 'MultiPolygon') {\n        rings = [];\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                projectedRing = project(coords[i][j], tolerance);\n                projectedRing.outer = (j === 0);\n                rings.push(projectedRing);\n            }\n        }\n        features.push(create(tags, 3, rings));\n\n    } else if (type === 'GeometryCollection') {\n        for (i = 0; i < geom.geometries.length; i++) {\n            convertFeature(features, {\n                geometry: geom.geometries[i],\n                properties: tags\n            }, tolerance);\n        }\n\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n}\n\nfunction create(tags, type, geometry) {\n    var feature = {\n        geometry: geometry,\n        type: type,\n        tags: tags || null,\n        min: [2, 1], // initial bbox values;\n        max: [-1, 0]  // note that coords are usually in [0..1] range\n    };\n    calcBBox(feature);\n    return feature;\n}\n\nfunction project(lonlats, tolerance) {\n    var projected = [];\n    for (var i = 0; i < lonlats.length; i++) {\n        projected.push(projectPoint(lonlats[i]));\n    }\n    if (tolerance) {\n        simplify(projected, tolerance);\n        calcSize(projected);\n    }\n    return projected;\n}\n\nfunction projectPoint(p) {\n    var sin = Math.sin(p[1] * Math.PI / 180),\n        x = (p[0] / 360 + 0.5),\n        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n\n    y = y < 0 ? 0 :\n        y > 1 ? 1 : y;\n\n    return [x, y, 0];\n}\n\n// calculate area and length of the poly\nfunction calcSize(points) {\n    var area = 0,\n        dist = 0;\n\n    for (var i = 0, a, b; i < points.length - 1; i++) {\n        a = b || points[i];\n        b = points[i + 1];\n\n        area += a[0] * b[1] - b[0] * a[1];\n\n        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation\n        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);\n    }\n    points.area = Math.abs(area / 2);\n    points.dist = dist;\n}\n\n// calculate the feature bounding box for faster clipping later\nfunction calcBBox(feature) {\n    var geometry = feature.geometry,\n        min = feature.min,\n        max = feature.max;\n\n    if (feature.type === 1) { calcRingBBox(min, max, geometry); }\n    else { for (var i = 0; i < geometry.length; i++) { calcRingBBox(min, max, geometry[i]); } }\n\n    return feature;\n}\n\nfunction calcRingBBox(min, max, points) {\n    for (var i = 0, p; i < points.length; i++) {\n        p = points[i];\n        min[0] = Math.min(p[0], min[0]);\n        max[0] = Math.max(p[0], max[0]);\n        min[1] = Math.min(p[1], min[1]);\n        max[1] = Math.max(p[1], max[1]);\n    }\n}\n\nvar tile = transformTile;\nvar point = transformPoint;\n\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nfunction transformTile(tile, extent) {\n    if (tile.transformed) { return tile; }\n\n    var z2 = tile.z2,\n        tx = tile.x,\n        ty = tile.y,\n        i, j, k;\n\n    for (i = 0; i < tile.features.length; i++) {\n        var feature = tile.features[i],\n            geom = feature.geometry,\n            type = feature.type;\n\n        if (type === 1) {\n            for (j = 0; j < geom.length; j++) { geom[j] = transformPoint(geom[j], extent, z2, tx, ty); }\n\n        } else {\n            for (j = 0; j < geom.length; j++) {\n                var ring = geom[j];\n                for (k = 0; k < ring.length; k++) { ring[k] = transformPoint(ring[k], extent, z2, tx, ty); }\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(p, extent, z2, tx, ty) {\n    var x = Math.round(extent * (p[0] * z2 - tx)),\n        y = Math.round(extent * (p[1] * z2 - ty));\n    return [x, y];\n}\n\nvar transform$1 = {\n	tile: tile,\n	point: point\n};\n\nvar clip_1 = clip$1;\n\n/* clip features between two axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \____|____/\n *     |        |\n */\n\nfunction clip$1(features, scale, k1, k2, axis, intersect, minAll, maxAll) {\n\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll <= k2) { return features; } // trivial accept\n    else if (minAll > k2 || maxAll < k1) { return null; } // trivial reject\n\n    var clipped = [];\n\n    for (var i = 0; i < features.length; i++) {\n\n        var feature = features[i],\n            geometry = feature.geometry,\n            type = feature.type,\n            min, max;\n\n        min = feature.min[axis];\n        max = feature.max[axis];\n\n        if (min >= k1 && max <= k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (min > k2 || max < k1) { continue; } // trivial reject\n\n        var slices = type === 1 ?\n                clipPoints(geometry, k1, k2, axis) :\n                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);\n\n        if (slices.length) {\n            // if a feature got clipped, it will likely get clipped on the next zoom level as well,\n            // so there's no need to recalculate bboxes\n            clipped.push({\n                geometry: slices,\n                type: type,\n                tags: features[i].tags || null,\n                min: feature.min,\n                max: feature.max\n            });\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geometry, k1, k2, axis) {\n    var slice = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n        var a = geometry[i],\n            ak = a[axis];\n\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n    }\n    return slice;\n}\n\nfunction clipGeometry(geometry, k1, k2, axis, intersect, closed) {\n\n    var slices = [];\n\n    for (var i = 0; i < geometry.length; i++) {\n\n        var ak = 0,\n            bk = 0,\n            b = null,\n            points = geometry[i],\n            area = points.area,\n            dist = points.dist,\n            outer = points.outer,\n            len = points.length,\n            a, j, last;\n\n        var slice = [];\n\n        for (j = 0; j < len - 1; j++) {\n            a = b || points[j];\n            b = points[j + 1];\n            ak = bk || a[axis];\n            bk = b[axis];\n\n            if (ak < k1) {\n\n                if ((bk > k2)) { // ---|-----|-->\n                    slice.push(intersect(a, b, k1), intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk >= k1) { slice.push(intersect(a, b, k1)); } // ---|-->  |\n\n            } else if (ak > k2) {\n\n                if ((bk < k1)) { // <--|-----|---\n                    slice.push(intersect(a, b, k2), intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk <= k2) { slice.push(intersect(a, b, k2)); } // |  <--|---\n\n            } else {\n\n                slice.push(a);\n\n                if (bk < k1) { // <--|---  |\n                    slice.push(intersect(a, b, k1));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n\n                } else if (bk > k2) { // |  ---|-->\n                    slice.push(intersect(a, b, k2));\n                    if (!closed) { slice = newSlice(slices, slice, area, dist, outer); }\n                }\n                // | --> |\n            }\n        }\n\n        // add the last point\n        a = points[len - 1];\n        ak = a[axis];\n        if (ak >= k1 && ak <= k2) { slice.push(a); }\n\n        // close the polygon if its endpoints are not the same after clipping\n\n        last = slice[slice.length - 1];\n        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) { slice.push(slice[0]); }\n\n        // add the final slice\n        newSlice(slices, slice, area, dist, outer);\n    }\n\n    return slices;\n}\n\nfunction newSlice(slices, slice, area, dist, outer) {\n    if (slice.length) {\n        // we don't recalculate the area/length of the unclipped geometry because the case where it goes\n        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work\n        slice.area = area;\n        slice.dist = dist;\n        if (outer !== undefined) { slice.outer = outer; }\n\n        slices.push(slice);\n    }\n    return [];\n}\n\nvar clip$2 = clip_1;\n\nvar wrap_1 = wrap$1;\n\nfunction wrap$1(features, buffer, intersectX) {\n    var merged = features,\n        left  = clip$2(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy\n        right = clip$2(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy\n\n    if (left || right) {\n        merged = clip$2(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy\n\n        if (left) { merged = shiftFeatureCoords(left, 1).concat(merged); } // merge left into center\n        if (right) { merged = merged.concat(shiftFeatureCoords(right, -1)); } // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    var newFeatures = [];\n\n    for (var i = 0; i < features.length; i++) {\n        var feature = features[i],\n            type = feature.type;\n\n        var newGeometry;\n\n        if (type === 1) {\n            newGeometry = shiftCoords(feature.geometry, offset);\n        } else {\n            newGeometry = [];\n            for (var j = 0; j < feature.geometry.length; j++) {\n                newGeometry.push(shiftCoords(feature.geometry[j], offset));\n            }\n        }\n\n        newFeatures.push({\n            geometry: newGeometry,\n            type: type,\n            tags: feature.tags,\n            min: [feature.min[0] + offset, feature.min[1]],\n            max: [feature.max[0] + offset, feature.max[1]]\n        });\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    var newPoints = [];\n    newPoints.area = points.area;\n    newPoints.dist = points.dist;\n\n    for (var i = 0; i < points.length; i++) {\n        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);\n    }\n    return newPoints;\n}\n\nvar tile$1 = createTile$1;\n\nfunction createTile$1(features, z2, tx, ty, tolerance, noSimplify) {\n    var tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: tx,\n        y: ty,\n        z2: z2,\n        transformed: false,\n        min: [2, 1],\n        max: [-1, 0]\n    };\n    for (var i = 0; i < features.length; i++) {\n        tile.numFeatures++;\n        addFeature(tile, features[i], tolerance, noSimplify);\n\n        var min = features[i].min,\n            max = features[i].max;\n\n        if (min[0] < tile.min[0]) { tile.min[0] = min[0]; }\n        if (min[1] < tile.min[1]) { tile.min[1] = min[1]; }\n        if (max[0] > tile.max[0]) { tile.max[0] = max[0]; }\n        if (max[1] > tile.max[1]) { tile.max[1] = max[1]; }\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, noSimplify) {\n\n    var geom = feature.geometry,\n        type = feature.type,\n        simplified = [],\n        sqTolerance = tolerance * tolerance,\n        i, j, ring, p;\n\n    if (type === 1) {\n        for (i = 0; i < geom.length; i++) {\n            simplified.push(geom[i]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else {\n\n        // simplify and transform projected coordinates for tile geometry\n        for (i = 0; i < geom.length; i++) {\n            ring = geom[i];\n\n            // filter out tiny polylines & polygons\n            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||\n                                (type === 3 && ring.area < sqTolerance))) {\n                tile.numPoints += ring.length;\n                continue;\n            }\n\n            var simplifiedRing = [];\n\n            for (j = 0; j < ring.length; j++) {\n                p = ring[j];\n                // keep points with importance > tolerance\n                if (noSimplify || p[2] > sqTolerance) {\n                    simplifiedRing.push(p);\n                    tile.numSimplified++;\n                }\n                tile.numPoints++;\n            }\n\n            if (type === 3) { rewind(simplifiedRing, ring.outer); }\n\n            simplified.push(simplifiedRing);\n        }\n    }\n\n    if (simplified.length) {\n        tile.features.push({\n            geometry: simplified,\n            type: type,\n            tags: feature.tags || null\n        });\n    }\n}\n\nfunction rewind(ring, clockwise) {\n    var area = signedArea(ring);\n    if (area < 0 === clockwise) { ring.reverse(); }\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n\nvar index = geojsonvt;\n\nvar convert = convert_1;\nvar transform = transform$1;\nvar clip = clip_1;\nvar wrap = wrap_1;\nvar createTile = tile$1;     // final simplified tile generation\n\n\nfunction geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) { console.time('preprocess data'); }\n\n    var z2 = 1 << options.maxZoom, // 2^z\n        features = convert(data, options.tolerance / (z2 * options.extent));\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = wrap(features, options.buffer / options.extent, intersectX);\n\n    // start slicing from the top tile down\n    if (features.length) { this.splitTile(features, 0, 0, 0); }\n\n    if (debug) {\n        if (features.length) { console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints); }\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    solidChildren: false,   // whether to tile solid square tiles further\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n    var this$1 = this;\n\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug,\n        solid = null;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this$1.tiles[id],\n            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);\n\n        if (!tile) {\n            if (debug > 1) { console.time('creation'); }\n\n            tile = this$1.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);\n            this$1.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this$1.stats[key] = (this$1.stats[key] || 0) + 1;\n                this$1.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) { continue; }\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) { continue; }\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) { continue; }\n        }\n\n        // stop tiling if the tile is solid clipped square\n        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {\n            if (cz) { solid = z; } // and remember the zoom if we're drilling down\n            continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (debug > 1) { console.time('clipping'); }\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);\n        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);\n\n        if (left) {\n            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (right) {\n            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);\n            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);\n        }\n\n        if (debug > 1) { console.timeEnd('clipping'); }\n\n        if (tl) { stack.push(tl, z + 1, x * 2,     y * 2); }\n        if (bl) { stack.push(bl, z + 1, x * 2,     y * 2 + 1); }\n        if (tr) { stack.push(tr, z + 1, x * 2 + 1, y * 2); }\n        if (br) { stack.push(br, z + 1, x * 2 + 1, y * 2 + 1); }\n    }\n\n    return solid;\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var this$1 = this;\n\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) { return transform.tile(this.tiles[id], extent); }\n\n    if (debug > 1) { console.log('drilling down to z%d-%d-%d', z, x, y); }\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this$1.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) { return null; }\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) { console.log('found parent tile z%d-%d-%d', z0, x0, y0); }\n\n    // it parent tile is a solid clipped square, return it instead since it's identical\n    if (isClippedSquare(parent, extent, options.buffer)) { return transform.tile(parent, extent); }\n\n    if (debug > 1) { console.time('drilling down'); }\n    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) { console.timeEnd('drilling down'); }\n\n    // one of the parent tiles was a solid clipped square\n    if (solid !== null) {\n        var m = 1 << (z - solid);\n        id = toID(solid, Math.floor(x / m), Math.floor(y / m));\n    }\n\n    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction intersectX(a, b, x) {\n    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];\n}\nfunction intersectY(a, b, y) {\n    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];\n}\n\nfunction extend(dest, src) {\n    for (var i in src) { dest[i] = src[i]; }\n    return dest;\n}\n\n// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further\nfunction isClippedSquare(tile, extent, buffer) {\n\n    var features = tile.source;\n    if (features.length !== 1) { return false; }\n\n    var feature = features[0];\n    if (feature.type !== 3 || feature.geometry.length > 1) { return false; }\n\n    var len = feature.geometry[0].length;\n    if (len !== 5) { return false; }\n\n    for (var i = 0; i < len; i++) {\n        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);\n        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||\n            (p[1] !== -buffer && p[1] !== extent + buffer)) { return false; }\n    }\n\n    return true;\n}\n\nvar identity = function(x) {\n  return x;\n};\n\nvar transform$3 = function(topology) {\n  if ((transform = topology.transform) == null) { return identity; }\n  var transform,\n      x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(point, i) {\n    if (!i) { x0 = y0 = 0; }\n    point[0] = (x0 += point[0]) * kx + dx;\n    point[1] = (y0 += point[1]) * ky + dy;\n    return point;\n  };\n};\n\nvar bbox = function(topology) {\n  var bbox = topology.bbox;\n\n  function bboxPoint(p0) {\n    p1[0] = p0[0], p1[1] = p0[1], t(p1);\n    if (p1[0] < x0) { x0 = p1[0]; }\n    if (p1[0] > x1) { x1 = p1[0]; }\n    if (p1[1] < y0) { y0 = p1[1]; }\n    if (p1[1] > y1) { y1 = p1[1]; }\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  if (!bbox) {\n    var t = transform$3(topology), p0, p1 = new Array(2), name,\n        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n    topology.arcs.forEach(function(arc) {\n      var i = -1, n = arc.length;\n      while (++i < n) {\n        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);\n        if (p1[0] < x0) { x0 = p1[0]; }\n        if (p1[0] > x1) { x1 = p1[0]; }\n        if (p1[1] < y0) { y0 = p1[1]; }\n        if (p1[1] > y1) { y1 = p1[1]; }\n      }\n    });\n\n    for (name in topology.objects) {\n      bboxGeometry(topology.objects[name]);\n    }\n\n    bbox = topology.bbox = [x0, y0, x1, y1];\n  }\n\n  return bbox;\n};\n\nvar reverse = function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) { t = array[i], array[i++] = array[j], array[j] = t; }\n};\n\nvar feature = function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n};\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform$3(topology),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) { points.pop(); }\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k].slice(), k));\n    }\n    if (i < 0) { reverse(points, n); }\n  }\n\n  function point(p) {\n    return transformPoint(p.slice());\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) { arc(arcs[i], points); }\n    if (points.length < 2) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) { points.push(points[0].slice()); }\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nvar stitch = function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) { p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; }); }\n    else { p1 = arc[arc.length - 1]; }\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) { fragments.push([i]); } });\n\n  return fragments;\n};\n\nfunction extractArcs(topology, object$$1, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object$$1);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) { arcs.push(geoms[0].i); } });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) { a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0]; }\n  return Math.abs(area); // Note: doubled area!\n}\n\nvar bisect = function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nvar slicers = {};\nvar options;\n\nonmessage = function (e) {\n	if (e.data[0] === 'slice') {\n		// Given a blob of GeoJSON and some topojson/geojson-vt options, do the slicing.\n		var geojson = e.data[1];\n		options     = e.data[2];\n\n		if (geojson.type && geojson.type === 'Topology') {\n			for (var layerName in geojson.objects) {\n				slicers[layerName] = index(\n					feature(geojson, geojson.objects[layerName])\n				, options);\n			}\n		} else {\n			slicers[options.vectorTileLayerName] = index(geojson, options);\n		}\n\n	} else if (e.data[0] === 'get') {\n		// Gets the vector tile for the given coordinates, sends it back as a message\n		var coords = e.data[1];\n\n		var tileLayers = {};\n		for (var layerName in slicers) {\n			var slicedTileLayer = slicers[layerName].getTile(coords.z, coords.x, coords.y);\n\n			if (slicedTileLayer) {\n				var vectorTileLayer = {\n					features: [],\n					extent: options.extent,\n					name: options.vectorTileLayerName,\n					length: slicedTileLayer.features.length\n				};\n\n				for (var i in slicedTileLayer.features) {\n					var feat = {\n						geometry: slicedTileLayer.features[i].geometry,\n						properties: slicedTileLayer.features[i].tags,\n						type: slicedTileLayer.features[i].type	// 1 = point, 2 = line, 3 = polygon\n					};\n					vectorTileLayer.features.push(feat);\n				}\n				tileLayers[layerName] = vectorTileLayer;\n			}\n		}\n		postMessage({ layers: tileLayers, coords: coords });\n	}\n};\n//# sourceMap" + "pingURL=slicerWebWorker.js.worker.map\n", "text/plain; charset=us-ascii", false);

    /**
     * L.VectorGrid.Slicer
     */

    L.VectorGrid.Slicer = L.VectorGrid.extend({

        options: {
            vectorTileLayerName: 'sliced',

            extent: 4096,	// Default for geojson-vt
            maxZoom: 14  	// Default for geojson-vt
        },

        initialize: function (geojson, options) {
            L.VectorGrid.prototype.initialize.call(this, options);

            // Create a shallow copy of this.options, excluding things that might
            // be functions - we only care about topojson/geojsonvt options
            var options = {};
            for (var i in this.options) {
                if (i !== 'rendererFactory' &&
                    i !== 'vectorTileLayerStyles' &&
                    typeof (this.options[i]) !== 'function'
                ) {
                    options[i] = this.options[i];
                }
            }

// 		this._worker = new Worker(window.URL.createObjectURL(new Blob([workerCode])));
            this._worker = new Worker(workerCode);

            // Send initial data to worker.
            this._worker.postMessage(['slice', geojson, options]);
        },

        _getVectorTilePromise: function (coords) {
            var _this = this;

            var p = new Promise(function waitForWorker(res) {
                _this._worker.addEventListener('message', function recv(m) {
                    if (m.data.coords &&
                        m.data.coords.x === coords.x &&
                        m.data.coords.y === coords.y &&
                        m.data.coords.z === coords.z) {

                        res(m.data);
                        _this._worker.removeEventListener('message', recv);
                    }
                });
            });

            this._worker.postMessage(['get', coords]);

            return p;
        },

    });


    L.vectorGrid.slicer = function (geojson, options) {
        return new L.VectorGrid.Slicer(geojson, options);
    };

    L.Canvas.Tile = L.Canvas.extend({
        initialize: function (tileCoord, tileSize, options) {
            L.Canvas.prototype.initialize.call(this, options);
            this._tileCoord = tileCoord;
            this._size = tileSize;

            this._initContainer();
            this._container.setAttribute('width', this._size.x);
            this._container.setAttribute('height', this._size.y);
            this._layers = {};
            this._drawnLayers = {};
            this._drawing = true;

            if (options.interactive) {
                // By default, Leaflet tiles do not have pointer events
                this._container.style.pointerEvents = 'auto';
            }
        },

        _initContainer: function () {
            var container = this._container = document.createElement('canvas');

            L.DomEvent
                .on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
                .on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
                .on(container, 'mouseout', this._handleMouseOut, this);

            this._ctx = container.getContext('2d');
        },

        getCoord: function () {
            return this._tileCoord;
        },

        getContainer: function () {
            return this._container;
        },

        getOffset: function () {
            return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
        },

        onAdd: L.Util.falseFn,

        addTo: function (map) {
            this._map = map;
        },

        removeFrom: function (map) {
            delete this._map;
        },

        _onClick: function (e) {
            var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset()), layer, clickedLayer;

            for (var id in this._layers) {
                layer = this._layers[id];
                if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
                    clickedLayer = layer;
                }
            }
            if (clickedLayer) {
                // L.DomEvent.fakeStop(e);
                this._fireEvent([clickedLayer], e);
            }
        },

        _onMouseMove: function (e) {
            if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
                return;
            }

            var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset());
            this._handleMouseHover(e, point);
        },

        /// TODO: Modify _initPath to include an extra parameter, a group name
        /// to order symbolizers by z-index
        _updateIcon: function (layer) {
            if (!this._drawing) {
                return;
            }

            var icon = layer.options.icon,
                options = icon.options,
                size = L.point(options.iconSize),
                anchor = options.iconAnchor ||
                    size && size.divideBy(2, true),
                p = layer._point.subtract(anchor),
                ctx = this._ctx,
                img = layer._getImage();

            if (img.complete) {
                ctx.drawImage(img, p.x, p.y, size.x, size.y);
            } else {
                L.DomEvent.on(img, 'load', function () {
                    ctx.drawImage(img, p.x, p.y, size.x, size.y);
                });
            }

            this._drawnLayers[layer._leaflet_id] = layer;
        }
    });


    L.canvas.tile = function (tileCoord, tileSize, opts) {
        return new L.Canvas.Tile(tileCoord, tileSize, opts);
    };
})();


/**
 * Created by whl on 2015/9/18.
 */
LW.LabelIcon = L.Icon.extend({
    options: {
        iconSize: new L.Point(40, 18),
        color: '#000',
        fontSize: '12px',
        textAlign:'center',
        edge: true,
        bold: false,
        // pointerEvents:'none',
        fontFamily:'Microsft YaHei',
        className:''
    },

    label: null,

    getIcon: function () {
        return this.label;
    },

    createIcon: function () {
        this.label = L.DomUtil.create('p', this.options.className);
        this.label.style.color = this.options.color;
        this.label.style.fontSize = this.options.fontSize;
        this.label.style.fontFamily = this.options.fontFamily;
        this.label.style.width = this.options.iconSize.x + 'px';
        this.label.style.textAlign = this.options.textAlign;
        // this.label.style.pointerEvents = this.options.pointerEvents;
        this.label.style.lineHeight = this.options.iconSize.y + 'px';
        if (this.options.bold)
            this.label.style.fontWeight = 'bold';
        if (this.options.edge)
            this.label.style.textShadow = '1px 0px 0px #fff,-1px 0px 0px #fff,0px 1px 0px #fff,0px -1px 0px #fff';

        this._setIconStyles(this.label, "icon");
        return this.label;
    },

    _setIconStyles: function (img, name) {
        var options = this.options,
            size = L.point(options[name + 'Size']),
            anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
                size && size.divideBy(2, true));

        img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

        if (anchor) {
            img.style.marginLeft = (-anchor.x) + 'px';
            img.style.marginTop  = (-anchor.y) + 'px';
        }
    },

    setData: function (value,rotation ) {
        // this.label.innerText = String(value);
        this.label.innerHTML = String(value);
        this.rotation = rotation;
        this.setRotation();
    },

    setStyle: function (style) {
        for(var key in style){
            this.options[key] = style[key];
            this.label.style[key] = style[key];
        }
    },

    setRotation: function () {
        if (this.rotation) {
            var rotation = this.rotation;
            var size = this.options.iconSize;
            rotation = rotation < -90 || rotation > 90 ? rotation + 180 : rotation;
            this.label.style.transform += "translate(" + size.x / 2 + "px," + size.y / 2 + "px)";
            this.label.style.transform += "rotate(" + rotation + "deg)";
            this.label.style.transform += "translate(" + -size.x / 2 + "px," + -size.y / 2 + "px)";
        }

        //this.label.style.msTransform += "rotate(" + rotation + "deg)";
        //this.label.style.webkitTransform += "rotate(" + rotation + "deg)";
        //this.label.style.MozTransform += "rotate(" + rotation + "deg)";
        //this.label.style.OTransform += "rotate(" + rotation + "deg)";
    },
    setLabelVisible: function (visible) {
        this.label.style.display = visible ? 'block' : 'none';
    }
});

/**
 * name icon
 * 带有名字的Icon
 */
LW.NameIcon = L.Icon.extend({

    options: {
        radius: 2,
        color: '#fff',
        iconSize: new L.Point(60, 50),
        iconType: 'image',//(image/graph/dyImage)
        strokeColor: '#333'
        //dyImageUrlFun:'' /*动态图片取地址Function*/
        //nameLabelClass:''
        //imageSize: new L.Point(25, 25)
    },

    container: null,
    dot: null,
    nameLabel: null,

    getIcon: function () {
        return this.container;
    },

    createIcon: function (oldIcon) {
        this.container = document.createElement('div');
        if (this.options.iconType == 'image' || this.options.iconType == 'dyImage') {
            this.dot = document.createElement("img");
            if (this.options.iconType == 'image')
                this.dot.src = this.options.iconUrl;
        } else
            this.dot = document.createElement("canvas");
        this.container.appendChild(this.dot);
        this._createLabel();
        this._setIconStyles(this.container, "icon");
        this._setStyle();
        this._setLabelStyle();
    },
    _createLabel: function () {
        this.nameLabel = document.createElement("p");
        this.container.appendChild(this.nameLabel);
    },

    _setStyle: function () {
        var iconSize = this.options.iconSize;
        if (this.options.iconType == 'graph') {
            this.dot.width = iconSize.x;
            this.dot.height = iconSize.y;
        }
        else {//图片布局
            if (this.options.imageSize) {
                this.dot.width = this.options.imageSize.x;
                this.dot.height = this.options.imageSize.y;
                Sun.Util.Layout.center(this.dot, iconSize.x, iconSize.y);
            }
            else {
                if (this.dot.complete)
                    Sun.Util.Layout.center(this.dot, iconSize.x, iconSize.y);
                else {
                    this.dot.onload = function (e) {
                        Sun.Util.Layout.center(e.target, iconSize.x, iconSize.y);
                    };
                }
            }
        }
    },
    _setLabelStyle: function () {
        this.nameLabel.className = this.options.nameLabelClass;
        this.nameLabel.style.width = this.options.iconSize.x;
        this.nameLabel.style.textAlign = 'center';
    },

    _drawDot: function () {
        var ctx = this.dot.getContext("2d");
        var w = this.options.iconSize.x;
        var h = this.options.iconSize.y;
        if (!ctx) return;
        ctx.clearRect(0,0,w,h);
        ctx.beginPath();
        ctx.fillStyle = this.options.color;
        ctx.strokeStyle = this.options.strokeColor;
        ctx.lineWidth = 1;
        var radius = this.options.radius;
        ctx.arc(w / 2, h / 2, radius, 0, Math.PI * 2, false);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    },

    reDrawDot: function (color) {
        if (this.options.iconType == 'graph') {
            var ctx = this.dot.getContext("2d");
            var w = this.options.iconSize.x;
            var h = this.options.iconSize.y;
            if (!ctx) return;
            ctx.clearRect(0, 0, w, h);
            this.options.color = color;
            this._drawDot();
        }
    },

    setData: function (data, stationName) {
        this.nameLabel.innerText = stationName ? stationName : '';
        if (this.options.iconType == 'dyImage') {
            this.dot.src = this.options.dyImageUrlFun(data);
            this._setStyle();
        }
        else if (this.options.iconType == 'graph')
            this._drawDot();
    },

    setNameLabelVisible: function (visible) {
        this.nameLabel.style.display = visible ? 'block' : 'none';
    }
});

/**
 * value icon
 * 带有值的Icon
 */
LW.ValueIcon = LW.NameIcon.extend({

    options: {
        iconType: 'graph',//(image/graph/dyImage)
        //valueLabelClass:''
        codeLabelClass: '',
        codeLabelVisible: false
    },

    valueLabel: null,
    codeLabel: null,

    _createLabel: function () {
        this.valueLabel = document.createElement("p");
        this.container.appendChild(this.valueLabel);
        this.nameLabel = document.createElement("p");
        this.container.appendChild(this.nameLabel);
        this.codeLabel = document.createElement("p");
        this.container.appendChild(this.codeLabel);
    },
    _setLabelStyle: function () {
        this.valueLabel.style.height = '18px';
        this.valueLabel.className = this.options.valueLabelClass;
        this.valueLabel.style.width = this.options.iconSize.x;
        this.valueLabel.style.textAlign = 'center';

        this.nameLabel.className = this.options.nameLabelClass;
        this.nameLabel.style.width = this.options.iconSize.x;
        this.nameLabel.style.textAlign = 'center';

        if (this.codeLabel) {
            this.codeLabel.className = this.options.codeLabelClass;
            this.codeLabel.style.width = this.options.iconSize.x;
            this.codeLabel.style.textAlign = 'center';
            this.codeLabel.style.visibility = this.options.codeLabelVisible ? 'visible' : 'hidden';
        }
    },

    setData: function (stationName, value, code) {
        this.valueLabel.innerText = value == null || isNaN(value) || value ==0 ? '  ' : value;
        this.nameLabel.innerText = stationName;
        this.codeLabel.innerText = code == null || code == undefined ? ' ' : code;
        if (this.options.iconType == 'dyImage') {
            this.dot.src = this.options.dyImageUrlFun(value);
            this._setStyle();
        }
        else if (this.options.iconType == 'graph')
            this._drawDot();
    },

    setValueLabelVisible: function (visible) {
        this.valueLabel.style.visibility = visible ? 'visible' : 'hidden';
    },

    setNameLabelVisible: function (visible) {
        this.nameLabel.style.display = visible ? 'block' : 'none';
        this.codeLabel.className = visible ? this.options.codeLabelClass : this.options.nameLabelClass;
    },

    setCodeLabelVisible: function (visible) {
        this.codeLabel.style.visibility = visible ? 'visible' : 'hidden';
    },

    setStyle: function (style,type) {
        if(type == 'radius'){
            this.options.radius = style;
            this._drawDot();
        }
        else{
            var label = type=='name'?this.nameLabel:this.valueLabel;
            for(var key in style){
                label.style[key] = style[key];
            }
        }
    }
});

/**
 * base zdz wind icon
 * 基础自动站风Icon
 */
LW.BaseZdzWindIcon = LW.ValueIcon.extend({
    options: {
        radius: 2,
        windVaneWidth: 1,
        windVaneColor: '#000',
        windVaneLength: 32,
        iconSize: new L.Point(80, 60)
        //windDirection: 0,
        //windSpeed: 0
    },
    canvas: null,

    createIcon: function (oldIcon) {
        this.container = document.createElement('div');
        this.dot = document.createElement("canvas");
        this.container.appendChild(this.dot);
        if (this.options.iconType == 'image') {
            this.img = document.createElement("img");
            this.img.src = this.options.iconUrl;
            this.container.appendChild(this.img);
        }
        this._createLabel();
        this._setIconStyles(this.container, "icon");
        this._setStyle();
        this._setLabelStyle();
        return this.container;
    },
    _setStyle: function () {
        var iconSize = this.options.iconSize;

        this.dot.width = iconSize.x;
        this.dot.height = iconSize.y;
        if (this.options.iconType == 'image') {//图片布局
            if (this.options.imageSize) {
                this.img.width = this.options.imageSize.x;
                this.img.height = this.options.imageSize.y;
            }
            if (this.img.complete) {
                Sun.Util.Layout.center(this.img, iconSize.x, iconSize.y);
            }
            else {
                this.img.onload = function (e) {
                    Sun.Util.Layout.center(e.target, iconSize.x, iconSize.y);
                };
            }
        }
    },
    _drawWind: function () {
        var ctx = this.dot.getContext("2d");
        var w = this.options.iconSize.x;
        var h = this.options.iconSize.y;
        if (!ctx) return;
        if (this.options.windSpeed == 0 || this.options.windDirection == 0) return;
        ctx.lineWidth = this.options.windVaneWidth;
        ctx.strokeStyle = this.options.windVaneColor;
        Sun.Util.Geometry.drawWind(ctx, this.options.windSpeed, this.options.windDirection, w, h, this.options.windVaneLength);
    },

    setData: function (stationName, windSpeed, windDirection, code) {
        this.valueLabel.innerText = (windSpeed == null || windSpeed == 999.9) ? ' ' : windSpeed;
        this.nameLabel.innerText = stationName;
        this.codeLabel.innerText = code == null || code == undefined ? ' ' : code;
        if (this.options.iconType == 'graph')
            this._drawDot();
        this._setWindData(windSpeed, windDirection);
    },

    _setWindData: function (windSpeed, windDirection, stationName) {
        //this.options.windDirection = (windDirection % 360) - (11.25 % 360);
        this.options.windDirection = windDirection;
        this.options.windSpeed = windSpeed;
        this._drawWind();
    },

    setStyle: function (style,type) {
        if(type == 'radius'){
            this.options.radius = style;
            this._drawDot();
            this.options.windDirection = 360;//Tip:重新绘制后似乎会记住上次rotate且网上增加，所以把这个设为360
            this._drawWind();
        }
        else{
            var label = type=='name'?this.nameLabel:this.valueLabel;
            for(var key in style){
                label.style[key] = style[key];
            }
        }
    }
});

/**
 * synthetical zdz icon
 * 自动站综合填图Icon
 */
LW.SynZdzIcon = LW.BaseZdzWindIcon.extend({
    options: {
        iconSize: new L.Point(80, 80),
        iconType: 'image'
    },

    valueLabelLeft: null,
    valueLabelRight: null,

    _createLabel: function () {
        this.valueLabel = document.createElement("p");
        this.container.appendChild(this.valueLabel);

        this.valueLabelLeft = document.createElement("p");
        this.container.appendChild(this.valueLabelLeft);

        this.valueLabelRight = document.createElement("p");
        this.container.appendChild(this.valueLabelRight);

        this.nameLabel = document.createElement("p");
        this.container.appendChild(this.nameLabel);
    },
    _setAroundLabelStyle: function () {
        this.valueLabel.style.color = '#000';
        this.valueLabelLeft.className = this.options.valueLabelClass;
        this.valueLabelLeft.style.color = '#000';
        this.valueLabelLeft.style.position = 'absolute';
        this.valueLabelLeft.style.top = '18px';
        this.valueLabelLeft.style.right = this.options.iconSize.x / 2 + 8 + 'px';
        this.valueLabelRight.className = this.options.valueLabelClass;
        this.valueLabelRight.style.color = '#000';
        this.valueLabelRight.style.position = 'absolute';
        this.valueLabelRight.style.top = '18px';
        this.valueLabelRight.style.left = this.options.iconSize.x / 2 + 8 + 'px';
    },

    setData: function (stationName, value, valueLeft, valueRight, windSpeed, windDirection) {
        this.valueLabel.innerText = Sun.Util.isValid(value) ? value : '  ';
        this.valueLabelLeft.innerText = Sun.Util.isValid(valueLeft) ? valueLeft : '  ';
        this.valueLabelRight.innerText = Sun.Util.isValid(valueRight) ? valueRight : '  ';
        this.nameLabel.innerText = stationName;
        if (this.options.iconType == 'graph')
            this._drawDot();
        if (windSpeed && windDirection)
            this._setWindData(windSpeed, windDirection);
        this._setAroundLabelStyle();
    },

    setValueLabelLeftVisible: function (visible) {
        this.valueLabelLeft.style.visibility = visible;
    },

    setValueLabelRightVisible: function (visible) {
        this.valueLabelRight.style.visibility = visible;
    }
});

/**
 * water level icon
 * 水位Icon
 */
LW.WaterLevelIcon = LW.ValueIcon.extend({
    options: {
        imageSize: new L.Point(20, 20),
        iconSize: new L.Point(120, 60)
    },

    statusContainer: null,
    dot2: null,

    createIcon: function (oldIcon) {
        this.container = document.createElement('div');
        this.statusContainer = document.createElement('div');
        this.container.appendChild(this.statusContainer);
        this.dot = document.createElement("img");
        this.statusContainer.appendChild(this.dot);
        this.dot2 = document.createElement("img");
        this.statusContainer.appendChild(this.dot2);
        this._createLabel();
        this._setIconStyles(this.container, "icon");
        this._setStyle();
        this._setLabelStyle();
    },
    _setStyle: function () {
        var iconSize = this.options.iconSize;
        this.dot.width = this.options.imageSize.x;
        this.dot.height = this.options.imageSize.y;
    },
    _setWaterStatusStyle: function () {
        this.statusContainer.width = this.dot.width + this.dot2.width;
        this.statusContainer.height = this.options.imageSize.y;
        Sun.Util.Layout.center(this.statusContainer, this.options.iconSize.x, this.options.iconSize.y);
    },
    setData: function (stationName, value, limitStatus, changedStatus) {
        this.valueLabel.innerText = value == null || isNaN(value) ? '  ' : value;
        this.nameLabel.innerText = stationName;
        this.dot.src = this.options.iconUrl + limitStatus + '.png';
        if (changedStatus != WaterlevelStatus.NONE) {
            this.dot2.width = this.options.imageSize.x;
            this.dot2.height = this.options.imageSize.y;
            this.dot2.src = this.options.iconUrl + changedStatus + '.png';
        }
        this._setWaterStatusStyle();
    }
});



/**
 * L.Marker增加可以设置的rotation的功能
 * Update Note ：
 *      + v1.5.5 ：Created
 */
L.DomUtil.setRotation = function(el, rotation, anchor){
    el.style.transform += "translate(" + anchor[0] + "px," + anchor[1] + "px)";
    el.style.transform += 'rotate('+rotation+'deg)';
    el.style.transform += "translate(" + -anchor[0] + "px," + -anchor[1] + "px)";
};
L.Marker.prototype._setPos= function (pos) {
    L.DomUtil.setPosition(this._icon, pos);

    var iconOptions = this.options.icon.options;
    if(iconOptions.rotation)
        L.DomUtil.setRotation(this._icon,iconOptions.rotation,iconOptions.iconAnchor);

    this._zIndex = pos.y + this.options.zIndexOffset;

    this._resetZIndex();
}

/**
 * Created by whl on 2015/9/18.
 */

LW.BaseMarker = L.Marker.extend({

    initialize: function (latlng, options) {
        L.setOptions(this, options);
        this._latlng = L.latLng(latlng);
        options.icon.createIcon(this._icon);
    },

    _initIcon: function () {
        var options = this.options,
            classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');


        var icon = options.icon.getIcon(),
            addIcon = false;

        // if we're not reusing the icon, remove the old one and init new one
        if (icon !== this._icon) {
            if (this._icon) {
                this._removeIcon();
            }
            addIcon = true;

            if (options.title) {
                icon.title = options.title;
            }
            if (options.alt) {
                icon.alt = options.alt;
            }
        }

        L.DomUtil.addClass(icon, classToAdd);

        if (options.keyboard) {
            icon.tabIndex = '0';
        }

        this._icon = icon;

        if (options.riseOnHover) {
            this.on({
                mouseover: this._bringToFront,
                mouseout: this._resetZIndex
            });
        }

        var newShadow = options.icon.createShadow(this._shadow),
            addShadow = false;

        if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
        }

        if (newShadow) {
            L.DomUtil.addClass(newShadow, classToAdd);
        }
        this._shadow = newShadow;


        if (options.opacity < 1) {
            this._updateOpacity();
        }


        if (addIcon) {
            this.getPane().appendChild(this._icon);
            this._initInteraction();
        }
        if (newShadow && addShadow) {
            this.getPane('shadowPane').appendChild(this._shadow);
        }
    }
});

/**
 * 纯文本 Marker
 * 支持设置旋转角度
 */
LW.LabelMarker = LW.BaseMarker.extend({

    /**
     * 设置文本值
     * @param value 值
     * @param rotation 旋转角度
     * @returns {L.LabelMarker}
     */
    setData: function (value, rotation) {
        this.value = value;
        this.options.icon.setData(value, rotation);
        return this;
    },
    _setPos: function (pos) {
        L.DomUtil.setPosition(this._icon, pos);
        this.options.icon.setRotation();

        this._zIndex = pos.y + this.options.zIndexOffset;

        this._resetZIndex();
    },
    setLabelVisible: function (visible) {
        this.options.icon.setLabelVisible(visible);
    },
    getValueInvalidity: function () {
        return (this.value == null || isNaN(this.value));
    }
});

LW.labelMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.LabelIcon(options.iconOptions);
    return new LW.LabelMarker(latlng, options);
};

/**
 * name Marker
 * 带有名字的Marker
 */
LW.NameMarker = LW.BaseMarker.extend({
    options: {
        nameField: 'STATIONNAME'
    },
    data: null,

    setData: function (data) {
        this.data = data;
        var nameText = data[this.options.nameField];
        this.options.icon.setData(data, nameText);
    },

    reDrawDot: function (color) {
        this.options.icon.reDrawDot(color);
    },

    setNameLabelVisible: function (visible) {
        this.options.icon.setNameLabelVisible(visible);
    }

});

LW.nameMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.NameIcon(options.iconOptions);
    return new LW.NameMarker(latlng, options);
};

/**
 * value Marker
 * 带有值的Marker
 */
LW.ValueMarker = LW.NameMarker.extend({
    options: {
        //valueField: '',
        //scale:1,
        codeField: 'STATIONCODE',
        legendData: null,
        invalidValue: ''
    },

    value: null,

    setData: function (data,dataField) {
        this._setData(data,dataField);
        this.options.icon.options.color = Sun.Util.LegendData.getColorOfRangeLegend(this.options.legendData, this.value);
        this.options.icon.setData(this.nameText, this.value, this.code);
    },

    _setData: function (data,dataField) {
        this.data = data;
        this.dataField = dataField;
        var value = Sun.Util.Data.getValueByField(data,this.options.valueField,dataField);
        this.nameText = Sun.Util.Data.getValueByField(data,this.options.nameField,dataField);
        this.code = Sun.Util.Data.getValueByField(data,this.options.codeField,dataField);
        if (this.options.scale && value != null) {
            value = String(value * this.options.scale);
            value = parseFloat(value.substr(0, value.indexOf(".") + 4));
        }
        this.value = value;
    },

    getValueInvalidity: function (value) {
        value = value || this.value;
        return (value == null || isNaN(value) || value == this.options.invalidValue);
    },

    setValueLabelVisible: function (visible) {
        this.options.icon.setValueLabelVisible(visible);
    },

    setCodeLabelVisible: function (value) {
        this.options.icon.setCodeLabelVisible(value);
    }
});

LW.valueMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.ValueIcon(options.iconOptions);
    return new LW.ValueMarker(latlng, options);
};

/**
 * base zdz wind marker
 * 基础自动站风Marker
 */
LW.BaseZdzWindMarker = LW.ValueMarker.extend({
    options: {
        dirField: ''
    },
    setData: function (data,dataField) {
        this._setData(data,dataField);
        this.options.icon.options.color = Sun.Util.LegendData.getColorOfRangeLegend(this.options.legendData, this.value);
        if (this.value > 10.8) {
            this.options.icon.options.windVaneWidth = 2;
            this.options.icon.options.windVaneColor = this.options.icon.options.color;
        }
        this.options.icon.setData(this.nameText, this.value, this.dir,this.code);
    },

    _setData:function (data,dataField) {
        LW.ValueMarker.prototype._setData.call(this,data,dataField);
        this.dir = Sun.Util.Data.getValueByField(data,this.options.dirField,dataField);
    }
});
LW.baseZdzWindMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.BaseZdzWindIcon(options.iconOptions);
    return new LW.BaseZdzWindMarker(latlng, options);
};

LW.SynZdzMarker = LW.BaseZdzWindMarker.extend({
    options: {
        windSpeedField: '',
        valueLeftField: '',
        valueRightField: ''
    },
    setData: function (data) {
        this.options.icon.setData(data[this.options.nameField], data[this.options.valueField],
            data[this.options.valueLeftField], data[this.options.valueRightField],
            data[this.options.windSpeedField], data[this.options.dirField]);
    },

    resetLabelField: function (valueField, valueLeftField, valueRightField, windSpeedField, dirField) {
        this.options.valueField = valueField;
        this.options.valueLeftField = valueLeftField;
        this.options.valueRightField = valueRightField;
        this.options.windSpeedField = windSpeedField;
        this.options.dirField = dirField;
    },

    setValueLabelLeftVisible: function (visible) {
        this.options.icon.setValueLabelLeftVisible(visible);
    },

    setValueLabelRightVisible: function (visible) {
        this.options.icon.setValueLabelRightVisible(visible);
    }
});

LW.synZdzMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.SynZdzIcon(options.iconOptions);
    return new LW.SynZdzMarker(latlng, options);
};

LW.WaterLevelMarker = LW.ValueMarker.extend({
    setData: function (currentData, historyData) {
        this.data = currentData;
        var nameText = currentData[this.options.nameField];
        var value = currentData[this.options.valueField];
        var limitStatus = Sun.Util.Weather.waterLevel_getLimitStatus(currentData);
        var changedStatus = Sun.Util.Weather.waterLevel_getLimitStatus(currentData, historyData);
        this.options.icon.setData(nameText, value, limitStatus, changedStatus);
    }
});

LW.waterLevelMaker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.WaterLevelIcon(options.iconOptions);
    return new LW.WaterLevelMarker(latlng, options);
};


/**
 * 基础图层
 *
 * Features :
 *      1. 含自动站、预警信号、雷达、云图等基础图层
 *
 * @module Layer.Base
 */

/**
 * 基础图层
 * Features :
 *      1. 默认为带名字的marker图层，可通过重设markerInstance改变marker实例
 *      2. 含有边界切割功能，在地图外的marker不显示
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.0.4 ：增加图层未添加在地图上仍可设置数据的功能
 *      + v1.0.4-dev ：移除markerClickMode属性，移除addEventParent方法
 *
 * @class LW.BaseLayer
 * @extends L.FeatureGroup
 *
 * @demo demo/base/base.html  {基于基础图层的地灾图层}
 */
LW.BaseLayer = L.FeatureGroup.extend({
    options: {
        /**
         * 纬度字段名
         * @property latField
         * @type {string}
         * @default 'LAT'
         */
        latField: 'LAT',

        /**
         * 经度字段名
         * @property lonField
         * @type {string}
         * @default 'LON'
         */
        lonField: 'LON',

        /**
         * Marker 实例
         * @property markerInstance
         * @type {function}
         * @default LW.nameMarker
         */
        markerInstance: LW.nameMarker,

        /**
         * Marker's id 字段名
         * @property markerIdField
         * @type {string}
         * @default 'STATIONCODE'
         */
        markerIdField: 'STATIONCODE',

        gradingModel:null,

        /**
         * icon 's options
         * @property iconOptions
         * @type {object}
         */
        iconOptions: {},

        pane: 'markerPane'
    },

    nameLabelVisible: true,

    initialize: function (options, layers) {
        this._layers = {};

        var i, len;

        if (layers) {
            for (i = 0, len = layers.length; i < len; i++) {
                this.addLayer(layers[i]);
            }
        }

        L.setOptions(this, options);
    },

    onAdd: function (map) {
        this._map = map;
        if (this.data)
            this.setData(this.data);
        map.on("zoomend", this._onMapChanged, this);
        map.on("moveend", this._onMapChanged, this);
    },

    onRemove: function (map) {
        map.off("zoomend", this._onMapChanged, this);
        map.off("moveend", this._onMapChanged, this);
        L.LayerGroup.prototype.onRemove.call(this, map);
    },

    _onMapChanged: function () {
        this.eachLayer(this._onMarkerShowHide, this);
    },

    _onMarkerShowHide: function (layer) {
        var map = this._map;
        if (null != map) {
            var zoom = map.getZoom(),
                minzoom = layer.options.minZoom || 0,
                maxzoom = layer.options.maxZoom || 18;
            if (zoom >= minzoom && zoom <= maxzoom && map.getBounds().contains(layer.getLatLng())) {
                if (!map.hasLayer(layer))
                    map.addLayer(layer);
            }
            else {
                map.removeLayer(layer);
            }

        }
    },

    /**
     * 设置图层数据，并创建数据对应的Marker，加到图层上
     * @method setData
     * @param data {Array}
     */
    setData: function (data) {
        this.clearLayers();
        if(this.options.gradingModel && data && data.length>0){
            this.options.gradingModel.setData(data);
            data = this.options.gradingModel.getData(18);
        }
        this.data = data;
        if (this._map) {
            this._setData(data);
            this._onMapChanged();
            this.eachLayer(this._setMarkerLabelStatus, this);
        }
        return this;
    },

    /**
     * 遍历数据，创建Markers
     * @protected
     * @param source {Array}
     */
    _setData: function (source) {
        var data = source.FieldName?source.Rows:source;
        for (var i = 0; i < data.length; i++) {
            var o = data[i];
            var options = Sun.Util.Data.clone(this.options);
            var lat = Sun.Util.Data.getValueByField(o,options.latField,source.FieldName);
            var lng = Sun.Util.Data.getValueByField(o,options.lonField,source.FieldName);
            if (lat != '' && lng != '') {
                if(o.minZoom) options.minZoom = o.minZoom;
                var m = options.markerInstance([lat, lng], options);
                m.id = o[options.markerIdField];
                m.addTo(this).setData(o,source.FieldName);
            }
        }
    },

    /**
     * 通过ID获取Maker
     * @method getMarkerById
     * @param id 注：options.markerIdField设置的字段的对应值为id
     * @returns {*}
     */
    getMarkerById: function (id) {
        for (var i in this._layers) {
            if (this._layers[i].id == id)
                return this._layers[i];
        }
    },

    _setMarkerLabelStatus: function (m) {
        if (!this.nameLabelVisible)
            m.setNameLabelVisible(this.nameLabelVisible);
    },

    /**
     * 设置名称文本(name label)的显隐
     * @method setNameLabelVisible
     * @param visible {boolean}
     */
    setNameLabelVisible: function (visible) {
        this.nameLabelVisible = visible;
        var setMarkerNameVisible = function (marker) {
            if (marker instanceof LW.NameMarker)
                marker.setNameLabelVisible(visible);
        };
        this.eachLayer(setMarkerNameVisible, this);
        return this;
    },

    setStyle:function (style,type) {
        if(typeof style == 'object'){
            for(var key in style){
                this.options.iconOptions[key] = style[key];
            }
        }
        else
            this.options.iconOptions[type] = style;

        this.eachLayer(function (m) {
            m.options.icon.setStyle(style,type);
        },this)
    }
});

/**
 *
 * @class LW.BaseLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @param layers {object} 初始图层，可以不传
 * @returns {LW.BaseLayer}
 */
LW.baseLayer = function (options, layers) {
    return new LW.BaseLayer(options, layers);
};

/**
 * 文本图层--县名、市名等图层
 * @class LW.LabelLayer
 * @extends LW.BaseLayer
 */
LW.LabelLayer = LW.BaseLayer.extend({
    options: {
        /**
         * marker name 字段名
         * @property nameField
         * @default 'NAME'
         */
        nameField: 'NAME',

        /**
         * marker location 字段名
         * @property locationField
         * @default 'LOCATION'
         */
        locationField: 'LOCATION',

        /**
         * Marker 实例
         * @property markerInstance
         * @default LW.labelMarker
         */
        markerInstance: LW.labelMarker,

        minZoom: 0,
        maxZoom: 18
    },


    // onAdd: function (map) {
    //     L.LayerGroup.prototype.onAdd.call(this, map);
    // },
    //
    // onRemove: function (map) {
    //     L.LayerGroup.prototype.onRemove.call(this, map);
    // },

    setData: function (data) {
        this.clearLayers();
        this.data = data;
        this._setData(data);
        return this;
    },

    _setData: function (data) {
        for (var i = 0; i < data.length; i++) {
            var o = data[i];
            var options = Sun.Util.Data.clone(this.options);
            var location = o[options.locationField][0];
            var m = this.options.markerInstance([location[1], location[0]], options);
            var name = o[options.nameField];
            m.addTo(this).setData(name);
            m.data = o;
            m.id = name.slice(0, 2);
        }
    }
});

LW.labelLayer = function (options, layers) {
    return new LW.LabelLayer(options, layers);
};

/**
 * 基础自动站图层
 * @class LW.BaseZdzLayer
 * @extends LW.BaseLayer
 *
 * @demo demo/base/zdzInstances.js {自动站--实例}
 * @demo demo/base/zdzWind.html {自动站--风图层}
 */
LW.BaseZdzLayer = LW.BaseLayer.extend({
    options: {
        /**
         * 设置icon options，将在创建icon时复制传入，可设置icon展示属性
         * @property iconOptions
         * @type {object}
         */

        /**
         * icon中心点的类型，可选类型如下：
         *      1. graph：绘制圆点，默认值
         *      2. image：固定图片
         *      3. dyImage：动态图片
         * @property iconOptions.iconType
         * @type {string}
         */

        /**
         * icon中心点的绘制半径，当iconType为'graph'时才会生效
         * @property iconOptions.radius
         * @type {number}
         */

        /**
         * 动态图片的图片地址设置方法，当iconType为'dyImage'时才会生效
         * @property iconOptions.dyImageUrlFun
         * @type {function}
         */

        //iconOptions:{},


        /**
         * 纬度字段名
         * @property latField
         * @type {string}
         * @default 'STATIONLAT'
         */
        latField: 'STATIONLAT',

        /**
         * 经度字段名
         * @property lonField
         * @type {string}
         * @default 'STATIONLON'
         */
        lonField: 'STATIONLON',

        markerInstance: LW.valueMarker
    },

    valueLabelVisible: true,
    codeLabelVisible: false,

    /**
     * 设置Marker文本的状态
     * @param m {L.ValueMarker}
     * @protected
     */
    _setMarkerLabelStatus: function (m) {
        if (!this.nameLabelVisible)
            m.setNameLabelVisible(this.nameLabelVisible);
        if (!this.valueLabelVisible)
            m.setValueLabelVisible(this.valueLabelVisible);
        if (this.codeLabelVisible)
            m.setCodeLabelVisible(this.codeLabelVisible);
    },

    /**
     * 设置站号文本(code label)的显隐
     * @method setCodeLabelVisible
     * @param visible {boolean}
     */
    setCodeLabelVisible: function (visible) {
        this.codeLabelVisible = visible;
        var setMarkerCodeVisible = function (marker) {
            if (marker instanceof LW.ValueMarker)
                marker.setCodeLabelVisible(visible);
        };
        this.eachLayer(setMarkerCodeVisible, this);
    },

    /**
     * 设置值文本(value label)的显隐
     * @method setValueLabelVisible
     * @param visible {boolean}
     */
    setValueLabelVisible: function (visible) {
        this.valueLabelVisible = visible;
        var setMarkerValueVisible = function (marker) {
            if (marker instanceof LW.ValueMarker)
                marker.setValueLabelVisible(visible);
        };
        this.eachLayer(setMarkerValueVisible, this);
    },

    /**
     * 隐藏无效值的Marker
     * @method setInvalidMarkerHidden
     */
    setInvalidMarkerHidden: function () {
        var _setInvalidMarkerVisible = function (m) {
            if (m instanceof LW.ValueMarker) {
                if (m.getValueInvalidity())
                    m.options.icon.getIcon().style.visibility = 'hidden';
            }
        };
        this.eachLayer(_setInvalidMarkerVisible, this);
    },

    /**
     * 显示所有Marker 用于过滤后的恢复
     * @method showAllMarker
     */
    showAllMarker: function () {
        var _showAllMarker = function (m) {
            if (m instanceof LW.NameMarker)
                m._icon.style.visibility = 'visible';
        };
        this.eachLayer(_showAllMarker, this);
    },

    /**
     * 过滤Marker 注：若Marker的value为无有效值则直接过滤
     * @method filterMarker
     * @param minValue {number} 不填或NaN时仅过滤出比maxValue小的值
     * @param isEqualMin {boolean} 是否将等于minValue的值过滤
     * @param maxValue {number} 不填或NaN时仅过滤出比minValue大的值
     * @param isEqualMax {boolean} 是否将等于maxValue的值过滤
     */
    filterMarker: function (minValue, isEqualMin, maxValue, isEqualMax) {
        var setMarkerVisible = function (m) {
            var value = m.value;
            if (Sun.Util.Common.isValid(value)) {
                var icon = m.options.icon.getIcon();
                if (m.getValueInvalidity())
                    return icon.style.visibility = 'hidden';
                if (isNaN(minValue) && isNaN(maxValue))
                    icon.style.visibility = 'visible';
                else if (isNaN(minValue)) {
                    icon.style.visibility = value <= maxValue ? 'visible' : 'hidden';
                    if (isEqualMax && value == maxValue)
                        icon.style.visibility = 'hidden';
                }
                else if (isNaN(maxValue)) {
                    icon.style.visibility = value >= minValue ? 'visible' : 'hidden';
                    if (isEqualMin && value == minValue)
                        icon.style.visibility = 'hidden';
                }
                else {
                    icon.style.visibility = value <= maxValue && value >= minValue ? 'visible' : 'hidden';
                    if (isEqualMin && value == minValue)
                        icon.style.visibility = 'hidden';
                    if (isEqualMax && value == maxValue)
                        icon.style.visibility = 'hidden';
                }
            }
        };
        this.eachLayer(setMarkerVisible, this);
    }

});

/**
 * @class LW.BaseZdzLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @param layers {object} 初始图层，可以不传
 * @returns {LW.BaseZdzLayer}
 */
LW.baseZdzLayer = function (options, layers) {
    return new LW.BaseZdzLayer(options, layers);
};


/**
 * 基础自动站--降水图层实例
 * @param options
 * @param layers
 * @returns {*}
 */
LW.baseZdzRainLayer = function (options, layers) {
    if (!options) options = {};
    options.valueField = options.valueField || 'RAIN_SUM_VALUE';
    options.legendData = options.legendData || Sun.LegendData.rain;
    return LW.baseZdzLayer(options, layers);
};

/**
 * 基础自动站--风图层实例
 * @param options
 * @param layers
 * @returns {*}
 */
LW.baseZdzWindLayer = function (options, layers) {
    if (!options) options = {};
    options.markerInstance = LW.baseZdzWindMarker;
    options.valueField = options.valueField || 'WIND_CURRENT_SPEEDVALUE';
    options.dirField = options.dirField || 'WIND_CURRENT_DIRVALUE';
    options.legendData = options.legendData || Sun.LegendData.wind;
    return LW.baseZdzLayer(options, layers);
};

/**
 * 基础自动站--气温图层实例
 * @param options
 * @param layers
 * @returns {*}
 */
LW.baseZdzAirtempLayer = function (options, layers) {
    if (!options) options = {};
    options.valueField = options.valueField || 'AIRTEMP_CURRENT_VALUE';
    options.legendData = options.legendData || Sun.LegendData.airtemp;
    return LW.baseZdzLayer(options, layers);
};

/**
 * 基础自动站--气压图层实例
 * @param options
 * @param layers
 * @returns {*}
 */
LW.baseZdzPressureLayer = function (options, layers) {
    if (!options) options = {};
    options.valueField = options.valueField || 'STAPRESSURE_CURRENT_VALUE';
    options.legendData = options.legendData || Sun.LegendData.pressure;
    return LW.baseZdzLayer(options, layers);
};

/**
 * 基础自动站--湿度图层实例
 * @param options
 * @param layers
 */
LW.baseZdzRhLayer = function (options, layers) {
    if (!options) options = {};
    options.valueField = options.valueField || 'RH_CURRENT_VALUE';
    options.legendData = options.legendData || Sun.LegendData.rh;
    return LW.baseZdzLayer(options, layers);
};


/**
 * 基础自动站--能见度图层
 * @class LW.BaseZdzVisibLayer
 * @extends L.BaseZdzLayer
 */

LW.BaseZdzVisibLayer = LW.BaseZdzLayer.extend({
    options: {
        //initShowCode:'58847',

        markerInstance: LW.valueMarker
    },

    // 能见度范围圈
    visibleRangeCircle: null,

    initialize: function (options, layers) {
        LW.BaseZdzLayer.prototype.initialize.call(this, options, layers);
        if (!this.visibleRangeCircle)
            this.visibleRangeCircle = L.circle([0, 0], 0, {
                color: '#fe7a04',
                fillColor: '#fee904',
                fillOpacity: 0.2,
                weight: 1
            });
    },

    onAdd: function (map) {
        LW.BaseLayer.prototype.onAdd.call(this, map);
        if (this.visibleRangeCircle)
            map.addLayer(this.visibleRangeCircle);
    },

    onRemove: function (map) {
        LW.BaseLayer.prototype.onRemove.call(this, map);
        if (this.visibleRangeCircle)
            map.removeLayer(this.visibleRangeCircle);
    },

    setData: function (data) {
        LW.BaseZdzLayer.prototype.setData.call(this,data);
        this.on('click', this._showRange);
    },

    // _setData: function (source) {
    //     var data = source.FieldName?source.Rows:source;
    //     for (var i = 0; i < data.length; i++) {
    //         var o = data[i];
    //         var options = Sun.Util.Data.clone(this.options);
    //         var lat = Sun.Util.Data.getValueByField(o,options.latField,source.FieldName);
    //         var lng = Sun.Util.Data.getValueByField(o,options.lonField,source.FieldName);
    //         if (lat != '' && lng != '') {
    //             if (o.minZoom) options.minZoom = o.minZoom;
    //             var m = options.markerInstance([lat, lng], options);
    //             m.id = o[options.markerIdField];
    //             m.addTo(this).setData(o,source.FieldName);
    //         }
    //     }
    //     this.on('click', this._showRange);
    // },

    /**
     * 设置能见度范围圈的大小及位置
     * @param e
     * @private
     */
    _showRange: function (e) {
        var m = e.layer;
        var value = Sun.Util.Data.getValueByField(m.data,m.options.valueField,this.data.FieldName);
        this.visibleRangeCircle.setLatLng(m.getLatLng());
        this.visibleRangeCircle.setRadius(value);
    }
});


LW.baseZdzVisibLayer = function (options, layers) {
    if (!options) options = {};
    options.valueField = options.valueField || 'VISIBILITY_CURRENT_VALUE';
    options.legendData = options.legendData || Sun.LegendData.visible;
    options.scale = options.scale || 0.001;
    return new LW.BaseZdzVisibLayer(options, layers);
};

/**
 * 综合填图图层
 * @class LW.SynZdzLayer
 * @extends LW.BaseZdzLayer
 */
LW.SynZdzLayer = LW.BaseZdzLayer.extend({
    options: {

        /**
         * 左侧值字段名
         * @property valueLeftField
         * @default ''
         */
        valueLeftField: '',

        /**
         * 右侧值字段名
         * @property valueRightField
         * @default ''
         */
        valueRightField: '',

        /**
         * 风速值字段名
         * @property windSpeedField
         * @default ''
         */
        windSpeedField: '',

        markerInstance: LW.synZdzMarker
    },

    resetLabelField: function (valueField, valueLeftField, valueRightField, windSpeedField, dirField) {
        this.options.valueField = valueField;
        this.options.valueLeftField = valueLeftField;
        this.options.valueRightField = valueRightField;
        this.options.windSpeedField = windSpeedField;
        this.options.dirField = dirField;
    },

    setValueLabelLeftVisible: function (visible) {
        var setMarkerValueVisible = function (marker) {
            if (marker instanceof L.SynZdzMarker)
                marker.setValueLabelLeftVisible(visible);
        };
        this.everyMarker(setMarkerValueVisible);
    },
    setValueLabelRightVisible: function (visible) {
        var setMarkerValueVisible = function (marker) {
            if (marker instanceof L.SynZdzMarker)
                marker.setValueLabelRightVisible(visible);
        };
        this.everyMarker(setMarkerValueVisible);
    }
});

LW.synZdzLayer = function (options, layers) {
    return new LW.SynZdzLayer(options, layers);
};

/**
 * 水位图层
 * @class LW.WaterLevelLayer
 * @extends LW.BaseZdzLayer
 */
LW.WaterLevelLayer = LW.BaseZdzLayer.extend({
    options: {
        iconSize: new L.Point(80, 60),
        iconType: 'image'
    },

    setData: function (currentData, historyData) {
        this.clearLayers();
        for (var i = 0; i < currentData.length; i++) {
            var currentItem = currentData[i];
            var historyItem = Sun.Util.Array.getItemByField(historyData, "STATIONCODE", currentItem.STATIONCODE);
            var options = Sun.Util.Data.clone(this.options);
            var m = LW.waterLevelMaker([currentItem.STATIONLAT, currentItem.STATIONLON], options);
            m.addTo(this).setData(currentItem, historyItem);
        }
    }
});

LW.waterLevelLayer = function (options, layers) {
    options.valueField = options.valueField || 'WATERLEVEL_CURRENT_VALUE';
    return new LW.WaterLevelLayer(options, layers);
};

/**
 * 预警信号icon
 */
LW.AlmtIcon = L.Icon.extend({
    options: {
        color: '#000',
        iconSize: new L.Point(310, 85), //宽高(可调节间隔)
        timeFormat: 'MM-dd hh:mm',
        timeVisible: true,//是否显示时间
        stationVisible: true,//是否显示站点名
        imgWidth:70
    },

    getIcon: function () {
        return this.container;
    },

    createIcon: function () {
        this.container = document.createElement('div');
        this.shell = L.DomUtil.create('div', 'lw-almt-shell', this.container);
        this.almtContainer = L.DomUtil.create('div', 'lw-almt', this.shell);
        this._setIconStyles(this.container, "icon");
    },

    setData: function (data) {
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            var almt = L.DomUtil.create('div', '', this.almtContainer);
            // img
            var img = L.DomUtil.create('img', '', almt);
            img.src = this.options.iconBaseUrl + data[i]['SIGNAL'] + '.png';
            img.data = item;
            img.offsetX = this._getOffsetX(i,data.length);
            img.id = item['ID'];
            img.onclick = this.options.markerClick;

            // label
            if (this.options.timeVisible) {
                var timeText = new Date(item['ISSUETIME2'].replace(/-/g, '/')).format(this.options.timeFormat);
                var timeLabel = L.DomUtil.create('span', '', almt);
                timeLabel.innerText = timeText || '';
            }
        }
        // 站名
        if (this.options.stationVisible) {
            var station = data[0]['STATIONNAME'];
            var stationLabel = L.DomUtil.create('span', '', this.shell);
            stationLabel.innerText = station || '';
            this.shell.appendChild(stationLabel);
        }
    },
    
    _getOffsetX:function (index,length) {
        var imgWidth = this.options.imgWidth;
        index = index+1;
        var c = length/2+0.5;
        return (index-c)*imgWidth;
    }
});

LW.AlmtMarker = LW.NameMarker.extend({
    setData: function (data) {
        this.data = data;
        this.options.icon.setData(data);
    },



    _initInteraction: function () {

        if (!this.options.interactive) { return; }

        L.DomUtil.addClass(this._icon, 'leaflet-interactive');

        // this.addInteractiveTarget(this._icon);

        if (L.Handler.MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
                draggable = this.dragging.enabled();
                this.dragging.disable();
            }

            this.dragging = new L.Handler.MarkerDrag(this);

            if (draggable) {
                this.dragging.enable();
            }
        }
    }
});

LW.almtMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.AlmtIcon(options.iconOptions);
    return new LW.AlmtMarker(latlng, options);
};

/**
 * @module Layer.Base
 */

/**
 * 预警信号图层
 *
 * Features :
 *      1. 支持多预警信号，及每个预警信号发出点击事件
 *      2. 通过配置iconOptions中的iconBaseUrl来设置预警信号的图片跟地址
 *      3. 可以为指定的站点图标设置描边
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.0.4-dev ：修改布局方式，采用css文件布局，需引用lealet.weather.css
 *      + v1.1.0-dev ：点击可以传出offsetX，用于显示弹框的偏移量
 *
 * @class LW.AlmtLayer
 * @extends L.BaseLayer
 * @demo demo/base/almt.html {}
 */

LW.AlmtLayer = LW.BaseLayer.extend({
    options: {
        latField: 'STATIONLAT',
        lonField: 'STATIONLON',
        markerInstance: LW.almtMarker,
        iconBaseUrl: '',
        iconOptions: {
            iconBaseUrl: "images/almt/"  //图片路径 建议使用100x85的预警信号图
        }
    },

    _hasWarning: false,

    _setData: function (data) {
        var almtList = this._getAlmtList(data);
        var proto = this;
        for (var key in almtList) {
            var item = almtList[key];
            var item0 = item[0];
            if (item0['SIGNAL'] != '无预警信号') {
                this._hasWarning = true;
                var options = Sun.Util.Data.clone(this.options);
                options.iconOptions.markerClick = function (e) {
                    e.stopPropagation();
                    proto.fire("AlmtMarkerClick", {data: e.currentTarget.data,offsetX: e.currentTarget.offsetX});
                };
                var m = options.markerInstance([item0[options.latField], item0[options.lonField]], options);
                m.id = item0.STATIONID;
                m.addTo(this).setData(item);
                this._setMarkerLabelStatus(m);
            }
        }
    },

    _getAlmtList: function (data) {
        var list = {};
        for (var i = 0; i < data.length; i++) {
            var stationId = data[i]["STATIONID"];
            list[stationId] = list[stationId] || [];
            list[stationId].push(data[i]);
        }
        return list;
    },

    /**
     * 为图标设置描边
     * @param stationId {string} data.STATIONID
     * @param id {string} data.ID 不传时可将stationId相等的所有icon描边
     */
    setIconStrokeByID: function (stationId, id) {
        this.eachLayer(function (m) {
            var imgs = m.options.icon.getIcon().getElementsByTagName('img');
            for (var i = 0; i < imgs.length; i++) {
                var dot = imgs[i];
                var idFlag = (typeof (id) != "undefined" && dot.id == id) || (typeof id == "undefined");
                if (idFlag && m.id == stationId) {
                    dot.style.border = '3px red solid';
                    dot.style.borderRadius = '5px';
                }
                else
                    dot.style.border = 'none';
            }
        }, this);
    },


    hasWarning: function () {
        return this._hasWarning;
    }
});

/**
 * @class LW.AlmtLayer
 * @constructor
 * @param [options] [object] 外部属性，可重设Properties
 * @param [layers] [object] 初始图层，可以不传
 * @returns {LW.AlmtLayer}
 */
LW.almtLayer = function (options, layers) {
    return new LW.AlmtLayer(options, layers);
};
/**
 * 预警信号icon
 */
LW.SuperAlmtIcon = LW.AlmtIcon.extend({
    options: {
        provStationId: 'none'
    },

    setData: function (data) {
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            var almt = L.DomUtil.create('div', '', this.almtContainer);
            // img
            var img = L.DomUtil.create('img', '');
            img.src = this.options.iconBaseUrl + data[i]['SIGNAL'] + '.png';
            img.data = item;
            this._whenImgLoaded(img, almt);
        }
        // 站名
        if (this.options.stationVisible) {
            var station = data[0]['STATIONNAME'];
            var stationLabel = L.DomUtil.create('span', '', this.shell);
            stationLabel.innerText = station || '';
            this.shell.appendChild(stationLabel);
        }
    },

    _whenImgLoaded: function (img, almt) {
        var me = this;
        if (img.complete)
            this._setIcon(img, almt);
        else {
            img.onload = function (e) {
                me._setIcon(img, almt);
            };
        }
    },
    _setIcon: function (img, almt) {
        var item = img.data;
        if (img.data['CHANGE'] == 3) {
            // 解除发布的站点变成灰色
            var grayDot = L.DomUtil.create('img');
            grayDot.src = this.gray(img);
            grayDot.data = img.data;
            img = grayDot;
        }
        almt.appendChild(img);
        img.id = item['ID'];
        img.onclick = this.options.markerClick;

        var cityLevel = this._getCityLevel(item);
        if (cityLevel == 0)// 县级站点
            img.className = 'smaller';

        // label
        if (this.options.timeVisible) {
            var timeText = new Date(item['ISSUETIME2'].replace(/-/g, '/')).format(this.options.timeFormat);
            var timeLabel = L.DomUtil.create('span', '', almt);
            timeLabel.innerText = timeText || '';
        }

        // 保存dot用于过滤
        this.levelDots = this.levelDots || [];
        var levelDot = Sun.Util.Array.getItemByField(this.levelDots, 'cityLevel', cityLevel);
        if (!levelDot) {
            levelDot = {cityLevel: cityLevel, dots: [almt]};
            this.levelDots.push(levelDot);
        }
        else
            levelDot.dots.push(almt);
    },

    // 0--县 1--市 2--省 3--全部
    _getCityLevel: function (item) {
        var stationType = item.STATIONTYPE;
        if (Sun.Util.Common.isValid(stationType)) {
            if (stationType == 1) //省
                return 2;
            else if (stationType == 0) //市
                return 1;
            else if (stationType == 3) //县
                return 0;
        }
        else {
            var stationName = item.STATIONNAME.slice(0, 2);
            var city = item.CITY.slice(0, 2);
            if (item.STATIONID == this.options.provStationId)
                return 2;
            if (stationName == city)
                return 1;
            else
                return 0;
        }
    },


    // 因为css设置灰度不能支持ie10和ie11，所以得用画布来转
    gray: function (imgObj) {
        // 最后要放到工具类中，实例不需拿出来
        var canvas = document.createElement('canvas');
        var canvasContext = canvas.getContext('2d');

        var imgW = imgObj.width;
        var imgH = imgObj.height;
        canvas.width = imgW;
        canvas.height = imgH;

        canvasContext.drawImage(imgObj, 0, 0);
        var imgPixels = canvasContext.getImageData(0, 0, imgW, imgH);

        for (var y = 0; y < imgPixels.height; y++) {
            for (var x = 0; x < imgPixels.width; x++) {
                var i = (y * 4) * imgPixels.width + x * 4;
                var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
                imgPixels.data[i] = avg;
                imgPixels.data[i + 1] = avg;
                imgPixels.data[i + 2] = avg;
            }
        }
        canvasContext.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);
        return canvas.toDataURL();
    }
});


LW.superAlmtMarker = function (latlng, options) {
    if (!options) options = {};
    options.icon = options.icon || new LW.SuperAlmtIcon(options.iconOptions);
    return new LW.AlmtMarker(latlng, options);
};

/**
 * @module Layer.Base
 */

/**
 * Super预警信号图层
 *
 * Features :
 *      1. 支持多预警信号，及每个预警信号发出点击事件
 *      2. 通过配置iconOptions中的iconBaseUrl来设置预警信号的图片跟地址
 *      3. 支持解除发布预警信号变灰
 *      4. 支持市一级预警信号比县一级大，在leaflet.weather.css可重置大小
 *      5. 支持同一个站点有两种不同等级的预警信号
 *
 * Update Note：
 *      + v1.0.4-dev ：Created
 *
 * @class LW.SuperAlmtLayer
 * @extends L.AlmtLayer
 * @demo demo/base/superAlmt.html {}
 */

LW.SuperAlmtLayer = LW.AlmtLayer.extend({
    options: {
        markerInstance: LW.superAlmtMarker
    },

    /**
     * 通过城市等级显示预警信号
     * @param level {number} 等级：0--县 1--市 2--省 3--全部
     */
    showAlmtByCityLevel: function (level) {
        this.eachLayer(function (m) {
            var icon = m.options.icon;
            if (icon.levelDots.length == 1) {
                if (icon.levelDots[0].cityLevel == level || level == 3)
                    icon.getIcon().style.display = 'inline-block';
                else
                    icon.getIcon().style.display = 'none';
            }
            else {
                for (var i = 0; i < icon.levelDots.length; i++) {
                    var levelDot = icon.levelDots[i];
                    if (levelDot.cityLevel == level || level == 3) {
                        levelDot.dots.forEach(function (dot) {
                            dot.style.display = 'inline-block';
                        })
                    }
                    else {
                        levelDot.dots.forEach(function (dot) {
                            dot.style.display = 'none';
                        })
                    }
                }
            }

        }, this);
    }
});

/**
 * @class LW.SuperAlmtLayer
 * @constructor
 * @param [options] [object] 外部属性，可重设Properties
 * @param [layers] [object] 初始图层，可以不传
 * @returns {LW.SuperAlmtLayer}
 */
LW.superAlmtLayer = function (options, layers) {
    return new LW.SuperAlmtLayer(options, layers);
};
/**
 * 交通路况瓦片图层
 *
 * Update Note：
 *      + v1.4.3 ：Created
 *      + v1.5.6 ：增加原图坐标系类型的配置，以叠加再非高德地图中自动位置纠偏
 *
 * @class LW.TrafficTileLayer
 * @extends L.TileLayer
 * @demo demo/base/trafficTileLayer.html  {路况}
 */
LW.TrafficTileLayer = L.TileLayer.extend({
    options:{
        /**
         * 原图坐标系类型，将会由该类型转为wgs84
         * @property coordType
         * @type {string}
         * @default 'gcj02'
         */
        coordType:'gcj02',
        /**
         * 是否自动刷新
         * @property autoRefresh
         * @type {boolean}
         * @default true
         */
        autoRefresh: true,     //是否自动刷新，默认为true
        /**
         * 自动刷新间隔,单位s
         * @property interval
         * @type {int}
         * @default 60
         */
        interval: 60
    },
    initialize: function (url, options) {
        var t = new Date().getTime();
        url = this.baseUrl = url || 'http://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&;t=1&x={x}&y={y}&z={z}&&t=';
        L.TileLayer.prototype.initialize.call(this,url+t,options);
        this.autoRefresh();
    },

    autoRefresh:function(){
        var  self = this;
        if(this.options.autoRefresh){
            setInterval(function () {
                self.refresh();
            },this.options.interval*1000);
        }
    },

    refresh:function () {
        var t = new Date().getTime();
        this.setUrl(this.baseUrl+t);
    }
});

/**
 * @class LW.TrafficTileLayer
 * @constructor
 * @param url {string} 瓦片地址
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.TrafficTileLayer}
 */
LW.trafficTileLayer = function (url, options) {
    return new LW.TrafficTileLayer(url, options);
};

/**
 * 图片播放代理
 * options-showFun--图片展示方法，必填属性，
 */
LW.ImagePlayerAgent = L.Class.extend({
    options: {
        //showFun:null,
        playInterval: 1000
    },

    initialize: function (options) {
        L.setOptions(this, options);
    },

    sourceData: null,
    cursor: -1,
    timer: null,

    setData: function (data) {
        if (this.timer) this.stop();
        this.sourceData = data;
        this.cursor = 0;
    },

    getCurItem: function () {
        return this.sourceData[this.cursor];
    },

    _setCursor: function (c) {
        this.cursor = c;
        this.options.showFun(this.getCurItem(), c, this);
    },

    setItem: function (index) {
        this._setCursor(index);
    },

    showFirst: function () {
        if (this.timer) this.stop();
        this._setCursor(this.sourceData.length - 1);
    },

    showLast: function () {
        if (this.timer) this.stop();
        this._setCursor(0);
    },

    showPrev: function () {
        if (this.timer) this.stop();
        this._setCursor((this.cursor + 1) % this.sourceData.length);
    },

    showNext: function () {
        if (this.timer) this.stop();
        this._showNext();
    },

    _showNext: function () {
        this.cursor--;
        this._setCursor(this.cursor < 0 ? this.sourceData.length - 1 : this.cursor);
    },

    play: function () {
        if (this.timer) this.stop();
        var self = this;
        self._showNext();
        this.timer = setInterval(function () {
            self._showNext()
        }, this.options.playInterval);
    },

    stop: function () {
        window.clearInterval(this.timer);
        this.timer = null;
    }
});



/**
 * Created by whl on 2015/9/7.
 */
LW.PixelFilter = L.Class.extend({
    options: {
        //colorSpectrum:<Array>
    },

    filterColor: null,
    filterIndex: -1,

    initialize: function (options) {
        L.setOptions(this, options);
    },

    setFilterColor: function (value) {
        this.filterColor = value;
        this.filterIndex = this.options.colorSpectrum.indexOf(value);
    },

    setFilterParam: function(value){
        typeof value == "object" ? this.filterRange = value : this.filterIndex = value;
    },

    filter: function (imageData) {
        var self = this;
        for (var i = 0; i < imageData.data.length; i += 4) {
            var color = Sun.Util.Color.rgbToHex(imageData.data[i], imageData.data[i + 1], imageData.data[i + 2]);
            var colorIndex = this.options.colorSpectrum.indexOf(color);
            if (color != '#000000') {
                if (isFilter(colorIndex))
                    imageData.data[i + 3] = 0;
                else
                    imageData.data[i + 3] = 255;
            }

        }
        return imageData;

        function isFilter(cIdx) {
            if(cIdx != -1){
                if(self.filterRange)
                    return cIdx < self.filterRange.min || cIdx > self.filterRange.max;
                else
                    return cIdx < self.filterIndex;
            }
        }
    }
});

/**
 * @module Layer.Base
 */

/**
 * 图片图层，基于L.ImageOverlay。增加初始化url和bounds可为空，后面再设置的空难
 * Image Layer primary for sat.
 * @class LW.ImageLayer
 * @extends L.ImageOverlay
 */
LW.ImageLayer = L.ImageOverlay.extend({
    initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
        this._url = url;
        if (bounds)
            this._bounds = L.latLngBounds(bounds);

        L.setOptions(this, options);
        this._zoomAnimated = true;
        if (!this._image){
            this._initImage();
            if (this.options.opacity < 1) {
                this._updateOpacity();
            }
        }
    },

    /**
     * 设置图片地址
     * @method setUrl
     * @param url {string} 图片地址
     * @returns {LW.ImageLayer}
     */
    setUrl: function (url) {
        if (this.options.opacity < 1) {
            this._updateOpacity();
        }

        this._url = url;

        if (this._image) {
            this._image.src = url;
        }
        return this;
    },

    /**
     * 设置图片边界
     * @method setBounds
     * @param bounds {L.LatLngBounds|Array}
     * @returns {LW.ImageLayer}
     */
    setBounds: function (bounds) {
        this._bounds = (bounds instanceof L.LatLngBounds) ? bounds : L.latLngBounds(bounds);

        if (this._map) {
            this._reset();
        }
        return this;
    },

    _reset: function () {
        if (this._bounds) {
            var bounds = new L.Bounds(
                this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                size = bounds.getSize();

            L.DomUtil.setPosition(this.getElement(), bounds.min);

            this.getElement().style.width = size.x + 'px';
            this.getElement().style.height = size.y + 'px';
        }
    },

    onAdd: function () {
        this.getPane().appendChild(this.getElement());
        this._reset();
    }
});

/**
 * @class LW.ImageLayer
 * @constructor
 * @param url 图片地址
 * @param bounds 图片边界
 * @param options 外部属性，可重设Properties
 * @returns {LW.ImageLayer}
 */
LW.imageLayer = function (url, bounds, options) {
    return new LW.ImageLayer(url, bounds, options);
};


/**
 * 图片遮罩图层
 * Features :
 *      1. 基于svg渲染
 *
 * Update Note：
 *      + v1.5.3 : Created
 *
 * @class LW.ImageLayer.Mask
 * @extends LW.ImageLayer
 */
LW.ImageLayer.Mask = LW.ImageLayer.extend({
    options:{
        maskGeoJson:null
    },

    _initContainer: function() {
        if(this.options.maskGeoJson){
            var rootGroup = this._map.getRenderer(this)._rootGroup;
            var defs = rootGroup.appendChild(L.SVG.create("defs"));
            var container = this._container = rootGroup.appendChild(L.SVG.create("g"));
            var clipPath  = this._clipPath = defs.appendChild(L.SVG.create("clipPath"));
            defs.appendChild(clipPath);
            this.id = 'leaflet-imgOverlay-mask-' + L.stamp(this);
            this._clipPath.setAttribute('id', this.id);
            this._updateClipPath();

            container.setAttribute('clip-path', 'url(#' + this.id + ')');
        }
    },
    _updateClipPath: function (clipPath,maskGeoJson) {
        clipPath = clipPath || this._clipPath;
        maskGeoJson = maskGeoJson || this.options.maskGeoJson;
        if (maskGeoJson && maskGeoJson instanceof L.GeoJSON) {
            var _layers = maskGeoJson._layers;
            for (i in _layers) {
                var path = _layers[i]._path;
                path.setAttribute('clip-rule','evenodd');
                clipPath.appendChild(path);
            }
        }
    },

    resetMask:function(maskGeoJson){
        var enabled = !!maskGeoJson;
        this._container.setAttribute('clip-path', enabled?'url(#' + this.id + ')':'none');
        if (maskGeoJson && maskGeoJson instanceof  L.GeoJSON) {
            this.options.maskGeoJson = maskGeoJson;
            Sun.Util.Common.removeAllChildren(this._clipPath);
            this._updateClipPath();
        }
    },

    _initImage:function(){
        var img = this._image = L.SVG.create("image");
        img.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this._url);
    },


    /**
     * 设置图片地址
     * @method setUrl
     * @param url {string} 图片地址
     * @returns {LW.ImageLayer}
     */
    setUrl: function (url) {
        if (this.options.opacity < 1) {
            this._updateOpacity();
        }

        this._url = url;

        if (this._image)
            this._image.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
        return this;
    },

    /**
     * 设置图片边界
     * @method setBounds
     * @param bounds {L.LatLngBounds|Array}
     * @returns {LW.ImageLayer}
     */
    setBounds: function (bounds) {
        this._bounds = (bounds instanceof L.LatLngBounds) ? bounds : L.latLngBounds(bounds);

        if (this._map) {
            this._reset();
        }
        return this;
    },

    _reset: function () {
        if (this._bounds) {
            var bounds = new L.Bounds(
                this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                size = bounds.getSize();

            var img = this._image;
            img.setAttribute("width", size.x);
            img.setAttribute("height", size.y);
            img.setAttribute("x", bounds.min.x);
            img.setAttribute("y", bounds.min.y);
            // L.DomUtil.setPosition(this.getElement(), bounds.min);
            // this.getElement().style.width = size.x + 'px';
            // this.getElement().style.height = size.y + 'px';
        }
    },

    _animateZoom: function (e) {
        return false;
    },

    onAdd: function () {
        if(!this._container)
            this._initContainer();
        this._container.appendChild(this.getElement());
        this._reset();
    }
});

/**
 * @class LW.ImageLayer
 * @constructor
 * @param url 图片地址
 * @param bounds 图片边界
 * @param options 外部属性，可重设Properties
 * @returns {LW.ImageLayer}
 */
LW.imageLayer.mask = function (url, bounds, options) {
    return new LW.ImageLayer.Mask(url, bounds, options);
};





/**
 * 雷达图层
 *
 * Features :
 *      1. 支持过滤，但需雷达图的色谱与设置的色谱一致
 *      2. 可像素化雷达图或者模化显示
 *      3. 因有对图片的像素化操作，所以服务端需配置允许跨域
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.0.3 ：色谱设置改为直接设置LegendData
 *      + v1.5.0 ：过滤方法支持双向过滤，索引过滤
 *
 * @class LW.RadarLayer
 * @extends LW.ImageLayer
 * @demo demo/base/radar.html  {雷达图层}
 */

LW.RadarLayer = LW.ImageLayer.extend({
    options: {
        /**
         * 透明度
         * @property opacity
         * @type {number}
         * @default 0.7
         */
        opacity: 0.7,

        crossOrigin: true,

        /**
         * 是否像素化展示
         * @property pixelate
         * @type {boolean}
         * @default false
         */
        pixelate: false,

        zIndex: null

        /**
         * 雷达图色谱(图例)
         * @property legendData
         * @type {Array}
         */
        //legendData:<Array>
    },

    canvas: null,
    ctx: null,
    imageData: null,
    filterParam: null,
    imageFilter: null,

    getElement: function () {
        return this.canvas;
    },

    initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
        this._url = url;
        if (bounds)
            this._bounds = L.latLngBounds(bounds);

        L.setOptions(this, options);
        if (!this.canvas)
            this._initCanvas();
    },

    setUrl: function (url) {
        this.imageData=null;
        if (!this._image) {
            this.on('load', this._imageLoaded);
            this._initImage();
            var self = this;
            this._image.onerror= function () {
                self.clear();
            };

            if (this.options.opacity < 1) {
                this.canvas.style.opacity = this.options.opacity;
            }
        }

        this._url = url;

        if (this._image) {
            this._image.src = url;
        }
        return this;
    },

    _initCanvas: function () {
        this.canvas = L.DomUtil.create('canvas', 'leaflet-radar-layer leaflet-zoom-animated');
        if(this.options.zIndex)
            this.canvas.style.zIndex = this.options.zIndex;
        if (this.options.pixelate)
            this.canvas.style.imageRendering = 'pixelated';
        this.ctx = this.canvas.getContext("2d");
        var imgOptions = this.options.legendData ? {colorSpectrum: Sun.Util.LegendData.getColors(this.options.legendData)} : {};
        this.imageFilter = new LW.PixelFilter(imgOptions);
    },

    clear: function(){
        var ctx = this.ctx,canvas = this.canvas;
        ctx.clearRect(0, 0,canvas.width,canvas.height);
    },

    /**
     * 设置雷达色谱
     * @method setLegendData
     * @param legendData {Array} 色谱数据
     */
    setLegendData: function (legendData) {
        if(this.legendData == legendData) return;
        this.legendData = legendData;
        this.filterParam = null;
        this.imageFilter.options.colorSpectrum = legendData? Sun.Util.LegendData.getColors(legendData):null;
    },

    onRemove: function () {
        L.DomUtil.remove(this.canvas);
        if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
        }
    },

    _imageLoaded: function () {
        if (this.canvas) {
            this.canvas.width = this._image.width;
            this.canvas.height = this._image.height;
            this.ctx.drawImage(this._image, 0, 0);
            try {
                this.imageData = this.ctx.getImageData(0, 0, this._image.width, this._image.height);
            }
            catch (e) {
                console.log('getImageData error!');
            }
            if (this.filterParam)
                this.filter(this.filterParam);
        }
    },

    _animateZoom: function (e) {
        if (!this._bounds)
            return;

        var scale = this._map.getZoomScale(e.zoom),
            offset = this._map._latLngToNewLayerPoint(this._bounds.getNorthWest(), e.zoom, e.center);

        L.DomUtil.setTransform(this.canvas, offset, scale);
    },

    /**
     * 雷达过滤
     * @method filter
     * @param param 1. 过滤的颜色值 eg:'#02c200'
     *              2. 过滤的索引范围; if:<min || >max被过滤 eg:{min:3,max:8}
     *              3. 过滤的最小索引(数值); if:<index被过滤 eg:3
     */
    filter: function (param) {
        this.filterParam = param;
        this.imageFilter[typeof param == 'string' ? 'setFilterColor' : 'setFilterParam'](param);
        if (this.imageData) {
            //Tip:ImageData的构造方法在某些浏览器及手机中没有兼容
            var imgData = this.imageFilter.filter(this.imageData);
            this.ctx.putImageData(imgData, 0, 0);
        }
    }
});

/**
 * @class LW.RadarLayer
 * @constructor
 * @param url 图片地址
 * @param bounds 图片边界
 * @param options 外部属性，可重设Properties
 * @returns {LW.RadarLayer}
 */
LW.radarLayer = function (url, bounds, options) {
    return new LW.RadarLayer(url, bounds, options);
};

/*	Curve extension for canvas 2.3.1
 *	Epistemex (c) 2013-2014
 *	www.epistemex.com
 *	License: MIT
 */

/*---------- B-SPLINE CALCULATION ----------*/
(function (window) {
    var Bspline = [ -1/6,  3/6, -3/6,  1/6,  // a,b,c,d cubic coefficients from P0
        3/6, -6/6,    0,  4/6,  // a,b,c,d cubic coefficients from P1
        -3/6,  3/6,  3/6,  1/6,  // a,b,c,d cubic coefficients from P2
        1/6,    0,    0,    0   // a,b,c,d cubic coefficients from P3
    ];
    function cubic(A, t) {
        var value = A[0] * t*t*t + A[1] * t*t + A[2] * t + A[3];
        return Sun.Util.Math.toRoundFixed(value,2);
    }
    function transform(m, v) {
        // IF v[3] IS UNDEFINED, SET IT TO 1 (THAT IS, ASSUME v IS A POINT).
        var x = v[0], y = v[1], z = v[2], w = v[3] === undefined ? 1 : v[3];

        // RETURN RESULT OF TRANSFORMING v BY MATRIX m.
        return [ x * m[0] + y * m[4] + z * m[ 8] + w * m[12],
            x * m[1] + y * m[5] + z * m[ 9] + w * m[13],
            x * m[2] + y * m[6] + z * m[10] + w * m[14],
            x * m[3] + y * m[7] + z * m[11] + w * m[15] ];
    }

    window.getBspline = function (pts) {
        var curve = [];
        var len = pts.length,
            tension = len > 1000 ? 1 / 2 : (len > 500 ? 1 / 4 : (len > 200 ? 1 / 6 : 1 / 10));
        for (var n = 0; n < len; n++) {
            var nm = (n - 1 + len) % len,
                n1 = (n + 1) % len,
                n2 = (n + 2) % len,
                X = transform(Bspline, [pts[nm].x, pts[n].x, pts[n1].x, pts[n2].x]),
                Y = transform(Bspline, [pts[nm].y, pts[n].y, pts[n1].y, pts[n2].y]);

            for (var t = 0; t < 1.0001; t += tension)
                curve.push({x: cubic(X, t), y: cubic(Y, t)});
        }
        return curve;
    }
})(window);

L.Canvas.mergeOptions({
    globalCompositeOperation: 'destination-in',
    /**
     * 双线配置,值为双线的间隔值或者不设置双线
     * @property doubleLine
     * @type {int|boolean}
     * @default false
     */
    doubleLine:false,
    /**
     * 遮罩的线宽。此属性在遮罩数据为折线时使用
     * @property maskLineWidth
     * @type {int}
     * @default 0
     */
    maskLineWidth:0,

    /**
     * 设置成true可以解决填色之间有缝隙的问题
     * @property lighter
     * @type {boolean}
     * @default false
     */
    lighter:false
});
/**
 * Update Note：
 *      + v1.5.3 : 1. 增加三线的渲染支持，搭配layer.options.tripleLine，eg:{weight:10,tripleLine:[7,3]}
 *                 2. 增加可以与csLayer同时响应鼠标事件的功能
 *      + v1.5.4 : 解决填色之间有缝隙的问题
 */
L.Canvas.include({
    _initContainer: function () {
        var container = this._container = document.createElement('canvas');
        if(this.options.zIndex)
            this._container.style.zIndex = this.options.zIndex;
        if(!this.options.interactive)
            this._container.style.pointerEvents='none';

        if(this.options.interactive && this._map){
            // Tip: 为了能和csLayer同时侦听到鼠标事件，改为用mapPane侦听
            var domObject = this._map._mapPane;
            L.DomEvent
                .on(domObject, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
                .on(domObject, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
                .on(domObject, 'mouseout', this._handleMouseOut, this);
        }

        this._ctx = container.getContext('2d');
    },
    _handleMouseOut: function (e) {
        var layer = this._hoveredLayer;
        if (layer) {
            // if we're leaving the layer, fire mouseout
            L.DomUtil.removeClass(this._map._mapPane, 'leaflet-interactive');
            this._fireEvent([layer], e, 'mouseout');
            this._hoveredLayer = null;
        }
    },

    _handleMouseHover: function (e, point) {
        var layer, candidateHoveredLayer;

        for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point)) {
                candidateHoveredLayer = layer;
            }
        }

        if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e);

            if (candidateHoveredLayer) {
                L.DomUtil.addClass(this._map._mapPane, 'leaflet-interactive'); // change cursor
                this._fireEvent([candidateHoveredLayer], e, 'mouseover');
                this._hoveredLayer = candidateHoveredLayer;
            }
        }

        if (this._hoveredLayer) {
            this._fireEvent([this._hoveredLayer], e);
        }
    },
    // 增加双实线的写法
    _updatePoly: function (layer, closed) {
        if (!this._drawing) { return; }

        var i, j, len2, p,
            parts = layer._parts,
            len = parts.length,
            ctx = this._ctx;

        if (!len) { return; }

        this._drawnLayers[layer._leaflet_id] = layer;

        ctx.beginPath();

        if (ctx.setLineDash) {
            ctx.setLineDash(layer.options && layer.options._dashArray || []);
        }

        for (i = 0; i < len; i++) {
            for (j = 0, len2 = parts[i].length; j < len2; j++) {
                p = parts[i][j];
                ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
            }
            if (closed) {
                ctx.closePath();
            }
        }

        this._fillStroke(ctx, layer);

        this._setMultipleLine(ctx, layer);

        // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
    },
    // 更新基数样条曲线
    _updateCardinalSpline:function (layer, closed) {
        if (!this._drawing) { return; }

        var i, j, len2, p,
            parts = layer._parts,
            len = parts.length,
            ctx = this._ctx;
        var curveZoom = layer.options.curveZoom || 7;

        if (!len) { return; }

        this._drawnLayers[layer._leaflet_id] = layer;

        ctx.beginPath();

        if (ctx.setLineDash) {
            ctx.setLineDash(layer.options && layer.options._dashArray || []);
        }

        var zoom = this._map.getZoom();
        var min = this._bounds.min, max = this._bounds.max;
        for (i = 0; i < len; i++) {
            var curve = parts[i];
            if(zoom >= curveZoom){
                var visible = false;
                for (j = 0, len2 = parts[i].length; j < len2; j++) {
                    p = parts[i][j];
                    if (p.x >= min.x && p.y >= min.y && p.x <= max.x && p.y <= max.y) {
                        visible = true;
                        break;
                    }
                }
                if(visible)
                    curve = getBspline(parts[i]);
            }

            for (j = 0, len2 = curve.length; j < len2; j++) {
                p = curve[j];
                ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
            }
            if (closed) {
                ctx.closePath();
            }
        }


        this._fillStroke(ctx, layer);
        this._setMultipleLine(ctx, layer);
    },

    _fillStroke: function (ctx, layer) {
        var options = layer.options;

        if (options.fill) {
            if(this.options.lighter)
                ctx.globalCompositeOperation = "lighter";//Tip:解决填色之间有缝隙的问题
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || 'evenodd');
        }

        if (options.stroke && options.weight !== 0) {
            ctx.globalCompositeOperation = "source-over";
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
        }
    },

    _setMultipleLine:function(ctx, layer){
        if(layer.options.doubleLine){
            var prev = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation= 'destination-out';
            ctx.lineWidth = layer.options.doubleLine;
            ctx.stroke();
            ctx.globalCompositeOperation=prev;
        }
        else if(layer.options.tripleLine){
            var prev = ctx.globalCompositeOperation;
            ctx.globalCompositeOperation= 'destination-out';
            ctx.lineWidth = layer.options.tripleLine[0];
            ctx.stroke();
            ctx.globalCompositeOperation= 'destination-over';
            ctx.lineWidth = layer.options.tripleLine[1];
            ctx.stroke();
            ctx.globalCompositeOperation=prev;
        }
    },

    _redraw: function () {
        this._redrawRequest = null;

        this._clear(); // clear layers in redraw bounds
        this._draw(); // draw layers

        this._redrawBounds = null;

        this.setMask();
    },

    resetMask: function(maskGeoJson) {
        this.options.maskGeoJson = maskGeoJson;
        if(this._map) this._redraw();
    },

    setMask:function () {
        var maskGeoJson = this.options.maskGeoJson;
        if(maskGeoJson && this._map){
            if (maskGeoJson && maskGeoJson instanceof L.GeoJSON) {

                var offset = this.options.maskOffset ? this._bounds.min : L.point(0,0),
                    ctx=this._ctx;
                var prev = ctx.globalCompositeOperation;
                ctx.globalCompositeOperation= this.options.globalCompositeOperation;

                ctx.beginPath();
                var _layers = maskGeoJson._layers;
                for (var key in _layers) {
                    var parts = _layers[key]._parts;
                    for (var i = 0; i < parts.length; i++) {
                        if(parts[i].length >= 2){
                            for (var j = 0, len2 = parts[i].length; j < len2; j++) {
                                var p = parts[i][j];
                                ctx[j ? 'lineTo' : 'moveTo'](p.x - offset.x, p.y - offset.y);
                            }
                            if(!this.options.maskLineWidth)
                                ctx.closePath();
                        }
                    }
                }
                if(!this.options.maskLineWidth){
                    ctx.fillStyle = '#000';
                    ctx.fill("evenodd");
                }
                else{
                    ctx.lineWidth = this.options.maskLineWidth;
                    ctx.stroke();
                }
                ctx.globalCompositeOperation=prev;
            }
        }
    }
});


LW.CSpline = L.Polygon.extend({
    options:{
        noClip: true,
        smoothFactor: 0,
        closed:true
    },
    _updatePath: function () {
        this._renderer._updateCardinalSpline(this, this.options.closed);
    },
    _updateStyle: function () {
        this._renderer._updateStyle(this);
    }
});

LW.cSpline = function (latlngs, options) {
    return new LW.CSpline(latlngs, options);
};

/**
 * @module Renderer
 */
/**
 * LW的不变换canvas
 *
 * Features :
 *      1. no translate when update,用于canvas铺满绘制的情况，不用于矢量绘制的情况
 *      2. 继承于L.Canvas
 *      3. 默认可交互
 *      4. 可以设置遮罩属性的配置
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.4.7 ：由LW.NoTranslateCanvas改名为LW.Canvas
 *
 * @class LW.Canvas
 * @extends L.Canvas
 */

LW.Canvas = L.Canvas.extend({
    options: {
        fitDpr:true,
        padding: 0,
        interactive:true,
        /**
         * 遮罩矢量
         * @property maskGeoJson
         * @type {LW.maskGeoJson|null}
         * @default null
         */
        maskGeoJson:null,
        /**
         * 遮罩偏移
         * @property maskGeoJson
         * @type {LW.maskGeoJson|null}
         * @default true
         */
        maskOffset:true
    },
    _initContainer: function () {
        var container = this._container = document.createElement('canvas');
        if(this.options.zIndex)
            this._container.style.zIndex = this.options.zIndex;
        if(!this.options.interactive)
            this._container.style.pointerEvents='none';

        this._ctx = container.getContext('2d');
    },

    resetInteractive:function (interactive) {
        this.options.interactive = interactive;
        if(interactive)
            this._container.style.pointerEvents='auto';
        else
            this._container.style.pointerEvents='none';
    },

    _update: function (reset) {
        if (this._map._animatingZoom && this._bounds) {
            return;
        }

        this._drawnLayers = {};

        L.Renderer.prototype._update.call(this);

        var b = this._bounds,
            container = this._container,
            size = b.getSize(),
            // m = L.Browser.retina ? 2 : 1;
            m = this.options.fitDpr ? Sun.Common.dpr : 1;
            // m = 1;// modified by helen in 2016/9/30

        L.DomUtil.setPosition(container, b.min);

        // set canvas size (also clearing it); use double size on retina
        if(container.width!==size.x || container.height!==size.y || reset){
            container.width = m * size.x;
            container.height = m * size.y;
            container.style.width = size.x + 'px';
            container.style.height = size.y + 'px';
        }

        //if (L.Browser.retina) {
           this._ctx.scale(m, m);
        //}

        // translate so we use the same path coordinates after canvas element moves
        // this._ctx.translate(-b.min.x, -b.min.y);

        // Tell paths to redraw themselves
        // this.fire('update');
    }
});
LW.canvas = function (options) {
    return L.Browser.canvas ? new LW.Canvas(options) : null;
};

// Tip:向下兼容v1.4.7的名字更换
LW.NoTranslateCanvas = LW.Canvas;
LW.noTranslateCanvas = LW.canvas;





var glUtil = {
    // 创建着色器方法，输入参数：渲染上下文，着色器类型，数据源
    createShader: function (gl, type, source) {
        var shader = gl.createShader(type); // 创建着色器对象
        gl.shaderSource(shader, source); // 提供数据源
        gl.compileShader(shader); // 编译 -> 生成着色器
        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader;
        }

        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    },

    createProgram: function (gl, vs, fs) {
        var program = gl.createProgram();
        var vertexShader = glUtil.createShader(gl, gl.VERTEX_SHADER, vs),
            fragmentShader = glUtil.createShader(gl, gl.FRAGMENT_SHADER, fs);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
            return program;
        }

        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    },
    getPrgObj: function (gl, vs, fs) {
        var prgObj = {};
        var program = prgObj.program = glUtil.createProgram(gl, vs, fs);
        var attrs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (i = 0; i < attrs; i++) {
            var attr = gl.getActiveAttrib(program, i);
            prgObj[attr.name] = gl.getAttribLocation(program, attr.name)
        }
        var uniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (j = 0; j < uniforms; j++) {
            var uniform = gl.getActiveUniform(program, j);
            prgObj[uniform.name] = gl.getUniformLocation(program, uniform.name)
        }
        return prgObj;
    },
    bindTexture: function (gl, type, data, width, height) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, type);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, type);
        data instanceof Uint16Array ? gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_SHORT_4_4_4_4, data) :
            data instanceof Uint8Array ? gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data) :
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    },
    bindImgTexture:function(gl,type, source, width, height){
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        // Tip: 1. 具有指定长宽的image/canvas的方法只有webgl2才支持，webgl1只支持2的幂次方长宽的图片纹理，如果webgl2没有成功，则可能会`parameter 9 is not of type 'ArrayBufferView'`的错误
        //      2. 纹理的最大size，有的GPU是16384,有的是4096。 gl.getParameter(gl.MAX_TEXTURE_SIZE)
        //      3. Safari全系不支持webgl2, Android版本58以上才支持webgl2
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, type);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, type);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    },
    activeTexture: function (gl, tex, e) {
        gl.activeTexture(gl.TEXTURE0 + e);
        gl.bindTexture(gl.TEXTURE_2D, tex);
    }
};

/**
 * 基于webgl的Canvas
 *
 * Update Note：
 *      + v1.5.2 ：Created
 *
 * @class LW.GlCanvas
 * @extends L.Canvas
 */
LW.GlCanvas = L.Canvas.extend({

    options:{
        padding: 0
    },

    _initContainer: function() {
        var canvas = this.canvas = this._container = document.createElement('canvas');
        this.gl = canvas.getContext("webgl2", {preserveDrawingBuffer: true,stencil: true}) ||
            canvas.getContext("experimental-webgl", {preserveDrawingBuffer: true,stencil: true});

        this.setStencilTest();
    },

    _update: function () {
        if (this._map._animatingZoom && this._bounds) { return; }

        this._drawnLayers = {};

        L.Renderer.prototype._update.call(this);

        var b = this._bounds,
            container = this._container,
            size = b.getSize(),
            m = 1;

        L.DomUtil.setPosition(container, b.min);

        // set canvas size (also clearing it); use double size on retina
        container.width = m * size.x;
        container.height = m * size.y;
        container.style.width = size.x + 'px';
        container.style.height = size.y + 'px';

        this._latLngBounds = L.latLngBounds(this._map.layerPointToLatLng(this._bounds.min), this._map.layerPointToLatLng(this._bounds.max));

        // Tell paths to redraw themselves
        this.fire('update');
    },

    _clear: function () {
        var gl = this.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    },

    _draw:function () { },

    getVs: function() {
        return 'attribute vec3 aPos;attribute vec2 aTextureCoords;varying vec2 vTextureCoord;void main() {gl_Position = vec4(aPos,1.0);vTextureCoord = aTextureCoords;}';
    },

    getFs: function(){
        return 'precision highp float;varying vec2 vTextureCoord;uniform sampler2D uSampler;void main(void) {vec4 color = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));if (color.rgb == vec3(1.0,0.0,0.0))discard;gl_FragColor = color;}'
    },

    setStencilTest:function(){
        var gl = this.gl;
        if(gl){
            if(this.options.maskGeoJson){
                gl.enable(gl.STENCIL_TEST);

                if(!this.prgObj){
                    var maskVertex = [ -1,-1,0,  1,-1,0,  1,1,0,  -1,-1,0,  1,1,0,  -1,1,0];
                    var vsBuffer = this.vsBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vsBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(maskVertex), gl.STATIC_DRAW);

                    var maskTexCoordBuffer = this.maskTexCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, maskTexCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]), gl.STATIC_DRAW);

                    this.prgObj = glUtil.getPrgObj(gl,this.getVs(),this.getFs());
                }
            }
            else
                gl.disable(gl.STENCIL_TEST);
        }
    },

    resetMask: function(maskGeoJson,draw) {// draw的判定用于，填色不显示时，重设遮罩的异常处理
        this.options.maskGeoJson = maskGeoJson;
        this.setStencilTest();
        if(this._map && draw) this._redraw();
    },

    setMask:function () {
        var maskGeoJson = this.options.maskGeoJson;
        var gl = this.gl, prgObj = this.prgObj;
        if(maskGeoJson && this._map && gl && prgObj){
            if (maskGeoJson instanceof L.GeoJSON) {
                if (!this.mask) {
                    this.mask = L.DomUtil.create('canvas');
                    this.maskCtx = this.mask.getContext("2d");
                }
                var self = this;
                var mask = this.mask,container = this._container;
                drawMask2D();
                drawMaskWebgl();
            }
        }

        function drawMask2D() {
            L.DomUtil.setPosition(mask, L.DomUtil.getPosition(container));
            mask.width = container.width;
            mask.height = container.height;
            mask.style.width = container.style.width;
            mask.style.height = container.style.height;

            var ctx = self.maskCtx,offset = self._bounds.min;
            ctx.beginPath();
            ctx.fillStyle = '#f00';
            ctx.fillRect(0, 0, container.width, container.height);
            ctx.fillStyle = '#ff0';
            var _layers = maskGeoJson._layers;
            for (var key in _layers) {
                var parts = _layers[key]._parts;
                for (var i = 0; i < parts.length; i++) {
                    if (parts[i].length >= 2) {
                        for (var j = 0, len2 = parts[i].length; j < len2; j++) {
                            var p = parts[i][j];
                            ctx[j ? 'lineTo' : 'moveTo'](p.x - offset.x, p.y - offset.y);
                        }
                        ctx.closePath();
                    }
                }
            }
            ctx.fill("evenodd");
            // console.log(this.mask.toDataURL("image/png"));
        }

        function drawMaskWebgl() {
            gl.useProgram(prgObj.program);

            gl.bindBuffer(gl.ARRAY_BUFFER, self.vsBuffer);
            gl.vertexAttribPointer(prgObj.aPos, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(prgObj.aPos);

            gl.bindBuffer(gl.ARRAY_BUFFER, self.maskTexCoordBuffer);
            gl.enableVertexAttribArray(prgObj.aTextureCoords);
            gl.vertexAttribPointer(prgObj.aTextureCoords, 2, gl.FLOAT, false, 0, 0);

            // Always pass test
            gl.stencilFunc(gl.ALWAYS, 1, 0xff);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
            gl.stencilMask(0xff);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            // No need to display the triangle
            gl.colorMask(0, 0, 0, 0);

            gl.deleteTexture(self.maskTexture);
            var maskTexture = self.maskTexture = glUtil.bindImgTexture(gl, gl.LINEAR, mask, mask.width, mask.height);
            glUtil.activeTexture(gl, maskTexture, 0);
            gl.uniform1i(prgObj.uSampler, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
    }
});


LW.glCanvas = function (options) {
    return new LW.GlCanvas(options);
};




/**
 * Created by whl on 2016/1/6.
 */
LW.ShadowCanvas = L.Canvas.extend({
    options: {
        padding: 0,
        shadow:true,
        shadowColor:'#999',
        shadowOffsetX:20,
        shadowOffsetY:20,
        shadowBlur:10
    },
    _fillStroke: function (ctx, layer) {
        if(this.options.shadow){
            ctx.shadowColor = this.options.shadowColor;
            ctx.shadowOffsetX = this.options.shadowOffsetX;
            ctx.shadowOffsetY = this.options.shadowOffsetY;
            ctx.shadowBlur = this.options.shadowBlur;
        }

        var options = layer.options;

        if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || 'evenodd');
        }
        if (options.stroke && options.weight !== 0) {
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
        }

        if(this.options.shadow){
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;
        }
    }
});
LW.shadowCanvas = function (options) {
    return L.Browser.canvas ? new LW.ShadowCanvas(options) : null;
};

/**
 * 可剪裁的SVG
 * Features :
 *      1. 可设置遮罩
 *      2. 可设置pattern填充
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.4.4 ：增加patternLegend属性来设置不同的模式填充
 *      + v1.5.4 ：增加patternLegend的间隔可以配置是否填色的功能
 * @class LW.ClipPathSvg
 * @extends L.SVG
 */
LW.ClipPathSvg = L.SVG.extend({
    options:{
        maskGeoJson:null,
        /**
         * 模式填充图例
         *
         * 数据格式 ：[{id:xx,color:'#f00',type:'r_bias',fill:false/'#fff', strokeWidth:2,width:15}]
         *
         * type :
         *      1. r_bias: 右斜线（若数据不传type，默认为右斜线）
         *      2. l_bias: 左斜线
         *      3. h_line: 横线
         *      4. v_line: 竖线
         *
         * @property patternLegend
         * @type {Array|null}
         * @default null
         */
        patternLegend:null
    },

    initialize: function (options) {
        L.SVG.prototype.initialize.call(this,options);
        if (!this._container) {
            this._initContainer(); // defined by renderer implementations

            if (this._zoomAnimated) {
                L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
            }
        }
    },

    onAdd: function () {
        this.getPane().appendChild(this._container);
        this._update();
        this.on('update', this._updatePaths, this);
    },

    setMaskKey:function (key) {
        this._rootGroup = this._rootGroups[key];
    },

    _initContainer: function () {
        this._container = L.SVG.create('svg');
        L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
        this.id = L.stamp(this);

        // makes it possible to click through svg root; we'll reset it back in individual paths
        this._container.setAttribute('pointer-events', 'none');

        this._rootGroup = L.SVG.create('g');
        this._container.appendChild(this._rootGroup);

        var defs = this.defs = L.SVG.create('defs');
        this._container.appendChild(defs);

        this._initPatten();
        this._initClipPath();
    },

    patternFn: {
        'r_bias':function (pat,item,a,fill) {
            if(fill) pat.appendChild(this.createRect(a,fill));
            var line1 = this.createLine(0,a,a,0,item.color,item.strokeWidth);
            pat.appendChild(line1);
            var line2 = this.createLine(-1,1,1,-1,item.color,item.strokeWidth);
            pat.appendChild(line2);
            var line3 = this.createLine(a-1,a+1,a+1,a-1,item.color,item.strokeWidth);
            pat.appendChild(line3);
        },
        'l_bias':function (pat,item,a,fill) {
            if(fill) pat.appendChild(this.createRect(a,fill));
            var line1 = this.createLine(0,0,a,a,item.color,item.strokeWidth);
            pat.appendChild(line1);
            var line2 = this.createLine(-1,a-1,1,a+1,item.color,item.strokeWidth);
            pat.appendChild(line2);
            var line3 = this.createLine(a-1,-1,a+1,1,item.color,item.strokeWidth);
            pat.appendChild(line3);
        },
        'h_line': function(pat,item,a,fill){
            if(fill) pat.appendChild(this.createRect(a,fill));
            var line1 = this.createLine(0,a/2,a,a/2,item.color,item.strokeWidth);
            pat.appendChild(line1);
        },
        'v_line': function(pat,item,a,fill){
            if(fill) pat.appendChild(this.createRect(a,fill));
            var line1 = this.createLine(a/2,0,a/2,a,item.color,item.strokeWidth);
            pat.appendChild(line1);
        },

        createLine: function (x1, y1, x2, y2,color,strokeWidth) {
            var line = L.SVG.create('line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', strokeWidth);
            return line;
        },

        createRect: function (w,color){
            var rect = L.SVG.create('rect');
            rect.setAttribute('width', w);
            rect.setAttribute('height', w);
            rect.setAttribute('fill', color);
            return rect;
        }
    },

    _initPatten:function () {
        var patternLegend = this.options.patternLegend,defs = this.defs;
        var patternFn = this.patternFn;
        if(patternLegend){
            patternLegend.forEach(function (item) {
                if(item.type){
                    var a = item.width || 15;
                    var pat = L.SVG.create('pattern');
                    pat.setAttribute('id', item.id);
                    pat.setAttribute('width', a);
                    pat.setAttribute('height', a);
                    pat.setAttribute('patternUnits', 'userSpaceOnUse');
                    defs.appendChild(pat);
                    patternFn[item.type](pat,item,a,item.fill);
                }
            });
        }
    },

    _initClipPath: function () {
        if(this.options.maskGeoJson instanceof L.GeoJSON){
            this._clipPath = L.SVG.create('clipPath');
            this.defs.appendChild(this._clipPath);
            this._clipPath.setAttribute('id', 'contour-mask' + this.id);
            this._updateClipPath();

            this._rootGroup.setAttribute('clip-path', 'url(#contour-mask' + this.id + ')');
        }
        else{//多个遮罩
            this._rootGroups = {};
            this._clipPaths = {};
            for(var key in this.options.maskGeoJson){
                var mask = this.options.maskGeoJson[key];
                var clipPath = L.SVG.create('clipPath');
                this.defs.appendChild(clipPath);
                clipPath.setAttribute('id', 'contour-mask' + this.id +key);
                this._clipPaths[key]=clipPath;
                this._updateClipPath(clipPath,mask);

                var rootGroup = L.SVG.create('g');
                this._container.appendChild(rootGroup);
                rootGroup.setAttribute('clip-path', 'url(#contour-mask' + this.id + key + ')');
                this._rootGroups[key]=rootGroup;
            }
        }

    },
    _update: function () {
        L.SVG.prototype._update.call(this);
        if(this.options.maskGeoJson instanceof L.GeoJSON)
            this._updateClipPath();
        else{
            for(var key in this.options.maskGeoJson){
                this._updateClipPath(this._clipPaths[key],this.options.maskGeoJson[key]);
            }
        }
    },
    _updateClipPath: function (clipPath,maskGeoJson) {
        clipPath = clipPath || this._clipPath;
        maskGeoJson = maskGeoJson || this.options.maskGeoJson;
        if (maskGeoJson && maskGeoJson instanceof L.GeoJSON) {
            var _layers = maskGeoJson._layers;
            for (i in _layers) {
                var path = _layers[i]._path;
                path.setAttribute('clip-rule','evenodd');
                clipPath.appendChild(path);
            }
        }
    },

    resetMask: function (maskGeoJson) {
        if (maskGeoJson && maskGeoJson instanceof  L.GeoJSON) {
            this.options.maskGeoJson = maskGeoJson;
            !this._clipPath ?  this._initClipPath() : this.defs.appendChild(this._clipPath);
            Sun.Util.Common.removeAllChildren(this._clipPath);
            this._updateClipPath();
        }
        else if(this._clipPath){
            this.defs.removeChild(this._clipPath);
        }
    },

    _updateStyle: function (layer) {
        L.SVG.prototype._updateStyle.call(this, layer);
        var options = layer.options;
        if(options.pointerEvents)
            layer._path.style.pointerEvents = options.pointerEvents;
    },
});

LW.clipPathSvg = function (options) {
    return L.Browser.svg ? new LW.ClipPathSvg(options) : null;
};

LW.HotspotSVG = LW.ClipPathSvg.extend({
    _initPath: function (layer) {
        L.SVG.prototype._initPath.call(this,layer);
        var path_over = layer._overPath = L.SVG.create('path');
        path_over.setAttribute('stroke', '#000');
        path_over.setAttribute('stroke-opacity', 0);
        path_over.setAttribute('stroke-width', 5);
        path_over.setAttribute('fill', 'none');

        var path = layer._hotspotPath = L.SVG.create('path');
        path.setAttribute('stroke', '#000');
        path.setAttribute('stroke-opacity', 0);
        path.setAttribute('stroke-width', 14);
        path.setAttribute('fill', 'none');
        path.style.pointerEvents='stroke';
    },

    _addPath: function (layer) {
        L.SVG.prototype._addPath.call(this,layer);
        this._rootGroup.appendChild(layer._overPath);
        this._rootGroup.appendChild(layer._hotspotPath);
        layer.addInteractiveTarget(layer._hotspotPath);
    },

    _removePath: function (layer) {
        L.SVG.prototype._removePath.call(this,layer);
        L.DomUtil.remove(layer._overPath);
        L.DomUtil.remove(layer._hotspotPath);
        layer.removeInteractiveTarget(layer._hotspotPath);
    },
    _setPath: function (layer, path) {
        L.SVG.prototype._setPath.call(this,layer,path);
        var _path = path.split('M');
        layer._hotspotPath.setAttribute('d', 'M'+_path[1]);
        layer._overPath.setAttribute('d', 'M'+_path[1]);
    },
});

LW.hotspotSvg = function (options) {
    return new LW.HotspotSVG(options);
};

// 增加textpath支持
LW.SVG = L.SVG.extend({
    _initContainer: function () {
        L.SVG.prototype._initContainer.call(this);
        this._defs = L.SVG.create('defs');
        this._container.appendChild(this._rootGroup);
    },
    _addPath: function (layer) {
        // defs path
        this._defs.appendChild(layer._path);
        layer._path.setAttribute('id', L.stamp(layer._path));

        // show path
        var path = L.SVG.create('use');
        path.setAttribute('xlink:href', layer._path._leaflet_id);
        this._rootGroup.appendChild(path);

        // text
        var text = L.SVG.create('text');
        this._rootGroup.appendChild(text);
        var textPath = layer._textPath = L.SVG.create('textPath');
        textPath.setAttribute('xlink:href', layer._path._leaflet_id);

        layer.addInteractiveTarget(layer._path);
    },

    _setPath: function (layer, path, text, gap, rotate) {
        layer._path.setAttribute('d', path);

        var d = this._getPathDistance(layer.getLatLngs());
        while (d > 0) {
            var tspan = L.SVG.create('tspan');
            layer._textPath.appendChild(tspan);
            tspan.innerText = text;
            if (Sun.Util.isValid(rotate))
                tspan.setAttribute('rotate', rotate);
            for (var i = 0; i < gap; i++) {
                var _tspan = L.SVG.create('tspan');
                tspan.setAttribute('stroke', 'none');
                tspan.setAttribute('fill', 'none');
                layer._textPath.appendChild(_tspan);
                _tspan.innerText = '_';
            }
            d -= 12 * (gap + 1);
        }


    },

    _getPathDistance: function (latlngs) {
        var p0, d = 0;
        for (var i = 0; i < latlngs.length; i++) {
            var latlng = latlngs[i];
            if (latlng && 'lat' in latlng) {
                if (d == 0)
                    p0 = this._map.latLngToLayerPoint(latlng);
                else {
                    var p1 = this._map.latLngToLayerPoint(latlng);
                    d += p0.distanceTo(p1);
                }
            }
            else if (L.Util.isArray(latlng))
                this._getPathDistance(latlng);
        }
        return d;
    },

    _removePath: function (layer) {
        L.DomUtil.remove(layer._path);
        L.DomUtil.remove(layer._textPath);
        layer.removeInteractiveTarget(layer._path);
    }
});


/**
 * geometry 类型的枚举
 * @type {{polygon_label: string, measureLine: string, rect: string, polygon: string, symbolLine: string, marker: string, labelLine: string, circle: string, polyline: string, profileLine: string}}
 *
 * Update Note ：
 *      + v1.5.5 ：Created
 */
LW.GeoType = {
    polyline:'polyline',
    labelLine:'labelLine',
    symbolLine:'symbolLine',
    measureLine:'measureLine',
    profileLine:'profileLine',
    polygon:'polygon',
    polygon_label:'polygon_label',
    measurePolygon:'measurePolygon',
    rect:'rect',
    circle:'circle',
    marker:'marker'
};

L.GeoJSON.include({
    setData:function (geojson) {
        this.clearLayers();
        if (geojson) {
            this.data = geojson;
            this.addData(geojson);
        }
    },
    
    resetOptionsStyle:function (style) {
        this.options.style = L.extend({}, this.options.style, style);
        return this.eachLayer(function (layer) {
            this.resetStyle(layer);
        }, this);
    }
});



/**
 * 几何图元集,最早的数值预报展示，将弃用
 *
 * Features :
 *      1. 支持贝塞尔曲线和折线组成的图元集
 *      2. 渲染器为svg
 *
 * @class LW.GeometryUnion
 * @extends L.Polygon
 */

LW.GeometryUnion = L.Polygon.extend({
    options: {
        renderer: L.svg(),
        maskGeoJson: null,
        pointerEvents: 'none',


        /**
         * 曲线类型
         *
         * Options :
         *      1. basis:贝塞尔曲线
         *      2. cardinal:基数样条曲线
         *
         * @property lineType
         * @type {string}
         * @default 'basis'
         */
        lineType: 'basis'
    },

    line: null,

    initialize: function (latlngs, options) {
        L.setOptions(this, options);
        this._latlngs = latlngs;
        this.line = d3.svg.line();
    },
    _project: function () {
        this._rings = '';
        this._projectLatlngs(this._latlngs);

        // project bounds as well to use later for Canvas hit detection/etc.
        var w = this._clickTolerance(),
            p = new L.Point(w, -w);

        // if (this._bounds.isValid()) {
        //    this._pxBounds = new L.Bounds(
        //        this._map.latLngToLayerPoint(this._bounds.getSouthWest())._subtract(p),
        //        this._map.latLngToLayerPoint(this._bounds.getNorthEast())._add(p));
        // }
    },
    // recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs) {
        for (var i = 0; i < latlngs.length; i++) {
            var planeType = latlngs[i].subplanetype;
            var interpolateType;
            if (planeType == 0)
                interpolateType = 'linear';
            else if (planeType == 1)
                interpolateType = this.options.lineType;
            else
                interpolateType = this.options.lineType + '-closed';
            this.line.interpolate(interpolateType);
            var items = latlngs[i].pointitems;
            if (items.length > 0) {
                var ring = [];
                for (var j = 0; j < items.length; j++) {
                    var p = this._map.latLngToLayerPoint(items[j]);
                    ring[j] = [p.x, p.y];
                }
                var d = this.line(ring);
                // 去除第一个Move点后MoveTo的点
                if (i != 0 && planeType != 3 && d.charAt(0) == 'M') {
                    d = d.slice(1);
                    while (d.charCodeAt(0) < 65) {//Tip:数字和','的Unicode编码均小于65
                        d = d.slice(1);
                    }
                }
                this._rings += d;
            }
        }
    },

    _updatePath: function () {
        this._renderer._setPath(this, this._rings);
    },

    _updateStyle: function () {
        this._renderer._updateStyle(this);
    }
});

LW.geometryUnion = function (latlngs, options) {
    return new LW.GeometryUnion(latlngs, options);
};


/**
 * 带标识文本的折线，默认A-Z..
 * Features :
 *      1. 序号编码可以为ASCII码，用isASCII属性配置
 *
 * Update Note ：
 *      + v1.5.3 ：Created
 *      + v1.5.6 ：修改默认样式为白色底图版样式
 *
 * @class LW.LabelPolyline
 */
LW.LabelPolyline = L.Polyline.extend({
    options:{
        // color: '#33fffb',
        color: '#eb6a01',
        closeBtn:true,
        iconUrl: 'close-icon.png',
        start:65,
        isASCII:true,
        infoClass:'',
        interactive: false
    },
    geoType:LW.GeoType.labelLine,
    initialize: function (latlngs, options) {
        L.Polyline.prototype.initialize.call(this, latlngs, options);
        this.labelLayer = L.layerGroup({pane: 'markerPane'});
        this.data = {latlngs:[],texts:[]};
        this.start = this.options.start;

        var self = this;
        this.on('editable:drawing:commit',function (e) {
            self.commited = true;
            self.addCloseIcon(e.latlng);
        });
        this.on('editable:shape:delete', function (e) {
            if(self._map)
                self._map.removeLayer(this.labelLayer);
        });
    },

    onAdd: function () {
        L.Polyline.prototype.onAdd.call(this);
        this._map.addLayer(this.labelLayer);
        if (this._closeMarker && !this._map.hasLayer(this._closeMarker))
            this._map.addLayer(this._closeMarker);

        var deleteShape = function (e) {
            if ((e.originalEvent.ctrlKey || e.originalEvent.metaKey) && this.editEnabled()) this.editor.deleteShapeAt(e.latlng);
        };
        this.on('click', L.DomEvent.stop).on('click', deleteShape, this);
    },

    onRemove: function () {
        L.Polyline.prototype.onRemove.call(this);
        this._map.removeLayer(this.labelLayer);
        if (this._closeMarker){
            this._closeMarker.off();
            this._map.removeLayer(this._closeMarker);
        }
    },

    deleteShape: function (e) {
        if (this.editEnabled() && e) this.editor.deleteShapeAt(e.latlng);
        if (this._map)  this._map.removeLayer(this);
    },

    redraw: function () {
        this.data.latlngs = this._latlngs;
        if (this._map)
            this._setData(this._latlngs);
        return this;
    },

    /**
     * 设置数据
     * @param data
     * @returns {LW.LabelPolyline}
     */
    setData: function (data) {
        this.data = data;
        this.commited = true;
        this._setLatLngs(data.latlngs);
        this._setData(data.latlngs);
        return this;
    },

    _setData:function (latlngs){
        this.start = this.options.start;
        this.labelLayer.clearLayers();
        if (this._map) {
            this._renderer._updatePath(this);
            for(var i=0;i<latlngs.length;i++){
                this._setLabel(i);
            }
            if(this.commited)
                this.addCloseIcon(latlngs[latlngs.length-1]);
        }
    },

    _setLabel:function (idx){
        var loc = this._latlngs[idx];
        var label = LW.labelMarker(loc, {
            interactive:false,
            iconOptions: {
                fontSize: '14px',
                color: '#515e70',
                edge:false,
                bold: false,
                iconAnchor: new L.Point(20,-6),
                className:this.options.infoClass
            }
        }).addTo(this.labelLayer);
        var t = this.start++;
        label.setData(this.options.isASCII?String.fromCharCode(t):t);
        return this;
    },

    addCloseIcon:function (latlng) {
        var self = this;
        if(this.options.closeBtn && latlng){
            if (!this._closeMarker) {
                var iconUrl = LW.defaultIconPath() + this.options.iconUrl;
                this._closeMarker = new L.Marker(latlng, {zIndexOffset:99999,icon: new L.Icon({iconUrl: iconUrl, iconAnchor: L.point(30, 9)})})
                    .addTo(this._map);
                this._closeMarker.on('click',function () {
                    self.deleteShape({latlng:latlng});
                })
            } else {
                this._closeMarker.setLatLng(latlng);
            }
        }
    }

});
/**
 * 测距折线
 * Features :
 *
 * Update Note ：
 *      + v1.4.2 ：Created
 *      + v1.5.5 ：增加每个点是否累计长度的配置
 *      + v1.5.6 ：增加是否展示方位角的支持
 *
 * @class LW.MeasureLine
 */
LW.MeasureLine = LW.LabelPolyline.extend({
    options:{
        infoClass:'lw-measure-info',
        /**
         * 是否每个点累计长度
         * @property eachSum
         * @type {Boolean}
         * @default true
         */
        eachSum:true,
        /**
         * 是否展示方位角
         * @property bearing
         * @type {Boolean}
         * @default false
         */
        bearing:false,
    },
    geoType:LW.GeoType.measureLine,

    initialize: function (latlngs, options) {
        LW.LabelPolyline.prototype.initialize.call(this, latlngs, options);
        this.totalDistance = 0;
    },
    _setData:function (latlngs){
        this.totalDistance = 0;
        LW.LabelPolyline.prototype._setData.call(this, latlngs);
    },

    _setLabel:function (idx){
        var loc,text;
        var eachSum = this.options.eachSum;
        if(idx == 0){
            loc = this._latlngs[0];
            text = '起点';
        }
        else{
            loc = this._latlngs[idx];
            var loc1 = this._latlngs[idx - 1];
            var d = Sun.Util.Math.round(loc1.distanceTo(loc) / 1000, 2);
            this.totalDistance = Sun.Util.Math.toFixed(parseFloat(this.totalDistance) + parseFloat(d), 2);
            text = (eachSum ? this.totalDistance : d ) +'km';
            if(this.options.bearing){
                // Tip: 同第一个点的方位角
                var bearing = Math.round(L.GeometryUtil.bearing(this._latlngs[0],loc,true));
                text += '， '+bearing+'°';
            }
        }
        var label = this.lastLabel = LW.labelMarker(loc, {
            iconOptions: {
                fontSize: '14px',
                color: '#515e70',
                edge:false,
                bold: false,
                textAlign:'left',
                className:this.options.infoClass,
                iconAnchor: new L.Point(-12,0)
            }
        }).addTo(this.labelLayer);
        label.setData(text);
    },

    addCloseIcon:function (latlng) {
        LW.LabelPolyline.prototype.addCloseIcon.call(this,latlng);
        var d = this.totalDistance;
        var text = this.options.eachSum ? '总长:'+d +'km' : (this.lastLabel.value + '<br/>总长: <span class="total">'+d +'</span> km')
        this.lastLabel.setData(text)
    }
});

LW.measureLine = function (latlngs, options) {
  return new LW.MeasureLine(latlngs,options);
};

/**
 * 标志线，现主要用于临时航线的展示
 * Features :
 *      1. 带icon序号、tooltip、两点之间的图表的标志线
 *
 * Update Note ：
 *      + v1.5.5 ：Created
 *
 * @class LW.SymbolLine
 */
LW.SymbolLine = LW.LabelPolyline.extend({
    options:{
        color: '#f5a623',
        dashArray:[1,6],
        start:1,
        infoClass:'lw-symbol-info',
        closeBtn:false,
        toolTipOptions:{
            direction:'top',
            className:'lw-symbol-tooltip',
            offset:L.point(0,-15),
            permanent:true
        },
        symbolOptions:{
            // iconUrl:'',
            // iconSize:     [],
            // iconAnchor:   []
        },
    },
    geoType:LW.GeoType.symbolLine,

    redraw: function () {
        this.data.latlngs = this._latlngs;
        if (this._map)
            this._setData(this._latlngs,this.data.texts||[]);
        return this;
    },

    /**
     * 设置数据
     * @param data {Object} {latlng:[],texts:[]}
     * @returns {LW.SymbolLine}
     */
    setData: function (data) {
        this.data = data;
        this._setLatLngs(data.latlngs);
        this._setData(data.latlngs,data.texts);
        return this;
    },
    _setData:function (latlngs,texts){
        this.options.start = 1;
        this.labelLayer.clearLayers();
        if (this._map) {
            this._renderer._updatePath(this);
            for(var i=0;i<latlngs.length;i++){
                this._setLabel(i-1,i,texts[i]);
            }
        }
    },

    _setLabel:function (idx1,idx2,text){
        text = text || '';
        var l1 = this._latlngs[idx1],l2 = this._latlngs[idx2];
        var label = LW.labelMarker(l2, {
            iconOptions: {
                fontSize: '14px',
                color: this.options.color,
                edge: false,
                className:this.options.infoClass,
                iconSize: new L.Point(24,24),
                iconAnchor: new L.Point(12,12)
            }
        }).addTo(this.labelLayer);
        label.setData(this.options.start++);

        var content = 'E'+Sun.Math.round(l2.lng,3)+'° N'+Sun.Math.round(l2.lat,3)+'° '+text;
        label.bindTooltip(content,this.options.toolTipOptions).openTooltip();

        if(l1 && l2){
            var lat = Math.abs(l1.lat+(l2.lat-l1.lat)/2),lng = Math.abs(l1.lng+(l2.lng-l1.lng)/2);
            var bearing = L.GeometryUtil.bearing(l1,l2);
            var iconOptions = this.options.symbolOptions;
            iconOptions.rotation = bearing;
            L.marker([lat,lng],{icon:L.icon(iconOptions)}).addTo(this.labelLayer);
        }
        return this;
    }
});

LW.symbolLine = function (latlngs, options) {
    return new LW.SymbolLine(latlngs,options);
};


/**
 * 带标识文本的多边形，默认从1开始
 * Features :
 *      1. 序号编码可以为ASCII码，用isASCII属性配置
 *
 * Update Note ：
 *      + v1.5.5 ：Created
 *      + v1.5.6 ：修改默认样式为白色底图版样式
 */
LW.LabelPolygon = L.Polygon.extend({
    options:{
        color: '#eb6a01',
        fillOpacity:0.1,
        start:1,
        isASCII:false,
        infoClass:'',
        closeBtn:false,
        iconUrl: 'close-icon.png',
        interactive: false,
        label:true,
        /**
         * 是否绑定提示框
         */
        bindTooltip:false,
        toolTipOptions:{
            direction:'top',
            className:'lw-symbol-tooltip',
            offset:L.point(0,-15),
            permanent:true
        },
    },
    geoType:LW.GeoType.polygon_label,

    initialize: function (latlngs, options) {
        L.Polygon.prototype.initialize.call(this, latlngs, options);
        this.labelLayer = L.layerGroup({pane: 'markerPane'});
        this.start = this.options.start;
        this.data = {latlngs:[],texts:[]};

        this._closeEvent();
    },

    _closeEvent:function (){
        var self = this;
        this.on('editable:drawing:commit',function (e) {
            self.commited = true;
            self.addCloseIcon(e.latlng);
        });
        this.on('editable:shape:delete', function (e) {
            // if(self._map)
            //     self._map.removeLayer(self.labelLayer);
        });
    },

    onAdd: function () {
        L.Polygon.prototype.onAdd.call(this);
        this._map.addLayer(this.labelLayer);
    },

    onRemove: function () {
        L.Polygon.prototype.onRemove.call(this);
        this._map.removeLayer(this.labelLayer);
        if (this._closeMarker){
            this._closeMarker.off();
            this._map.removeLayer(this._closeMarker);
        }
    },

    getLatLngs: function () {
        return this._latlngs[0];
    },

    deleteShape: function (e) {
        if (this.editEnabled() && e) this.editor.deleteShape(e.latlng,this._latlngs);
        if (this._map)  this._map.removeLayer(this);
    },

    redraw: function () {
        this.data.latlngs = this.getLatLngs();
        if (this._map)
            this._setData(this.data.latlngs);
        return this;
    },

    /**
     * 设置数据
     * @param data
     * @returns this
     */
    setData: function (data) {
        this.data = data;
        this.commited = true;
        this._setLatLngs(data.latlngs);
        this._setData(data.latlngs);
        return this;
    },

    _setData:function (latlngs){
        this.start = this.options.start;
        this.labelLayer.clearLayers();
        if (this._map) {
            this._renderer._updatePath(this);
            for(var i=0;i<latlngs.length;i++){
                this._setLabel(i);
            }
            if(this.commited)
                this.addCloseIcon(latlngs[latlngs.length-1]);
        }
    },

    _setLabel:function (idx){
        var loc = this._latlngs[0][idx];
        var label = LW.labelMarker(loc, {
            interactive:false,
            iconOptions: {
                fontSize: '14px',
                color: '#515e70',
                className: this.options.infoClass,
                edge: true,
                iconAnchor: new L.Point(20,-6)
            }
        }).addTo(this.labelLayer);
        var t = this.start++;
        label.setData(this.options.label?(this.options.isASCII?String.fromCharCode(t):t):'');

        if(this.options.bindTooltip){
            var content = 'N '+Sun.Math.round(loc.lat,3)+'°<br/>E '+Sun.Math.round(loc.lng,3)+'° ';
            label.bindTooltip(content,this.options.toolTipOptions).openTooltip();
        }
        return this;
    },

    addCloseIcon:function (latlng) {
        var self = this;
        if(this.options.closeBtn){
            if (!this._closeMarker) {
                var iconUrl = LW.defaultIconPath() + this.options.iconUrl;
                this._closeMarker = new L.Marker(latlng, {zIndexOffset:99999,icon: new L.Icon({iconUrl: iconUrl, iconAnchor: L.point(30, 9)})})
                    .addTo(this._map);
                this._closeMarker.on('click',function () {
                    self.deleteShape({latlng:latlng});
                })
            } else {
                this._closeMarker.setLatLng(latlng);
            }
        }
    }

});

/**
 * 带面积、周长测量文本的多边形
 * Features :
 *
 * Update Note ：
 *      + v1.5.5 ：Created
 */
LW.MeasurePolygon = LW.LabelPolygon.extend({
    options:{
        infoClass:'lw-measure-area-info',
        closeBtn:true,
    },
    geoType:LW.GeoType.measurePolygon,

    initialize: function (latlngs, options) {
        L.Polygon.prototype.initialize.call(this, latlngs, options);
        this.measureInfo = LW.labelMarker([0,0],{iconOptions: {className: this.options.infoClass,
                edge:false,iconAnchor: new L.Point(-12,8)}});
        this.data = {latlngs:[],texts:[]};

        this._closeEvent();
    },

    onAdd: function () {
        L.Polyline.prototype.onAdd.call(this);
        this._map.addLayer(this.measureInfo);
        if (this._closeMarker && !this._map.hasLayer(this._closeMarker))
            this._map.addLayer(this._closeMarker);
    },

    onRemove: function () {
        L.Polyline.prototype.onRemove.call(this);
        this._map.removeLayer(this.measureInfo);
        if (this._closeMarker){
            this._closeMarker.off();
            this._map.removeLayer(this._closeMarker);
        }
    },

    _setData:function (latlngs){
        this.start = this.options.start;
        if (this._map) {
            this._renderer._updatePath(this);
            if(latlngs.length>2){
                var lnglats = latlngs.map(function (item){
                    return [item.lng,item.lat];
                });
                lnglats.push(lnglats[0]);
                var polygon = turf.polygon([lnglats]);
                var area = turf.area(polygon);
                area = Sun.Math.round(area/1000/1000,2);
                for(var i=0,d=0;i<latlngs.length-1;i++){
                    var p1 = latlngs[i],p2=latlngs[i+1];
                    d += p1.distanceTo(p2)/1000;
                }
                d = Sun.Math.round(d,2);
                var text = '面积：<span class="area">'+area+'</span> km² <br/>'+ '周长：<span class="side">'+d+'</span> km'
                this.measureInfo.setData(text);
                this.measureInfo.setLatLng(latlngs[latlngs.length-1]);
            }
            if(this.commited)
                this.addCloseIcon(latlngs[latlngs.length-1]);
        }
    }

});

/**
 * 几何图形
 * @module Geometry
 */

L.SVG.include({
    _updateSpline: function (layer) {
        this._setPath(layer, L.SVG.pointsToSpline(layer._parts, layer.line));
    }
});
L.extend(L.SVG, {
    pointsToSpline: function (rings, d3SvgLine) {
        var str = '';
        for (i = 0, len = rings.length; i < len; i++) {
            var points = rings[i].map(function (item) {
                return [item.x,item.y];
            });
            str += d3SvgLine(points);
        }
        return str || 'M0 0';
    }
});
/**
 * 曲线
 *
 * Features :
 *      1. 贝塞尔曲线
 *      2. 支持闭合和不闭合曲线
 *      3. 渲染器为svg
 *
 * @class LW.Spline
 * @extends L.Polygon
 */

LW.Spline = L.Polygon.extend({

    options: {
        renderer: L.svg(),
        pointerEvents: 'none',

        /**
         * 是否为闭合曲线
         * @property closed
         * @type {boolean}
         * @default true
         */
        closed: true,

        /**
         * 曲线类型
         *
         * Options :
         *      1. basis:贝塞尔曲线
         *      2. cardinal:基数样条曲线
         *      3. linear 折线
         *
         * @property lineType
         * @type {string}
         * @default 'basis'
         */
        lineType: 'basis'
    },

    line: null,

    initialize: function (latlngs, options) {
        L.setOptions(this, options);
        this.line = d3.svg.line();
        var interpolateType = this.options.lineType + (this.options.closed ? '-closed' : '');
        this.line.interpolate(interpolateType);
        this._setLatLngs(latlngs);
    },

    bezierInterpolate: function (points) {
        var r = [];
        for (var i=1; i<points.length; i++) {
            var d0 = points[i-1], d1 = points[i];
            r.push([d0[0] + (d1[0]  - d0[0] ) * 0.5, d0[1]  + (d1[1] - d0[1]) * 0.5]);
        }
        return r;
    },

    _project: function () {
        // var pxBounds = new L.Bounds();
        this._rings = '';
        this._projectLatlngs(this._latlngs, this._rings);

        //project bounds as well to use later for Canvas hit detection/etc.
        // var w = this._clickTolerance(),
        //     p = new L.Point(w, w);
        //
        // if (this._bounds.isValid() && pxBounds.isValid()) {
        //     pxBounds.min._subtract(p);
        //     pxBounds.max._add(p);
        //     this._pxBounds = pxBounds;
        // }
    },
    //recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs, result/*, projectedBounds*/) {

        var flat = latlngs[0] instanceof L.LatLng,
            len = latlngs.length,
            i, ring;

        if (flat) {
            ring = [];
            for (i = 0; i < len; i++) {
                var p = this._map.latLngToLayerPoint(latlngs[i]);
                // projectedBounds.extend(p);
                ring[i] = [p.x, p.y];
            }
            var d = this.line(ring);
            this._rings += d;
        } else {
            for (i = 0; i < len; i++) {
                this._projectLatlngs(latlngs[i], result/*, projectedBounds*/);
            }
        }
    },

    _updatePath: function () {
        // this._renderer._updateSpline(this);
        this._renderer._setPath(this, this._rings);
    },

    _updateStyle: function () {
        this._renderer._updateStyle(this);
    }
});

LW.spline = function (latlngs, options) {
    return new LW.Spline(latlngs, options);
};



/**
 * @module Geometry
 */


/**
 * 采样加密的曲线折线
 *
 * * Features :
 *      1. 贝塞尔式折线
 *      2. 支持闭合和不闭合曲线
 *
 * Update Note :
 *      + v1.5.6 : 修改曲线算法，由turf.bezier改为L.GeometryUtil.getCurvePoints
 *
 * @class LW.IntensiveSpline
 * @extends L.Polygon
 */
LW.IntensiveSpline = L.Polygon.extend({

    options:{
        weight:2,
        close:true,
        fill:false
    },

    addLatLng: function (latlng, latlngs) {
        this.s_latlngs.push(latlng);
        this.setLatLngs(this.s_latlngs);
    },

    getSLatLngs: function(){
        return this.s_latlngs;
    },

    _setLatLngs:function (latlngs) {
    //     if(latlngs.intensived)
    //         latlngs = latlngs.data;
    //     else{
    //         var result = this.s_latlngs = latlngs.map(function (item) {
    //             return L.latLng(item);
    //         });
    //         if(latlngs && latlngs.length>1){
    //             var coords = L.GeoJSON.latLngsToCoords(result, 0, this.options.close);
    //             var geoJson = L.GeoJSON.getFeature(this, {
    //                 type: this.options.close?'Polygon':'LineString',
    //                 coordinates: coords
    //             });
    //
    //             var bezier = turf.bezier(geoJson,10000,0.7);
    //             latlngs = bezier.geometry.coordinates.map(function (item) {
    //                 return L.latLng([item[1],item[0]]);
    //             });
    //         }
    //     }
    //
        L.Polygon.prototype._setLatLngs.call(this, latlngs);
        if(latlngs.length>1){
            var _latlngs = L.Polyline._flat(latlngs)? latlngs : latlngs[0];
            this.s_latlngs = _latlngs.map(function (item) {
                return L.latLng(item);
            });
        }
    },

    _convertLatLngs: function (latlngs) {
        var result = [],
            flat = L.Polyline._flat(latlngs);

        for (var i = 0, len = latlngs.length; i < len; i++) {
            if (flat) {
                result[i] = L.latLng(latlngs[i]);
                // this._bounds.extend(result[i]);
            } else {
                result[i] = this._convertLatLngs(latlngs[i]);
            }
        }

        if(flat && latlngs && latlngs.length>1){
            var coords = L.GeoJSON.latLngsToCoords(result, 0/*, this.options.close*/);
            var curvePoints = L.GeometryUtil.getCurvePoints(coords,this.options.close);
            var self = this;
            result = curvePoints.map(function (item) {
                var l = L.latLng([item[1],item[0]]);
                self._bounds.extend(l);
                return l;
            });
            // var geoJson = L.GeoJSON.getFeature(this, {
            //     type: this.options.close?'Polygon':'LineString',
            //     coordinates: coords
            // });
            //
            // var bezier = turf.bezier(geoJson,10000,0.7);
            // result = bezier.geometry.coordinates.map(function (item) {
            //     return L.latLng([item[1],item[0]]);
            // });
        }

        return result;
    },

    _updatePath: function () {
        this._renderer._updatePoly(this, this.options.close);
    }
});

LW.intensiveSpline = function (latlngs, options) {
    return new LW.IntensiveSpline(latlngs, options);
};

L.SVG.include({
    _initText: function (layer) {
        var text = layer._text = L.SVG.create('text');
        text.setAttribute('stroke',layer.options.textStroke);
        text.setAttribute('fill',layer.options.textColor);
        text.setAttribute('font-weight',layer.options.fontWeight);
        text.setAttribute('font-size',layer.options.fontSize);
        text.setAttribute('text-anchor',"middle");
        text.setAttribute('dominant-baseline',"middle");
    },

    _addText: function (layer) {
        this._rootGroup.appendChild(layer._text);
    },

    _removeText: function (layer) {
        L.DomUtil.remove(layer._text);
    },

    _updateText: function (layer, pos, text) {
        layer._text.setAttribute('x', pos.x);
        layer._text.setAttribute('y', pos.y);
        text = text.toString();
        if(text.indexOf('\n') == -1)
            layer._text.textContent = text;
        else{
            var texts = text.split('\n');
            var html = '',h = parseFloat(layer.options.fontSize)+4;
            texts.forEach(function (t,idx){
                html+='<tspan x="{1}" dy="{2}">{0}</tspan>'.format(t,pos.x,idx*h)
            })
            layer._text.innerHTML = html;
        }
    },
});

/**
 * 采样加密的贝塞尔式等值线(带文本的线)
 *
 * * Features :
 *      1. 线的类型与LW.IntensiveSpline一致，多了value文本展示
 *      2. 文本位置可在初始点或折线的中心
 * Update Note：
 *      + v1.4.5 : 增加文本在初始点或折线的中心的配置
 *      + v1.5.5 : 1. 增加多行文本的支持，文本用'\n'换行
 *                 2. 为text新增不同的svg渲染器，为了path可以使用canvas，然后和csLayer等其他canvas同时侦听到鼠标事件
 *
 * @class LW.IntensiveIsoline
 * @extends LW.IntensiveSpline
 */
LW.IntensiveIsoline = LW.IntensiveSpline.extend({
    options:{
        textColor:'#333',
        fontSize:16,
        fontWeight:'bold',
        textStroke:'none',
        textPosition: 'first', // first/center
        textOffset: L.point(0,0),
        textRenderer:L.svg({pane:'markerPane'})
    },

    value:0,

    initialize: function (latlngs, options,value,textLatLngs) {
        L.setOptions(this, options);
        this._setLatLngs(latlngs);
        this.value = value || '';
        this.textLatLngs = textLatLngs;
        if(textLatLngs)
            this.texts = L.layerGroup();
    },

    onAdd: function () {
        this._map.addLayer(this.options.textRenderer);
        this.options.textRenderer._initText(this);
        LW.IntensiveSpline.prototype.onAdd.call(this);

        if(this.texts){
            if(!this._map.hasLayer(this.texts))
                this.texts.addTo(this._map);
        }
        else
            this.options.textRenderer._addText(this);
    },

    onRemove: function () {
        if(this.texts){
            if(this._map.hasLayer(this.texts))
                this._map.removeLayer(this.texts);
        }
        else
            this.options.textRenderer._removeText(this);
        this._map.removeLayer(this.options.textRenderer);
        LW.IntensiveSpline.prototype.onRemove.call(this);
    },

    _update: function () {
        if (!this._map) { return; }
        LW.IntensiveSpline.prototype._update.call(this);
        this._updateText();
    },

    _updateText:function () {
        var textLatLngs = this.textLatLngs,options = this.options;
        if(textLatLngs){
            this.texts.clearLayers();
            if(textLatLngs.length>0){
                for(var i=0;i<textLatLngs.length;i++){
                    var l = textLatLngs[i];
                    LW.labelMarker(l,{interactive:false,iconOptions:{fontSize: options.fontSize+'px'}})
                        .setData(this.value).addTo(this.texts);
                }
            }
            else
                LW.labelMarker(this.getLatLngs()[0][0],{interactive:false,iconOptions:{fontSize: options.fontSize+'px'}})
                    .setData(this.value).addTo(this.texts);
        }
        else{// 只在单个位置展示值
            var latlng = this.options.textPosition=='first'?this.getLatLngs()[0][0]:this.getCenter();
            if(latlng instanceof L.LatLng){
                var textPos = this._map.latLngToLayerPoint(latlng);
                textPos = textPos.add(this.options.textOffset);
                this.options.textRenderer._updateText(this,textPos,this.value);
            }
        }
    },

    setValue:function (value,textLatLngs) {
        this.value = value;
        if(textLatLngs)
            this.textLatLngs = textLatLngs;
        this._updateText();
    }
});

LW.intensiveIsoline = function (latlngs, options,value,textLatLngs) {
    return new LW.IntensiveIsoline(latlngs, options,value,textLatLngs);
};

LW.IntensiveLabelLine = LW.IntensiveIsoline.extend({
    options:{
        textColor:'#333',
        fontSize:16,
        fontWeight:'800',
        textStroke:'#fff',
        textPosition: 'center', // first/center
        textOffset: L.point(0,0),
        iconsOptions:[]
    },
    onAdd: function () {
        this._map.addLayer(this.options.textRenderer);
        this.options.textRenderer._initText(this);
        LW.IntensiveSpline.prototype.onAdd.call(this);
        this.options.textRenderer._addText(this);
        if(this.markers){
            var map = this._map;
            this.markers.forEach(function (m) {
                if(!map.hasLayer(m))
                    m.addTo(map);
            })
        }
    },

    onRemove: function () {
        this.options.textRenderer._removeText(this);
        if(this.marker && this._map.hasLayer(this.marker))
            this._map.removeLayer(this.marker);
        if(this.markers){
            var map = this._map;
            this.markers.forEach(function (m) {
                if(map.hasLayer(m))
                    map.removeLayer(m);
            })
        }
        this._map.removeLayer(this.options.textRenderer);
        LW.IntensiveSpline.prototype.onRemove.call(this);
    },
    _update: function () {
        if (!this._map) { return; }
        LW.IntensiveSpline.prototype._update.call(this);
        this._updateText();
        this._updateIcon();
    },
    _updateIcon:function (resetIcons) {
        var latlng = this.getCenter();
        if(latlng instanceof L.LatLng){
            if(!this.markers){
                var markers = this.markers = [];
                this.options.iconOptions.forEach(function (iOpts) {
                    markers.push(L.marker(latlng,{interactive:false,icon: L.icon(iOpts)}));
                })
            }
            else if(resetIcons){
                var iconOptions = this.options.iconOptions;
                this.markers.forEach(function (m,i) {
                    m.setIcon(L.icon(iconOptions[i]))
                })
            }
            else{
                this.markers.forEach(function (m) {
                    m.setLatLng(latlng);
                })
            }
        }
    },

    setIcons:function (iconOptions) {
        this.options.iconOptions = iconOptions;
        this._updateIcon(true);
    }

});

LW.intensiveLabelLine = function (latlngs, options,value) {
    return new LW.IntensiveLabelLine(latlngs, options,value);
};

LW.TextPathSVG= LW.ClipPathSvg.extend({
    options:{
        interactive:false,
        // null | middle
        baseline:null,
        // null | number | 百分比
        startOffset:null
    },

    _initContainer: function () {
        LW.ClipPathSvg.prototype._initContainer.call(this);

        if(this.options.interactive){
            var me = this;
            L.DomEvent.on(this._rootGroup,'click',function (e) {
                var textPath = e.path[1];
                if(textPath){
                    var id = textPath.getAttribute('parentleafletid');
                    me._layers[id].fire('click',e,true);
                }
            });
        }
    },

    _initPath: function (layer) {
        // element
        var path = layer._path = L.SVG.create('path');
        layer._use = L.SVG.create('use');
        layer._text = L.SVG.create('text');
        if(this.options.baseline)
            layer._text.setAttribute('dominant-baseline',this.options.baseline);
        layer._textPath = L.SVG.create('textPath');

        // set id and links
        var pathId = 'pathId'+L.stamp(layer._path);
        layer._path.setAttribute('id',pathId);
        layer._use.setAttribute('xlink:href','#'+pathId);
        layer._textPath.setAttribute('xlink:href','#'+pathId);
        layer._textPath.setAttribute('parentleafletid',layer._leaflet_id);
        if(this.options.startOffset)
            layer._textPath.setAttribute('startOffset',this.options.startOffset);

        // @namespace Path
        // @option className: String = null
        // Custom class name set on an element. Only for SVG renderer.
        if (layer.options.className) {
            L.DomUtil.addClass(path, layer.options.className);
        }

        if (layer.options.interactive) {
            // L.DomUtil.addClass(path, 'leaflet-interactive');
            L.DomUtil.addClass(layer._text, 'leaflet-interactive');
        }

        this._updateStyle(layer);
        this._layers[L.stamp(layer)] = layer;
    },

    _addPath: function (layer) {
        // defs path
        this.defs.appendChild(layer._path);

        // show path
        this._rootGroup.appendChild(layer._use);

        // text
        this._rootGroup.appendChild(layer._text);
        layer._text.appendChild(layer._textPath);

        // Tip:节点添加(appendChild)后Html标签正常但是渲染不正常，重新赋值html后才能正常显示
        layer._use.outerHTML = layer._use.outerHTML;
        layer._text.outerHTML = layer._text.outerHTML;

        layer.addInteractiveTarget(layer._path);
    },

    _setPath: function (layer, path, text, gap, rotate) {
        layer._path.setAttribute('d', path);

        this._distance = 0;
        this._setPathDistance(layer.getLatLngs());
        L.DomUtil.empty(layer._textPath);
        while (this._distance>0){
            var tspan = L.SVG.create('tspan');
            layer._textPath.appendChild(tspan);
            tspan.innerHTML = text;
            if(Sun.Util.Common.isValid(rotate))
                tspan.setAttribute('rotate',rotate);
            for(var i=0;i<gap;i++){
                var _tspan = L.SVG.create('tspan');
                _tspan.setAttribute('stroke','none');
                _tspan.setAttribute('fill','none');
                layer._textPath.appendChild(_tspan);
                _tspan.innerHTML = '_';
            }
            this._distance -= 5*(gap+1);
        }
        // Tip: 因_rootGroup中的节点不是正常append的来，而是HTML赋值来的，所以当其中内容要更变时必须找到对应的节点来更新
        var textNode = this._getTextNode('#pathId'+layer._path._leaflet_id);
        if(textNode)
            textNode.outerHTML = layer._text.outerHTML;
    },

    _getTextNode :function (xlink) {
        var nodes = this._rootGroup.childNodes;
        for(var i=0;i<nodes.length;i++){
            var node = nodes[i];
            if(node.nodeName == 'text'){
                var textPath = node.firstChild;
                if(xlink == textPath.getAttribute("xlink:href"))
                    return node;
            }
        }
    },

    _setPathDistance:function (latlngs) {
        var p0;
        for(var i=0;i<latlngs.length;i++){
            var latlng = latlngs[i];
            if(latlng && 'lat' in latlng){
                if(p0){
                    var p1 = this._map.latLngToContainerPoint(latlng);
                    this._distance += p0.distanceTo(p1);
                }
                p0=this._map.latLngToContainerPoint(latlng);
            }
            else if(L.Util.isArray(latlng))
                this._setPathDistance(latlng);
        }
    },

    _removePath: function (layer) {
        L.DomUtil.remove(layer._path);

        // 刪除use 和 text
        var xlink = '#pathId'+layer._path._leaflet_id;
        var deleteNodes=[];
        this._rootGroup.childNodes.forEach(function (node) {
            if(node.nodeName == 'text'){
                var textPath = node.firstChild;
                if(xlink == textPath.getAttribute("xlink:href"))
                    deleteNodes.push(node);
            }
            else if(xlink == node.getAttribute("xlink:href"))
                deleteNodes.push(node);
        });
        deleteNodes.forEach(function (node) {
            L.DomUtil.remove(node);
        });

        layer.removeInteractiveTarget(layer._path);
        delete this._layers[L.stamp(layer)];
    },

    _updateStyle: function (layer) {
        var path = layer._path,
            text = layer._text,
            options = layer.options;

        if (!path) { return; }

        if (options.stroke) {
            path.setAttribute('stroke', options.color);
            path.setAttribute('stroke-opacity', options.opacity);
            path.setAttribute('stroke-width', options.weight);
            path.setAttribute('stroke-linecap', options.lineCap);
            path.setAttribute('stroke-linejoin', options.lineJoin);

            text.setAttribute('font-size', '15px');
            text.setAttribute('stroke', options.color);

            if (options.dashArray) {
                path.setAttribute('stroke-dasharray', options.dashArray);
            } else {
                path.removeAttribute('stroke-dasharray');
            }

            if (options.dashOffset) {
                path.setAttribute('stroke-dashoffset', options.dashOffset);
            } else {
                path.removeAttribute('stroke-dashoffset');
            }
        } else {
            path.setAttribute('stroke', 'none');
        }

        path.setAttribute('fill', 'none');
        if(options.fill)
            text.setAttribute('fill', options.fillColor || options.color);
    }
});

LW.textPathSVG = function (options) {
    return new LW.TextPathSVG(options);
};

/**
 *
 * textPath图层
 * Features :
 *      1. 文本路径图层
 *      2. 渲染器为LW.textPathSVG()
 *      3. 继承与Spline，但是可以配置lineType:'linear'设置成折线。需要用于d3.js
 *
 * Update Note：
 *      + v1.4.0 ：Created
 *      + v1.5.5 ：增加pathText属性，优先于textType；LW.TextPathSVG增加baseline和startOffset配置
 *
 * @class LW.TextPathLine
 * @extends LW.Spline
 *
 */

LW.TextPathLine = LW.Spline.extend({
    options: {
        renderer: LW.textPathSVG(),
        pointerEvents: 'none',

        /**
         * 锋面类型
         *
         * Options :
         *      1. line:─
         *      2. triangle:▲
         *      3. arch:◖
         *      4. vline: l
         *
         * @property textType
         * @type {string}
         * @default 'line'
         */
        textType: 'line',

        /**
         * 路径文本,如果有设置pathText则用该值，如果没有，可以用textType对应的值
         * @property pathText
         * @type {null|string}
         * @default null
         */
        pathText:null,

        textRotate:0,

        /**
         * 锋面图标之间的间隔
         *
         * @property gap
         * @type {int}
         * @default 0
         */
        gap: 0,
        closed: false
    },

    pathTexts:{triangle:'▲',arch:'◖',line:'─',vline:' l '},

    initialize: function (latlngs, options) {
        LW.Spline.prototype.initialize.call(this, latlngs, options);
        this._pathText = this.options.pathText || this.pathTexts[this.options.textType];
    },

    _updatePath: function () {
        this._renderer._setPath(this, this._rings, this._pathText, this.options.gap, this.options.textRotate);
    }

});

LW.textPathLine = function (latlngs,options) {
    return new LW.TextPathLine(latlngs,options);
};


L.SVG.include({
    _updateQuadCircle: function (layer) {
        console.log('QuadCircle暂未支持svg器');
    }
});
L.Canvas.include({
    _updateQuadCircle: function (layer) {
        if (!this._drawing || layer._empty()) { return; }

        var p = layer._point,
            ctx = this._ctx,
            r = layer._radius,
            s = 1;

        this._drawnLayers[layer._leaflet_id] = layer;

        if (s !== 1) {
            ctx.save();
            ctx.scale(1, s);
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y / s, r.SE, 0, Math.PI * 0.5, false);
        ctx.arc(p.x, p.y / s, r.SW, Math.PI * 0.5, Math.PI, false);
        ctx.arc(p.x, p.y / s, r.NW, Math.PI, Math.PI * 1.5, false);
        ctx.arc(p.x, p.y / s, r.NE, Math.PI * 1.5, Math.PI * 2, false);
        ctx.arc(p.x, p.y / s, r.SE, 0, 0, false);

        if (s !== 1) {
            ctx.restore();
        }

        this._fillStroke(ctx, layer);
    },
});

/**
 * 四象限风圈
 *
 * Features :
 *      1. 东南、西南、东北、西北四个现象不同半径的风圈
 *      2. 暂只支持L.canvas作为renderer
 *
 * Update Note：
 *      + v1.3.0-dev ：Created
 *
 * @class LW.QuadCircle
 * @extends L.Circle
 * @demo demo/geometry/quadWindCircle.html
 */
LW.QuadCircle = L.Circle.extend({
    options:{
        radius:{NE:0,NW:0,SE:0,SW:0},
        renderer:L.canvas()
    },
    initialize: function (latlng, options, legacyOptions) {
        if (typeof options === 'number') {
            // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
            options = L.extend({}, legacyOptions, {radius: options});
        }
        L.setOptions(this, options);
        this._latlng = L.latLng(latlng);

        this.setRadius(this.options.radius);
    },

    setRadius: function (radius) {
        this._mRadius = radius;
        this._maxRadius = Math.max(radius.NE,radius.NW,radius.SE,radius.SW);
        return this.redraw();
    },

    getBounds: function () {
        var half = [this._maxRadius, this._maxRadius];

        return new L.LatLngBounds(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half)));
    },
    _updateBounds: function () {
        var r = this._maxRadius,
            r2 = this._maxRadius,
            w = this._clickTolerance(),
            p = [r + w, r2 + w];
        this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
    },

    _project: function () {
        var lng = this._latlng.lng,
            lat = this._latlng.lat,
            map = this._map,
            crs = map.options.crs;
        this._radius = {};

        if(isNaN(this._maxRadius))//Tip:如果radius中有一个半径是NaN，则不绘制风圈半径
            return;

        for(var key in this._mRadius){
            if (crs.distance === L.CRS.Earth.distance) {
                var d = Math.PI / 180,
                    latR = (this._mRadius[key] / L.CRS.Earth.R) / d,
                    top = map.project([lat + latR, lng]),
                    bottom = map.project([lat - latR, lng]),
                    p = top.add(bottom).divideBy(2),
                    lat2 = map.unproject(p).lat,
                    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
                        (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

                if (isNaN(lngR) || lngR === 0) {
                    lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
                }

                this._point = p.subtract(map.getPixelOrigin());
                this._radius[key] = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);

            } else {
                var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

                this._point = map.latLngToLayerPoint(this._latlng);
                this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
            }
        }

        this._updateBounds();
    },

    _updatePath: function () {
        this._renderer._updateQuadCircle(this);
    },
});
/**
 * @class LW.QuadCircle
 * @constructor
 * @param latlng {L.LatLng} 经纬度
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.QuadCircle}
 */
LW.quadCircle = function (latlng,options) {
    return new LW.QuadCircle(latlng,options);
};

/**
 * @module Geometry
 */
L.SVG.include ({
    _updateEllipse: function (layer) {
        var c = layer._point,
            rx = layer._radiusX,
            ry = layer._radiusY,
            phi = layer._tiltDeg,
            endPoint = layer._endPointParams;

        var d = 'M' + endPoint.x0 + ',' + endPoint.y0 +
            'A' + rx + ',' + ry + ',' + phi + ',' +
            endPoint.largeArc + ',' + endPoint.sweep + ',' +
            endPoint.x1 + ',' + endPoint.y1 + ' z';
        this._setPath(layer, d);
    }
});

L.Canvas.include ({
    _updateEllipse: function (layer) {
        if (layer._empty()) { return; }

        var p = layer._point,
            ctx = this._ctx,
            r = layer._radiusX,
            s = (layer._radiusY || r) / r;

        this._drawnLayers[layer._leaflet_id] = layer;

        ctx.save();

        ctx.translate(p.x, p.y);
        if (layer._tilt !== 0) {
            ctx.rotate( layer._tilt );
        }
        if (s !== 1) {
            ctx.scale(1, s);
        }

        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.restore();

        this._fillStroke(ctx, layer);
    },
});
/**
 * 椭圆形
 *
 * Features :
 *
 * Update Note：
 *      + v1.3.0-dev ：Created
 *
 * @class LW.Ellipse
 * @extends L.Path
 * @demo demo/geometry/ellipse.html
 */
LW.Ellipse = L.Path.extend({

    options: {
        fill: true,
        startAngle: 0,
        endAngle: 359.9
    },

    initialize: function (latlng, radii, tilt, options) {

        L.setOptions(this, options);
        this._latlng = L.latLng(latlng);

        if (tilt) {
            this._tiltDeg = tilt;
        } else {
            this._tiltDeg = 0;
        }

        if (radii) {
            this._mRadiusX = radii[0];
            this._mRadiusY = radii[1];
        }
    },

    setRadius: function (radii) {
        this._mRadiusX = radii[0];
        this._mRadiusY = radii[1];
        return this.redraw();
    },

    getRadius: function () {
        return new L.point(this._mRadiusX, this._mRadiusY);
    },

    setTilt: function (tilt) {
        this._tiltDeg = tilt;
        return this.redraw();
    },

    getBounds: function () {
        // TODO respect tilt (bounds are too big)
        var lngRadius = this._getLngRadius(),
            latRadius = this._getLatRadius(),
            latlng = this._latlng;

        return new L.LatLngBounds(
            [latlng.lat - latRadius, latlng.lng - lngRadius],
            [latlng.lat + latRadius, latlng.lng + lngRadius]);
    },

    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function (latlng) {
        this._latlng = L.latLng(latlng);
        this.redraw();
        return this.fire('move', {latlng: this._latlng});
    },

    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function () {
        return this._latlng;
    },

    setStyle: L.Path.prototype.setStyle,

    _project: function () {
        var lngRadius = this._getLngRadius(),
            latRadius = this._getLatRadius(),
            latlng = this._latlng,
            pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]),
            pointBelow = this._map.latLngToLayerPoint([latlng.lat - latRadius, latlng.lng]);

        this._point = this._map.latLngToLayerPoint(latlng);
        this._radiusX = Math.max(this._point.x - pointLeft.x, 1);
        this._radiusY = Math.max(pointBelow.y - this._point.y, 1);
        this._tilt = Math.PI * this._tiltDeg / 180;
        this._endPointParams = this._centerPointToEndPoint();
        this._updateBounds();
    },

    _updateBounds: function () {
        // http://math.stackexchange.com/questions/91132/how-to-get-the-limits-of-rotated-ellipse
        var sin = Math.sin(this._tilt);
        var cos = Math.cos(this._tilt);
        var sinSquare = sin * sin;
        var cosSquare = cos * cos;
        var aSquare = this._radiusX * this._radiusX;
        var bSquare = this._radiusY * this._radiusY;
        var halfWidth = Math.sqrt(aSquare*cosSquare+bSquare*sinSquare);
        var halfHeight = Math.sqrt(aSquare*sinSquare+bSquare*cosSquare);
        var w = this._clickTolerance();
        var p = [halfWidth + w, halfHeight + w];
        this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
    },

    _update: function () {
        if (this._map) {
            this._updatePath();
        }
    },

    _updatePath: function () {
        this._renderer._updateEllipse(this);
    },

    _getLatRadius: function () {
        return (this._mRadiusY / 40075017) * 360;
    },

    _getLngRadius: function () {
        return ((this._mRadiusX / 40075017) * 360) / Math.cos((Math.PI / 180) * this._latlng.lat);
    },

    _centerPointToEndPoint: function () {
        var c = this._point,
            rx = this._radiusX,
            ry = this._radiusY,
            theta2 = (this.options.startAngle + this.options.endAngle) * (Math.PI / 180),
            theta1 = this.options.startAngle * (Math.PI / 180),
            delta = this.options.endAngle,
            phi = this._tiltDeg * (Math.PI / 180);

        // Determine start and end-point coordinates
        var x0 = c.x + Math.cos(phi) * rx * Math.cos(theta1) +
            Math.sin(-phi) * ry * Math.sin(theta1);
        var y0 = c.y + Math.sin(phi) * rx * Math.cos(theta1) +
            Math.cos(phi) * ry * Math.sin(theta1);

        var x1 = c.x + Math.cos(phi) * rx * Math.cos(theta2) +
            Math.sin(-phi) * ry * Math.sin(theta2);
        var y1 = c.y + Math.sin(phi) * rx * Math.cos(theta2) +
            Math.cos(phi) * ry * Math.sin(theta2);

        var largeArc = (delta > 180) ? 1 : 0;
        var sweep = (delta > 0) ? 1 : 0;

        return {'x0': x0, 'y0': y0, 'tilt': phi, 'largeArc': largeArc,
            'sweep': sweep, 'x1': x1, 'y1': y1};
    },

    _empty: function () {
        return this._radiusX && this._radiusY && !this._renderer._bounds.intersects(this._pxBounds);
    },

    _containsPoint : function (p) {
        var sin = Math.sin(this._tilt);
        var cos = Math.cos(this._tilt);
        var dx = p.x - this._point.x;
        var dy = p.y - this._point.y;
        var sumA = cos * dx + sin * dy;
        var sumB = sin * dx - cos * dy;
        return sumA * sumA / (this._radiusX * this._radiusX)  + sumB * sumB / (this._radiusY * this._radiusY) <= 1;
    }
});
/**
 * @class LW.Ellipse
 * @constructor
 * @param latlng {L.LatLng} 经纬度
 * @param radii {Array} 半径
 * @param tilt {number} 倾斜角度
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.Ellipse}
 */
LW.ellipse = function (latlng, radii, tilt, options) {
    return new LW.Ellipse(latlng, radii, tilt, options);
};

(function(){
    var labelInclude = {
        options:{
            /**
             * 文本颜色
             * @property textColor
             * @type {string}
             * @default '#333'
             */
            textColor:'#333',
            /**
             * 文本字号
             * @property fontSize
             * @type {number}
             * @default 16
             */
            fontSize:16,
            /**
             * 文本加粗
             * @property fontWeight
             * @type {string}
             * @default 'bold'
             */
            fontWeight:'bold',
            /**
             * 文本描边
             * @property textStroke
             * @type {string}
             * @default 'none'
             */
            textStroke:'none',
            /**
             * 文本偏移量
             * @property textOffset
             * @type {L.Point}
             * @default L.point(0,0)
             */
            textOffset: L.point(0,0)
        },

        onAdd: function () {
            this._renderer._initText(this);
            L.Path.prototype.onAdd.call(this);
            this._renderer._addText(this);
        },

        onRemove: function () {
            this._renderer._removeText(this);
            L.Path.prototype.onRemove.call(this);
        },

        _updateText:function () {
            var latlng = this.getCenter();
            if(latlng instanceof L.LatLng){
                var textPos = this._map.latLngToLayerPoint(latlng);
                textPos = textPos.add(this.options.textOffset);
                this._renderer._updateText(this,textPos,this.value);
            }
        },

        setValue:function (value) {
            this.value = value;
            this._updateText();
        }
    };


    /**
     * 带标注的矩形
     *
     * Features :
     *      1. 带标注的矩形
     *
     * Update Note：
     *      + v1.5.2 ：Created
     *
     * @class LW.LabelRect
     * @extends L.Rectangle
     * @demo demo/geometry/labelGeometry.html  {带文本的几何体}
     */
    LW.LabelRect = L.Rectangle.extend(L.extend({}, labelInclude, {
        initialize: function (latLngBounds, options,value) {
            L.Rectangle.prototype.initialize.call(this, latLngBounds, options);
            this.value = value || '';
        },

        _update: function () {
            if (!this._map) { return; }
            L.Rectangle.prototype._update.call(this);
            this._updateText();
        },
    }));

    /**
     * @class LW.LabelRect
     * @constructor
     * @param latLngBounds {L.LatLngBounds}
     * @param options {object} 外部属性，可重设Properties
     * @param value {string}
     * @returns {LW.LabelRect}
     */
    LW.labelRect = function (latLngBounds, options, value) {
        return new LW.LabelRect(latLngBounds, options, value);
    };


    /**
     * 带标注的圆形
     *
     * Features :
     *      1. 带标注的圆形
     *
     * Update Note：
     *      + v1.5.2 ：Created
     *
     * @class LW.LabelCircle
     * @extends L.Circle
     * @demo demo/geometry/labelGeometry.html  {带文本的几何体}
     */
    LW.LabelCircle = L.Circle.extend(L.extend({}, labelInclude, {
        initialize: function (latlng, options,value) {
            L.Circle.prototype.initialize.call(this, latlng, options);
            this.value = value || '';
        },

        _update: function () {
            if (!this._map) { return; }
            L.Circle.prototype._update.call(this);
            this._updateText();
        },

        getCenter: function () {
            return this._latlng;
        }
    }));

    /**
     * @class LW.LabelCircle
     * @constructor
     * @param latlng {L.LatLng}
     * @param options {object} 外部属性，可重设Properties
     * @param value {string}
     * @returns {LW.LabelCircle}
     */
    LW.labelCircle = function (latlng, options, value) {
        return new LW.LabelCircle(latlng, options, value);
    };

})();

L.Polyline.include({
    //micaps 11类数据的箭头绘制
    arrowheads: function (options) {
        options = options || {};
        var defaults = {
            yawn: 60,
            size: '15%',
            frequency: 'allvertices',
            proportionalToTotal: false
        };
        this.options.noClip = true;
        var actualOptions = Object.assign({}, defaults, options);
        this._arrowheadOptions = actualOptions;
        this._hatsApplied = true;
        return this;
    },
    buildVectorHats: function (options) {
        if (this._arrowheads) {
            this._arrowheads.remove();
        }

        var defaultOptionsOfParent = Object.getPrototypeOf(Object.getPrototypeOf(this.options));
        var parentOptions = Object.assign({}, defaultOptionsOfParent, this.options);
        var hatOptions = Object.assign({}, parentOptions, options);
        hatOptions.smoothFactor = 1;
        hatOptions.fillOpacity = 1;
        hatOptions.fill = options.fill ? true : false;
        hatOptions.interactive = false;
        var size = options.size.toString(); // stringify if its a number

        var allhats = []; // empty array to receive hat polylines

        var frequency = options.frequency;
        var self = this;

        this._parts.forEach(function (peice, index) {
            var latlngs = peice.map(function (point) {
                return self._map.layerPointToLatLng(point);
            });

            var totalLength = function () {
                var total = 0;

                for (var i = 0; i < peice.length - 1; i++) {
                    total += self._map.distance(latlngs[i], latlngs[i + 1]);
                }

                return total;
            }();

            var derivedLatLngs;
            var derivedBearings;
            var spacing;
            var noOfPoints;

            if (!isNaN(frequency)) {
                spacing = 1 / frequency;
                noOfPoints = frequency;
            } else if (frequency.toString().slice(frequency.toString().length - 1, frequency.toString().length) === '%') {
                console.log('Error: arrowhead frequency option cannot be given in percent.  Try another unit.');
            } else if (frequency.toString().slice(frequency.toString().length - 1, frequency.toString().length) === 'm') {
                spacing = frequency.slice(0, frequency.length - 1) / totalLength;
                noOfPoints = 1 / spacing; // round things out for more even spacing:

                noOfPoints = Math.floor(noOfPoints);
                spacing = 1 / noOfPoints;
            } else if (frequency.toString().slice(frequency.toString().length - 2, frequency.toString().length) === 'px') {
                spacing = function () {
                    var chosenFrequency = frequency.slice(0, frequency.length - 2);

                    var refPoint1 = this._map.getCenter();

                    var xy1 = this._map.latLngToLayerPoint(refPoint1);

                    var xy2 = {
                        x: xy1.x + Number(chosenFrequency),
                        y: xy1.y
                    };

                    var refPoint2 = this._map.layerPointToLatLng(xy2);

                    var derivedMeters = this._map.distance(refPoint1, refPoint2);

                    return derivedMeters / totalLength;
                }();

                noOfPoints = 1 / spacing;
                noOfPoints = Math.floor(noOfPoints);
                spacing = 1 / noOfPoints;
            }

            if (options.frequency === 'allvertices') {
                derivedBearings = function () {
                    var bearings = [];

                    for (var i = 1; i < latlngs.length; i++) {
                        var bearing = L.GeometryUtil.angle(this._map, latlngs[modulus(i - 1, latlngs.length)], latlngs[i]) + 180;
                        bearings.push(bearing);
                    }

                    return bearings;
                }();

                derivedLatLngs = latlngs;
                derivedLatLngs.shift();
            } else if (options.frequency === 'endonly') {
                derivedLatLngs = [latlngs[latlngs.length - 1]];
                derivedBearings = [L.GeometryUtil.angle(self._map, latlngs[latlngs.length - 2], latlngs[latlngs.length - 1]) + 180];
            } else {
                derivedLatLngs = [];
                var interpolatedPoints = [];

                for (var i = 0; i < noOfPoints; i++) {
                    var interpolatedPoint = L.GeometryUtil.interpolateOnLine(self._map, latlngs, spacing * (i + 1));
                    interpolatedPoints.push(interpolatedPoint);
                    derivedLatLngs.push(interpolatedPoint.latLng);
                }

                derivedBearings = function () {
                    var bearings = [];

                    for (var i = 0; i < interpolatedPoints.length; i++) {
                        var bearing = L.GeometryUtil.angle(this._map, interpolatedPoints[i].latLng, latlngs[interpolatedPoints[i].predecessor]);
                        bearings.push(bearing);
                    }

                    return bearings;
                }();
            }

            var n = latlngs.length - 1;
            var hats = [];

            var pushHats = function pushHats(size) {
                var leftWingPoint = L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] - options.yawn / 2, size);
                var rightWingPoint = L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] + options.yawn / 2, size);
                var hatPoints = [[leftWingPoint.lat, leftWingPoint.lng], [derivedLatLngs[i].lat, derivedLatLngs[i].lng], [rightWingPoint.lat, rightWingPoint.lng]];
                var hat = options.fill ? L.polygon(hatPoints, hatOptions) : L.polyline(hatPoints, hatOptions);
                hats.push(hat);
            }; // pushHats()


            var pushHatsFromPixels = function pushHatsFromPixels(size) {
                var sizePixels = size.slice(0, size.length - 2);

                var derivedXY = self._map.latLngToLayerPoint(derivedLatLngs[i]);

                var bearing = derivedBearings[i];
                var thetaLeft = (180 - bearing - options.yawn / 2) * (Math.PI / 180),
                    thetaRight = (180 - bearing + options.yawn / 2) * (Math.PI / 180);
                var dxLeft = sizePixels * Math.sin(thetaLeft),
                    dyLeft = sizePixels * Math.cos(thetaLeft),
                    dxRight = sizePixels * Math.sin(thetaRight),
                    dyRight = sizePixels * Math.cos(thetaRight);
                var leftWingXY = {
                    x: derivedXY.x + dxLeft,
                    y: derivedXY.y + dyLeft
                };
                var rightWingXY = {
                    x: derivedXY.x + dxRight,
                    y: derivedXY.y + dyRight
                };

                var leftWingPoint = self._map.layerPointToLatLng(leftWingXY),
                    rightWingPoint = self._map.layerPointToLatLng(rightWingXY);

                var hatPoints = [[leftWingPoint.lat, leftWingPoint.lng], [derivedLatLngs[i].lat, derivedLatLngs[i].lng], [rightWingPoint.lat, rightWingPoint.lng]];
                var hat = options.fill ? L.polygon(hatPoints, hatOptions) : L.polyline(hatPoints, hatOptions);
                hats.push(hat);
            }; // pushHatsFromPixels()


            for (var i = 0; i < derivedLatLngs.length; i++) {
                if (size.slice(size.length - 1, size.length) === 'm') {
                    var hatSize = size.slice(0, size.length - 1);
                    pushHats(hatSize);
                } else if (size.slice(size.length - 1, size.length) === '%') {
                    var sizePercent = size.slice(0, size.length - 1);

                    var hatSize = function () {
                        if (options.frequency === 'endonly' && options.proportionalToTotal) {
                            return totalLength * sizePercent / 100;
                        } else {
                            var averageDistance = totalLength / (peice.length - 1);
                            return averageDistance * sizePercent / 100;
                        }
                    }(); // hatsize calculation


                    pushHats(hatSize);
                } else if (size.slice(size.length - 2, size.length) === 'px') {
                    pushHatsFromPixels(options.size);
                } else {
                    console.log('Error: Arrowhead size unit not defined.  Check your arrowhead options.');
                } // if else block for Size

            } // for loop for each point witin a peice


            hats.forEach(function (item) {
                allhats.push(item);
            }); // allhats.push(...hats);
        }); // forEach peice


        var arrowheads = L.layerGroup(allhats);
        this._arrowheads = arrowheads;
        return this;

        function modulus(i, n) {
            return (i % n + n) % n;
        }
    },
    getArrowheads: function () {
        if (this._arrowheads) {
            return this._arrowheads;
        } else {
            return console.log("Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'");
        }
    },
    deleteArrowheads: function () {
        if (this._arrowheads) {
            this._arrowheads.remove();

            delete this._arrowheads;
            delete this._arrowheadOptions;
            this._hatsApplied = false;
        }
    },
    addTo: function (map) {
        this._map = map;
        map.addLayer(this);

        if (this._hatsApplied) {
            this.buildVectorHats(this._arrowheadOptions);

            this._arrowheads.addTo(this._map);
        }

        return this;
    },
    _update: function () {
        if (!this._map) {
            return;
        }

        this._clipPoints();

        this._simplifyPoints();

        this._updatePath();

        if (this._hatsApplied) {
            this.buildVectorHats(this._arrowheadOptions);

            this._map.addLayer(this._arrowheads);
        }
    },
    remove: function () {
        if (this._arrowheads) {
            this._arrowheads.remove();
        }

        return this.removeFrom(this._map || this._mapToAdd);
    }
});
L.LayerGroup.include({
    removeLayer: function (layer) {
        var id = layer in this._layers ? layer : this.getLayerId(layer);

        if (this._map && this._layers[id]) {
            if (this._layers[id]._arrowheads) {
                this._layers[id]._arrowheads.remove();
            }

            this._map.removeLayer(this._layers[id]);
        }

        delete this._layers[id];
        return this;
    },
    onRemove: function (map, layer) {
        for (var layer in this._layers) {
            if (this._layers[layer]) {
                this._layers[layer].remove();
            }
        }

        this.eachLayer(map.removeLayer, map);
    }
});
L.Map.include({
    removeLayer: function (layer) {
        var id = L.Util.stamp(layer);

        if (layer._arrowheads) {
            layer._arrowheads.remove();
        }

        if (!this._layers[id]) {
            return this;
        }

        if (this._loaded) {
            layer.onRemove(this);
        }

        if (layer.getAttribution && this.attributionControl) {
            this.attributionControl.removeAttribution(layer.getAttribution());
        }

        delete this._layers[id];

        if (this._loaded) {
            this.fire('layerremove', {
                layer: layer
            });
            layer.fire('remove');
        }

        layer._map = layer._mapToAdd = null;
        return this;
    }
});


/**
 * 遮罩GeoJson
 *
 * Tips :
 *      主图层的渲染器为canvas时，以下方案需要2选1 ：
 *          1. 遮罩图层maskgeojson在主图层之前添加到地图
 *          2. new MaskGeojson的时候这个iscanvas参数改为true
 * TODO: 渲染器为svg时直接添加到<defs>中，后其他图层用到时，直接用id关联
 *
 * @class LW.maskGeoJson
 * @demo demo/geometry/geoOutMask.html  {geo外部遮罩}
 * @constructor
 * @param data geojson 数据
 * @param isCanvas 是否是canvas
 * @param options {object} 外部属性，可重设Properties
 */
LW.maskGeoJson = function (data,isCanvas,options) {
    options = options || {style: {weight: 0, color: '#000', opacity: 0, fillColor: "#000", fillOpacity: 0}};
    if(isCanvas)
        options.renderer = L.canvas({type:'mask'});
    var geo = L.geoJson(data, options);
    geo.data = data;
    return geo;
};

L.Layer.include({
    _layerAdd: function (e) {
        var map = e.target;

        // check in case layer gets added and then removed before the map is ready
        if (!map.hasLayer(this)) { return; }

        this._map = map;
        this._zoomAnimated = map._zoomAnimated;

        if (this.getEvents) {
            var events = this.getEvents();
            map.on(events, this);
            this.once('remove', function () {
                map.off(events, this);
            }, this);
        }

        this.onAdd(map);

        if (this.getAttribution && this._map.attributionControl) {
            this._map.attributionControl.addAttribution(this.getAttribution());
        }

        // Tip: 遮罩的特殊处理:事件前置,用于解决遮罩添加于被遮罩图层之后，事件响应滞后导致的遮罩位置异常的问题
        if(this.options.renderer && this.options.renderer.options.type == 'mask'){
            var _events = map._events.moveend;
            var e = _events[_events.length-1];
            if(e.ctx && e.ctx.options.type=='mask')
                _events.unshift(_events.pop());
        }

        this.fire('add');
        map.fire('layeradd', {layer: this});
    }
});

/**
 *
 * @module Layer.Plot.Contour
 */
/**
 * 色斑图模型
 *
 * Features :
 *      1. 自动站点绘制色斑图的信息模型
 *      2. 网格信息、图例信息等
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.4.0 ：增加根据经纬度获取最近网格的行列的方法，增加根据行列获取网格值的方法
 *
 *
 * @class LW.ContourModel
 * @extends L.Class
 */
LW.ContourModel = L.Class.extend({

    options:{
        /**
         * 参与插值的离散点最少数量
         * @property iPointMinNum
         * @type {int}
         * @default 3
         */
        iPointMinNum: 3,
        /**
         * 插值指数，离散点的比重的指数
         * @property pow
         * @type {int}
         * @default 5
         */
        pow: 5,
        /**
         * 查找的最大行数
         * @property seekMaxRow
         * @type {int}
         * @default 50
         */
        seekMaxRow:50,
        /**
         * 查找的最列数
         * @property seekMaxColumn
         * @type {int}
         * @default 50
         */
        seekMaxColumn:50,

        /**
         * 是否计算填色数据
         */
        fillData:true,

        method:'idw',//idw/kriging/rbf

        latField:'STATIONLAT',
        lonField:'STATIONLON',
        // 修正差值
        d_value: 0.1,
    },

    /**
     * 网格列数(越大则性能越差，但插值会更准确)
     * @property columns
     * @type {int}
     * @default 50
     */
    columns: 50,
    /**
     * 网格行数(越大则性能越差，但插值会更准确)
     * @property rows
     * @type {int}
     * @default 50
     */
    rows: 50,

    /**
     * 起止经纬构成的范围
     *
     * @property bounds
     * @type {L.LatLngBounds}
     * @default null
     */
    bounds: null,

    /**
     * 单元纬度间隔
     * @property cellLatRange
     * @type {number}
     * @default NaN
     */
    cellLatRange: NaN,

    /**
     * 单元经度间隔
     * @property cellLngRange
     * @type {number}
     * @default NaN
     */
    cellLngRange: NaN,

    /**
     * 图例数据
     * @property legendData
     * @type {Array}
     * @default null
     */
    legendData: null,

    /**
     * 等级模式（若图例数据不是等间隔，可用等级模式来平衡数值，从而平衡等值面的大小）
     *
     * eg:降水图例一般需要用等级模式
     * @property levelMode
     * @type {Boolean}
     * @default false
     */
    levelMode: false,

    /**
     * 网格模型数据
     */
    grid: [],

    initialize: function (options) {
        L.setOptions(this,options);

        // this.bounds = bounds;
        // this.columns = columns || this.columns;
        // this.rows = rows || this.rows;
        // this.legendData = legendData || this.legendData;
        //this._buildGrid();

        this.gridInterpolate = new LW.GridInterpolate(this);
        this.tracker = new LW.Tracker(this,{d_value:this.options.d_value});
        this.tinter = new LW.Tinter({editable: this.options.editable});
    },

    setGridBounds:function(bounds, rows, columns){
        this.bounds = bounds;
        this.rows = rows || this.rows;
        this.columns = columns || this.columns;
    },

    buildGrid: function () {
        // 建立初始网格
        this.setGridByData();
        // this.grid = [];
        // var rows = this.rows,
        //     columns = this.columns;
        // for (var i = 0; i < rows; i++) {
        //     for (var j = 0; j < columns; j++) {
        //         this.grid.push({gridValue: NaN, valuePoints: [], interpolatePoints: []});
        //     }
        // }

        // 计算单元经纬度间隔
        var bounds = this.bounds;
        if (Sun.Util.Common.isValid(bounds) && (bounds instanceof L.LatLngBounds)) {
            var latRange = bounds.getNorth() - bounds.getSouth();
            var lngRange = bounds.getEast() - bounds.getWest();
            this.cellLatRange = latRange / (this.rows - 1);
            this.cellLngRange = lngRange / (this.columns - 1);
        }
    },

    /**
     * 在网格最外层扩展一层图例最小值，用于跟踪时避免开曲线问题
     *
     * 外部可通过s_grid引用这个被扩展的网格数据
     * @method spreadGrid
     */
    spreadGrid: function () {
        if (!isNaN(this.minValue)) {
            var s_value = -9999;
            if(this.legendData){
                for (var m = 0; m < this.legendData.length; m++) {
                    if (this.legendData[m].min > this.minValue) {
                        var item = this.legendData[m - 1] || this.legendData[m];
                        s_value = isNaN(item.min)?s_value:item.min - 0.01;
                        break;
                    }
                }
            }

            var s_rows = this.s_rows;
            var s_columns = this.s_columns;
            for (var i = 0; i < s_rows; i++) {
                for (var j = 0; j < s_columns; j++) {
                    if(i===0 || i===s_rows-1 || j===0 || j===s_columns-1)
                        this.s_grid[i * s_columns + j].gridValue=s_value;
                }
            }
        }

        // this.s_grid = Sun.Util.Data.deepClone(this.grid);
        // this.s_grid = this.grid.concat();
        // var columns = this.columns,rows = this.rows;
        // var s = [];
        // for (var i = 0; i < columns; i++) {
        //     s.push({gridValue: s_value});
        //     // this.s_grid.unshift({gridValue: s_value});
        //     // this.s_grid.push({gridValue: s_value});
        // }
        // this.s_grid = s.concat(this.s_grid).concat(s);
        //
        // var d3 = new Date().getTime();
        // var s_rows = this.s_rows = rows + 2;
        // var s_columns = this.s_columns = columns + 2;
        // for (i = 0; i < s_rows; i++) {
        //     // TODO:splice太耗性能，需优化,优化成一开始则扩展网格
        //     this.s_grid.splice(i * s_columns, 0, {gridValue: s_value});
        //     this.s_grid.splice((i + 1) * s_columns - 1, 0, {gridValue: s_value});
        // }
        // var d4 = new Date().getTime();
        // console.log('tx：',(d4-d3)/1000+'s');
    },

    setGridByData:function (data,fixValue) {
        this.grid = [];
        this.s_grid = [];
        var s_value = -9999.01,minValue = 9999,maxValue = -9999;

        // 建立初始网格
        var rows = this.rows,
            columns = this.columns;
        var s_rows = this.s_rows = rows + 2;
        var s_columns = this.s_columns = columns + 2;
        for (var i = 0; i < s_rows; i++) {
            for (var j = 0; j < s_columns; j++) {
                var idx = i * s_columns + j;
                if(i===0 || i===s_rows-1 || j===0 || j===s_columns-1)
                    this.s_grid[idx] = {gridValue: s_value, valuePoints: [], interpolatePoints: []};
                else{
                    var value = NaN;
                    if(data){
                        value = data.data[(i-1)*columns+(j-1)];
                        if(value != data.invalidValue){
                            minValue = minValue>value ? value : minValue;
                            maxValue = maxValue<value ? value : maxValue;
                        }
                        else if(value == data.invalidValue)
                            value = fixValue || s_value;
                    }
                    var item = {gridValue: value, valuePoints: [], interpolatePoints: []};
                    this.grid.push(item);
                    this.s_grid[idx] = item;
                }
            }
        }
        this.minValue = minValue;
        this.maxValue = maxValue;
    },

    /**
     * 获取扩展网格的单元格
     * @method getCell_S
     * @param row
     * @param column
     * @returns {T|*}
     */
    getCell_S: function (row, column) {
        return this.s_grid[row * this.s_columns + column];

    },


    /**
     * 获取扩展网格的指定网格点的经纬
     * @method getCellLatLng_S
     * @param row
     * @param column
     */
    getCellLatLng_S: function (row, column) {
        return this.getCellLatLng(row - 1, column - 1);
    },

    /**
     * 获取单元格
     * @method getCell
     * @param row
     * @param column
     * @returns {*}
     */
    getCell: function (row, column) {
        return this.grid[row * this.columns + column];
    },

    /**
     * 获取指定网格点的经纬
     * @method getCellLatLng
     * @param row
     * @param column
     */
    getCellLatLng: function (row, column) {
        var bounds = this.bounds;
        return L.latLng(bounds.getSouth() + this.cellLatRange * row, bounds.getWest() + this.cellLngRange * column);
    },

    _getRankByLatlng:function (latlng) {
        var x0 = this.bounds.getWest(), y0 = this.bounds.getSouth();
        var dx = this.cellLngRange, dy = this.cellLatRange;
        var row = (latlng.lat - y0) / dy;
        var column = (latlng.lng - x0) / dx;
        return {row: row, column: column};
    },

    getClosestGridByLatlng:function (latlng) {
        if(this.bounds){
            var rank = this._getRankByLatlng(latlng);
            return {row:Math.round(rank.row),column:Math.round(rank.column)};
        }
    },

    inGrid:function (row,column) {
        return row>=0 && row<this.rows && column>=0 && column<this.columns;
    },

    /**
     * 根据所给的row，column获得指向的格点
     * @method getGrid
     * @param row {int}
     * @param column {int}
     * @returns {boolean}
     */
    getGrid:function (row,column) {
        return this.inGrid(row,column)?this.getCell(row,column).gridValue : null;
    },

    /**
     * 遍历所有格点
     * @method eachGrid
     * @param fun {Function} 回调
     * @param context {LW.GridModel} this
     */
    eachGrid:function (fun, context) {
        for(var row_i=0,i=0;row_i<context.rows;row_i++){
            for(var column_i=0;column_i<context.columns;column_i++,i++){
                fun(context,row_i,column_i,i);
            }
        }
    },

    /**
     * 获取离散点（将站点数据整合成简单的结构）
     * @param source
     * @param valueField
     * @param valueScale
     * @returns {Array}
     */
    getDiscreteData: function (source, valueField, valueScale) {
        var discreteData = [];
        var data = source.FieldName?source.Rows:source;
        var bounds = this.bounds;
        valueScale = valueScale || 1;
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            var value = Sun.Util.Data.getValueByField(item,valueField,source.FieldName);
            var lat = Sun.Util.Data.getValueByField(item,this.options.latField,source.FieldName);
            var lng = Sun.Util.Data.getValueByField(item,this.options.lonField,source.FieldName);
            if (!isNaN(value) && value != null && lat != '' && lng != '' && bounds.contains([lat,lng])) {
                var dValue = this.levelMode ? getSectionIndex(this.legendData, value) : (value * valueScale);
                var dItem = {lat: lat, lng: lng, value: dValue};
                discreteData.push(dItem);
            }
        }
        return discreteData;

        function getSectionIndex(legendData, value) {
            for (var i = 0; i < legendData.length; i++) {
                var item = legendData[i];
                if ((isNaN(item.max) || value < item.max || (item.equalMax && value == item.max))
                    && (isNaN(item.min) || value > item.min) || (item.equalMin && value == item.min))
                    return i;
            }
            return -1;
        }
    },

    /**
     * 插值
     * @param discreteData
     */
    interpolate:function (discreteData) {
        this.gridInterpolate.interpolate(discreteData);
    },

    /**
     * 获取格点值数据
     * @method getGridValueData
     * @returns {{data: Array, startlon: *, startlat: *, endlon: *, endlat: *, nlon: (number|*), nlat: (number|*), lonsize: (int|Array|*), latsize: (int|SQLResultSetRowList|Number|HTMLCollection|string)}}
     */
    getGridValueData: function () {
        var bounds = this.bounds;
        return {
            data: this.grid.map(function (item) {
                return item.gridValue
            }),
            startlon: bounds.getWest(), startlat: bounds.getSouth(),
            endlon: bounds.getEast(), endlat: bounds.getNorth(),
            nlon: this.cellLngRange, nlat: this.cellLatRange,
            lonsize: this.columns, latsize: this.rows
        };
    },

    /**
     * 获取等值线数据
     * @returns {*}
     */
    getIsolineData: function (gap) {
        return this.tracker.getIsolineData(gap);
    },

    /**
     * 获取面数据
     * @param isolineData
     * @returns {*|Array}
     */
    getPlaneData: function (isolineData) {
        return this.tinter.getPlaneData(this.legendData,isolineData);
    },

    /**
     * 用站点数据获取色斑图数据
     * @param zdzData
     * @param valueField
     * @param legendData
     * @return {*|{data: Array, startlon: *, startlat: *, endlon: *, endlat: *, nlon: (number), nlat: (number), lonsize: (int), latsize: (int)}}
     */
    getContourDataOfZdz: function (zdzData, valueField, legendData) {
        var discreteData = this.discreteData;
        if(zdzData){
            this.legendData = legendData;
            discreteData = this.discreteData = this.getDiscreteData(zdzData, valueField,this.options.valueScale);
        }

        // tip: 因离散点数量小于最小离散点数不能有效插值
        if (discreteData && discreteData.length) {
            // 如果数据量小于最小离散点数，则使用数据的数量作为最小离散点数
            var iPointMinNum = Math.min(this.options.iPointMinNum, discreteData.length);
            this.options.iPointMinNum = iPointMinNum;
            // 插值
            this.interpolate(discreteData);
            var data = this.getGridValueData();
            // 跟踪
            var isolineData = this.getIsolineData();
            data.lineitems = isolineData;
            // 填色
            if (this.options.fillData)
                data.planeitems = this.getPlaneData(isolineData);
            return data;
        }
    },

    /**
     * 获取密度数据的色斑图
     * @param pointData
     * @param gap
     * @param legendData
     * @return {*}
     */
    getContourDataOfDensity: function(pointData,gap,legendData){
        this.legendData = legendData;
        // 设置网格
        this.cellLatRange = this.cellLngRange = gap;
        var bounds = this.bounds;
        if (Sun.Util.Common.isValid(bounds) && (bounds instanceof L.LatLngBounds)) {
            var latRange = bounds.getNorth() - bounds.getSouth();
            var lngRange = bounds.getEast() - bounds.getWest();
            this.rows = Math.round(latRange / gap + 1);
            this.columns = Math.round(lngRange / gap + 1);
        }
        // 建立初始网格
        this.setGridByData();
        for(var i=0;i<pointData.length;i++){
            var item = pointData[i];
            var lat = item[this.options.latField];
            var lng = item[this.options.lonField];
            var rank = this._getRankByLatlng(L.latLng(lat,lng));
            var row = Math.ceil(rank.row),column = Math.ceil(rank.column);
            if(this.inGrid(row,column)){
                var grid = this.getCell(row,column);
                isNaN(grid.gridValue) ? grid.gridValue = 1 : grid.gridValue++;
            }
        }
        var data = this.getGridValueData();
        // 跟踪
        var isolineData = this.getIsolineData();
        data.lineitems = isolineData;
        // 填色
        data.planeitems = this.getPlaneData(isolineData);
        return data;
    },

    /**
     * 获取格点数据的色斑图数据
     * @param data
     * @param legendData {array|function} 图例数据，或根据minValue/maxValue可返回图例数据的方法
     * @return {*}
     */
    getContourDataOfGrid: function (data, legendData) {
        var bound = L.latLngBounds([data.endlat, data.startlon], [data.startlat, data.endlon]);
        this.setGridBounds(bound,data.latsize,data.lonsize);
        this.cellLatRange = data.nlat;
        this.cellLngRange = data.nlon;
        this.setGridByData(data);
        this.legendData = typeof legendData == "function" ? legendData(this.minValue,this.maxValue) : legendData;
        // 跟踪
        var isolineData = this.getIsolineData();
        data.lineitems = isolineData;
        // 填色
        if(this.options.fillData)
            data.planeitems = this.getPlaneData(isolineData);
        return data;
    },

    /**
     * 获取图表网格的色斑图数据
     * @param data
     * @param field
     * @param legendData
     * @param fill
     * @param gap
     * @return {*}
     */
    setContourDataOfChartGrid: function (data, field, legendData, fill,gap) {
        var bound = L.latLngBounds([0, 0], [data.xaxis.length-1,data.yaxis.length-1]);
        this.setGridBounds(bound,data.yaxis.length,data.xaxis.length);
        this.legendData = legendData;
        this.cellLatRange = 1;
        this.cellLngRange = 1;
        this.setGridByData(data.data[field],-9999);
        // 跟踪
        var isolineData = this.getIsolineData(gap);
        data.data[field].lineitems = isolineData;

        if(fill)// 填色
            data.data[field].planeitems = this.getPlaneData(isolineData);
        return data;
    }
});

/**
 *
 * @module Layer.Plot.Contour
 */
/**
 * 站点插值成格点数据
 *
 * Features :
 *      1. 暂只支持反距离加权法插值
 *      2. 插值后网格信息存储于contourModel中
 *
 *
 * @class LW.GridInterpolate
 * @extends L.Class
 */
LW.GridInterpolate = L.Class.extend({

    options: {
    },

    initialize: function (contourModel, options) {
        L.setOptions(this, options);
        this.contourModel = contourModel;
    },

    /**
     * 插值
     * @method interpolate
     * @param data {Array|rbus} 离散点数据 eg:[{lat:25.06,lng:112.23:value:10}]
     */
    interpolate: function (data) {
        var cModel = this.contourModel,method = cModel.options.method;

        cModel.buildGrid();// 创建网格
        var minItem = Sun.Util.Array.getMinValObject(data, 'value');
        cModel.minValue = minItem.value;// 根据离散数据，设置网格模型最小值
        var maxItem = Sun.Util.Array.getMaxValObject(data, 'value');
        cModel.maxValue = maxItem.value;// 根据离散数据，设置网格模型最小值

        if(method=='idw'){
            var d1 = new Date().getTime();
            // 填充各个网格对应的离散点
            this._fillValuePoints(data);

            // 插值
            this._IDWInterpolate();
            // var d2 = new Date().getTime();
            // console.log('插值:',(d2-d1)/1000+'s');
        }
        else if(method=='kriging'){
            var t = data.map(function(d){ return d.value; });
            var x = data.map(function(d){ return d.lng; });
            var y = data.map(function(d){ return d.lat; });
            this.variogram = this._getVariogram(t,x,y,Math.sqrt(data.length));
            // 插值
            this._KrigingInterpolate();
        }
        else if(method=='rbf'){
            var data = [];
            // 清除离散点数据中经纬度重合的点
            for(var i=0;i<data.length;i++){
                var item1 = data[i],single = true;
                for(var j=i+1;j<data.length;j++){
                    var item2 = data[j];
                    if(item1.lat==item2.lat && item1.lng==item2.lng)
                        single=false;
                }
                if(single)
                    data.push(item1);
            }
            var values = data.map(function(d){ return d.value; });
            var points = data.map(function(d){ return [d.lng,d.lat]; });
            this.rbf = RBF(points, values);
            this._RBFInterpolate();
        }
    },

    _fillValuePoints:function (discreteData) {
        var bounds = this.contourModel.bounds;
        // 填充各个网格对应的离散点
        for (var i = 0; i < discreteData.length; i++) {
            var item = discreteData[i];
            var row = parseInt((item.lat - bounds.getSouth()) / this.contourModel.cellLatRange);
            var column = parseInt((item.lng - bounds.getWest()) / this.contourModel.cellLngRange);
            if (row < 0 || column < 0 || row > this.contourModel.rows - 1 || column > this.contourModel.columns - 1)
                continue;
            var cell = this.contourModel.getCell(row, column);
            cell.valuePoints.push(item);
        }
    },

    _getVariogram:function (t,x,y,alpha) {
        var model = "exponential";
        var sigma2 = 0;
        return kriging.train(t, x, y, model,sigma2,alpha);
    },

    /**
     * 径向基函数插值
     * @private
     */
    _RBFInterpolate:function () {
        var rows = this.contourModel.rows,
            columns = this.contourModel.columns;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                var cell = this.contourModel.getCell(i, j);
                var cellLatlng = this.contourModel.getCellLatLng(i, j);
                cell.gridValue = this.rbf([cellLatlng.lng, cellLatlng.lat]);
            }
        }
    },

    /**
     * 克里金插值
     * @private
     */
    _KrigingInterpolate: function () {
        var rows = this.contourModel.rows,
            columns = this.contourModel.columns;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                var cell = this.contourModel.getCell(i, j);
                var cellLatlng = this.contourModel.getCellLatLng(i, j);
                cell.gridValue = kriging.predict(cellLatlng.lng, cellLatlng.lat, this.variogram);
            }
        }
    },

    /**
     * 反距离加权插值
     */
    _IDWInterpolate: function () {

        var d, v, w, sum_d, e = 0.000001;
        var cModel = this.contourModel;

        var rows = cModel.rows,columns = cModel.columns;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                v = 0;
                w = 0;
                sum_d = 0;
                var cell = cModel.getCell(i, j);
                var cellLatlng = cModel.getCellLatLng(i, j);

                // 查找参与插值的离散点
                this._seekIPoints(cell, i - 1, i, j - 1, j);

                var iPointNum = cell.interpolatePoints.length;
                // 权重数据
                var sgData = [];
                for (var k = 0; k < iPointNum; k++) {
                    var p = cell.interpolatePoints[k];
                    // d = cellLatlng.distanceTo(L.latLng(p.lat, p.lng));
                    d = Math.sqrt(Math.pow(cellLatlng.lat - p.lat,2)+Math.pow(cellLatlng.lng - p.lng,2));
                    if (d < e) {
                        cell.gridValue = parseFloat(p.value);
                        break;
                    }
                    else {
                        //d = Math.pow(1/d,this.options.pow);
                        //v += p.value * d;
                        //w += d;

                        var pd = Math.pow(1/d, cModel.options.pow);
                        // var pd = getPd(1/d);
                        sgData.push({d: pd, value: p.value});
                        w += pd;
                    }
                }

                if (isNaN(cell.gridValue)) {
                    var value = 0;
                    for (var s = 0; s < sgData.length; s++) {
                        var sg = sgData[s];
                        value += sg.d / w * sg.value;
                    }
                    cell.gridValue = parseFloat(Sun.Util.Math.toFixed(value, 2));
                }
                //cell.gridValue = MathUtil.toFixed(v/w, 2);

            }
        }

        function getPd(_d) {
            return _d*_d*_d*_d*_d;
        }
    },

    _seekIPoints: function (cell, startRow, endRow, startColumn, endColumn) {
        var cModel = this.contourModel;
        //行列范围设定
        startRow = startRow < 0 ? 0 : startRow;
        endRow = endRow > cModel.rows - 1 ? (cModel.rows - 1) : endRow;
        startColumn = startColumn < 0 ? 0 : startColumn;
        endColumn = endColumn > cModel.columns - 1 ? (cModel.columns - 1) : endColumn;

        var rs = endRow - startRow + 1;
        var cs = endColumn - startColumn + 1;

        // if(rs > cModel.options.seekMaxRow || cs > cModel.options.seekMaxColumn)
        //     return;
        if (rs == 1 && cs == 1 && !(startRow == 0 && endRow == 0 && startColumn == 0 && endColumn == 0))
            return;


        //小于或等于4格
        if (cs * rs <= 4) {
            for (var i = startRow; i <= endRow; i++) {
                for (var j = startColumn; j <= endColumn; j++) {
                    var iCell = cModel.getCell(i, j);
                    if (iCell.valuePoints.length > 0)
                        cell.interpolatePoints = cell.interpolatePoints.concat(iCell.valuePoints);
                }
            }
        }
        else {
            //上部
            for (i = startColumn; i <= endColumn - 1; i++) {
                iCell = cModel.getCell(startRow, i);
                if (iCell.valuePoints.length > 0)
                    cell.interpolatePoints = cell.interpolatePoints.concat(iCell.valuePoints);
            }
            //左部
            for (i = startRow + 1; i <= endRow; i++) {
                iCell = cModel.getCell(i, startColumn);
                if (iCell.valuePoints.length > 0)
                    cell.interpolatePoints = cell.interpolatePoints.concat(iCell.valuePoints);
            }
            //右部
            for (i = startRow; i <= endRow - 1; i++) {
                iCell = cModel.getCell(i, endColumn);
                if (iCell.valuePoints.length > 0)
                    cell.interpolatePoints = cell.interpolatePoints.concat(iCell.valuePoints);
            }
            //下部
            for (i = startColumn + 1; i <= endColumn; i++) {
                iCell = cModel.getCell(endRow, i);
                if (iCell.valuePoints.length > 0)
                    cell.interpolatePoints = cell.interpolatePoints.concat(iCell.valuePoints);
            }
        }

        if (cell.interpolatePoints.length < cModel.options.iPointMinNum)
            this._seekIPoints(cell, startRow - 1, endRow + 1, startColumn - 1, endColumn + 1);
        else
            return;
    }
});

/**
 *
 * @module Layer.Plot.Contour
 */
/**
 * 格点数据跟踪出等值线数据
 *
 * Features :
 *      1. 查找出所有的等值点，再遍历网格跟踪
 *      2. 跟踪出等值线信息
 *
 * @class LW.Tracker
 * @extends L.Class
 */
LW.Tracker = L.Class.extend({
    options: {
        // 修正差值
        d_value: 0.1,
    },

    // 对比精度
    precision: 0.0001,

    /**
     *
     * @param contourModel {ContourModel} 网格模型
     * @param options
     */
    initialize: function (contourModel, options) {
        L.setOptions(this, options);
        this.contourModel = contourModel;
    },

    /**
     * 获取等值线数据
     * @method getIsolineData
     * @param gap {int} 插值的间隔,如果有间隔，优先用间隔插值
     * @returns {*}
     */
    getIsolineData: function (gap) {
        // 在格点值最外层加入一层图例的最小值
        // this.contourModel.spreadGrid();

        // 寻找等值点，并填充于格点模型中
        var d1 = new Date().getTime();
        var legendData = this.contourModel.legendData;
        var cOpts = this.contourModel.options;
        var min = gap&&!isNaN(cOpts.minValue)?cOpts.minValue:this.contourModel.minValue,
            max = gap&&!isNaN(cOpts.maxValue)?cOpts.maxValue:this.contourModel.maxValue;
        var i_min,i_max;
        if(gap){
            this.clearIsoPoints();
            i_min = Math.ceil(min/gap);
            i_max = Math.floor(max/gap) + 1;
        }
        else{
            i_min = Sun.Util.LegendData.getColorIndex(legendData,min);
            i_max = Sun.Util.LegendData.getColorIndex(legendData,max);
            i_min = i_min>0 ? i_min - 1 : 0;
            i_max = i_max>0 ? i_max + 1 : legendData.length;
        }
        for (var i = i_min; i < i_max; i++) {
            var value = gap?i*gap:legendData[i].min;
            value = isNaN(value) || value == null ? -9999 : value;
            this._seekSameValuePoint(value);
        }
        // var d2 = new Date().getTime();
        // console.log('寻找等值点:',(d2-d1)/1000+'s');

        var data = this._track();
        // var d3 = new Date().getTime();
        // console.log('跟踪:',(d3-d2)/1000+'s');
        // 跟踪
        return data;
    },

    /**
     * 清空之前插值的等值点
     */
    clearIsoPoints:function (){
        this.contourModel.s_grid.forEach(function (item){
            item.x_isoPoints=[];
            item.y_isoPoints=[];
        });
    },

    /**
     * 寻找等值点
     * @param value
     * @private
     */
    _seekSameValuePoint: function (value) {
        if (isNaN(value))
            return;

        var gridModel = this.contourModel;
        var rows = gridModel.s_rows;
        var columns = gridModel.s_columns;
        var d_value = this.options.d_value;

        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                var cell = this.contourModel.getCell_S(i, j);
                var x_cell = j === columns - 1 ? null : this.contourModel.getCell_S(i, j + 1);
                var y_cell = i === rows - 1 ? null : this.contourModel.getCell_S(i + 1, j);
                var v0 = cell.gridValue, v1, flag, rate;
                var latlng = this.contourModel.getCellLatLng_S(i, j);
                if (x_cell) {
                    v1 = x_cell.gridValue;
                    var lng = NaN;
                    flag = (value - v0) * (value - v1);
                    if (flag < 0)
                        lng = latlng.lng + (v0 - value) / (v0 - v1) * this.contourModel.cellLngRange;
                    else if (flag === 0) {
                        //if((value-v0)<this.precision && (value-v0)>-this.precision)
                        if (Math.abs(value - v0) < this.precision)
                            v0 += d_value;
                        else
                            v1 += d_value;
                        rate = (value - v0) / (v1 - v0);
                        if (rate > 0 && rate < 1) {
                            lng = latlng.lng + rate * this.contourModel.cellLngRange;
                        }
                    }
                    if (!isNaN(lng)) {
                        cell.x_isoPoints = cell.x_isoPoints || [];
                        cell.x_isoPoints.push({value: value, latlng: [latlng.lat, lng]});
                        // var n_marker=LW.nameMarker([latlng.lat,lng],{iconOptions:{radius: 3,color: '#f00',iconType: 'graph'}}).addTo(map);
                        // n_marker.options.icon.setData([],value);
                    }
                }
                v0 = cell.gridValue;
                if (y_cell) {
                    v1 = y_cell.gridValue;
                    var lat = NaN;
                    flag = (value - v0) * (value - v1);
                    if (flag < 0)
                        lat = latlng.lat + (v0 - value) / (v0 - v1) * this.contourModel.cellLatRange;
                    else if (flag === 0) {
                        //if((value-v0)<this.precision && (value-v0)>-this.precision)
                        if (Math.abs(value - v0) < this.precision)
                            v0 += d_value;
                        else
                            v1 += d_value;
                        rate = (value - v0) / (v1 - v0);
                        if (rate > 0 && rate < 1) {
                            lat = latlng.lat + rate * this.contourModel.cellLatRange;
                        }
                    }
                    if (!isNaN(lat)) {
                        cell.y_isoPoints = cell.y_isoPoints || [];
                        cell.y_isoPoints.push({value: value, latlng: [lat, latlng.lng]});
                        // n_marker=LW.nameMarker([lat,latlng.lng],{iconOptions:{radius: 3,color: '#f00',iconType: 'graph'}}).addTo(map);
                        // n_marker.options.icon.setData([],value);
                    }
                }
            }
        }
    },

    /**
     * 跟踪
     */
    _track: function () {
        var contourModel = this.contourModel;
        var rows = contourModel.s_rows;
        var columns = contourModel.s_columns;

        var data = [];
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < columns; j++) {
                var cell = contourModel.getCell_S(i, j);
                var p0, t_value, line;
                trackLine(cell.x_isoPoints, 'bottom');
                trackLine(cell.y_isoPoints, 'left');
            }
        }

        // var data = this._fixData(data);

        return data;

        function trackLine(isoPoints, dir) {
            if (isoPoints) {
                for (var m = 0; m < isoPoints.length; m++) {
                    var p = isoPoints[m];
                    if (!p.tracked) {
                        p.tracked = true;
                        p0 = p.latlng;
                        t_value = p.value;
                        var iValue = contourModel.levelMode ? contourModel.legendData[p.value].min : p.value;
                        // var bounds = L.latLngBounds();
                        // bounds.extend(p0);
                        line = {linevalue: iValue, linetype: 1, pointitems: [p0]};
                        data.push(line);
                        trampoline(trackCell(i, j, dir));
                    }
                }
            }

        }

        function trampoline(f) {
            while (f && f instanceof Function) {
                f = f();
            }
            return f;
        }

        function trackCell(row, column, dir) {
            if (dir == 'bottom') {
                var cell = contourModel.getCell_S(row, column);
                // 先找本点y放向是否有等值点，有的话，加入线条  -- 左，西
                var next_p = cell && cell.y_isoPoints ? Sun.Util.Array.getItemByField(cell.y_isoPoints, 'value', t_value) : null;
                if (closed(p0, next_p))
                    return true;
                if (addTrackPoint(next_p))
                    return trackCell.bind(null, row, column, "right");
                else {
                    // 若本点y没有等值点，再查找本点下一行的x方向是否有等值点 -- 对面，北
                    cell = contourModel.getCell_S(row + 1, column);
                    next_p = cell && cell.x_isoPoints ? Sun.Util.Array.getItemByField(cell.x_isoPoints, 'value', t_value) : null;
                    if (closed(p0, next_p))
                        return true;
                    if (addTrackPoint(next_p))
                        return trackCell.bind(null, row + 1, column, "bottom");
                    else {
                        // 若本点下一行的x方向无等值点，则查找本点下一列的y方向是否有等值点  -- 右，东
                        cell = contourModel.getCell_S(row, column + 1);
                        next_p = cell && cell.y_isoPoints ? Sun.Util.Array.getItemByField(cell.y_isoPoints, 'value', t_value) : null;
                        if (closed(p0, next_p))
                            return true;
                        if (addTrackPoint(next_p))
                            return trackCell.bind(null, row, column + 1, "left");
                    }
                }
            }
            else if (dir == 'top') {
                // 查找本点上一行的y方向是否有等值点  -- 左，西
                cell = contourModel.getCell_S(row - 1, column);
                next_p = cell && cell.y_isoPoints ? Sun.Util.Array.getItemByField(cell.y_isoPoints, 'value', t_value) : null;
                if (closed(p0, next_p))
                    return true;
                if (addTrackPoint(next_p))
                    return trackCell.bind(null, row - 1, column, "right");
                else {
                    // 查找本点上一行的x方向是否有等值点 -- 对面，南
                    next_p = cell && cell.x_isoPoints ? Sun.Util.Array.getItemByField(cell.x_isoPoints, 'value', t_value) : null;
                    if (closed(p0, next_p))
                        return true;
                    if (addTrackPoint(next_p))
                        return trackCell.bind(null, row - 1, column, "top");
                    else {
                        // 若本点上一行的x方向无等值点，则查找本点上一行下一列的y方向是否有等值点  -- 右，东
                        cell = contourModel.getCell_S(row - 1, column + 1);
                        next_p = cell && cell.y_isoPoints ? Sun.Util.Array.getItemByField(cell.y_isoPoints, 'value', t_value) : null;
                        if (closed(p0, next_p))
                            return true;
                        if (addTrackPoint(next_p))
                            return trackCell.bind(null, row - 1, column + 1, "left");
                    }
                }
            }
            else if (dir == 'left') {
                // 若本点x方向没有等值点，再查找本点上一行的x方向是否有等值点  -- 左，北 tip:数据纬度由小到大
                cell = contourModel.getCell_S(row + 1, column);
                next_p = cell && cell.x_isoPoints ? Sun.Util.Array.getItemByField(cell.x_isoPoints, 'value', t_value) : null;
                if (closed(p0, next_p))
                    return true;
                if (addTrackPoint(next_p))
                    return trackCell.bind(null, row + 1, column, "bottom");
                else {
                    // 若本点下一行的x方向无等值点，则查找本点下一列的y方向是否有等值点 -- 对面，东
                    cell = contourModel.getCell_S(row, column + 1);
                    next_p = cell && cell.y_isoPoints ? Sun.Util.Array.getItemByField(cell.y_isoPoints, 'value', t_value) : null;
                    if (closed(p0, next_p))
                        return true;
                    if (addTrackPoint(next_p))
                        return trackCell.bind(null, row, column + 1, "left");
                    else {
                        // 本点x方向是否有等值点，有的话，加入线条  -- 右，南
                        cell = contourModel.getCell_S(row, column);
                        next_p = cell && cell.x_isoPoints ? Sun.Util.Array.getItemByField(cell.x_isoPoints, 'value', t_value) : null;
                        if (closed(p0, next_p))
                            return true;
                        if (addTrackPoint(next_p))
                            return trackCell.bind(null, row, column, "top");
                    }
                }
            }
            else if (dir == 'right') {
                // 查找本点上一列的x方向是否有等值点 -- 左，南
                cell = contourModel.getCell_S(row, column - 1);
                next_p = cell && cell.x_isoPoints ? Sun.Util.Array.getItemByField(cell.x_isoPoints, 'value', t_value) : null;
                if (closed(p0, next_p))
                    return true;
                if (addTrackPoint(next_p))
                    return trackCell.bind(null, row, column - 1, "top");
                else {
                    // 查找本点上一列的y方向是否有等值点 -- 对面，西
                    cell = contourModel.getCell_S(row, column - 1);
                    next_p = cell && cell.y_isoPoints ? Sun.Util.Array.getItemByField(cell.y_isoPoints, 'value', t_value) : null;
                    if (closed(p0, next_p))
                        return true;
                    if (addTrackPoint(next_p))
                        return trackCell.bind(null, row, column - 1, "right");
                    else {
                        // 若本点上一列的y方向无等值点，则查找本点下一行上一列的x方向是否有等值点 -- 右，北
                        cell = contourModel.getCell_S(row + 1, column - 1);
                        next_p = cell && cell.x_isoPoints ? Sun.Util.Array.getItemByField(cell.x_isoPoints, 'value', t_value) : null;
                        if (closed(p0, next_p))
                            return true;
                        if (addTrackPoint(next_p))
                            return trackCell.bind(null, row + 1, column - 1, "bottom");
                    }
                }
            }
        }

        function closed(p1, p2) {
            return p1 && p2 && L.latLng(p1).equals(p2.latlng);
        }

        function addTrackPoint(p) {
            if (p && !p.tracked) {
                p.tracked = true;
                line.pointitems.push(p.latlng);
                // line.bounds.extend(p.latlng);
                return true;
            }
            else
                return false;
        }

    },

    _fixData: function (data) {
        for(i=0;i<data.length;i++){
            var points = data[i].pointitems;
            if(points.length>4){
                var fixPoints = [];
                for(j=0;j<points.length;j++){
                    if(j==0 || j==points.length-1){
                        fixPoints.push(points[j]);
                        // var n_marker=LW.nameMarker(L.latLng(points[j]),{iconOptions:{radius: 3,color: '#ff0',iconType: 'graph'}}).addTo(map);
                        // n_marker.options.icon.setData([],'');
                    }
                    else{
                        var latlng0 = L.latLng(points[j-1]);
                        var latlng1 = L.latLng(points[j]);
                        var latlng2 = L.latLng(points[j+1]);
                        var dis1 = latlng0.distanceTo(latlng1);
                        var dis2 = latlng1.distanceTo(latlng2);
                        if(dis1+dis2>5000){
                            fixPoints.push(points[j]);
                            // var n_marker=LW.nameMarker(latlng1,{iconOptions:{radius: 3,color: '#00f',iconType: 'graph'}}).addTo(map);
                            // n_marker.options.icon.setData([],'');
                        }
                    }
                }
                data[i].pointitems = fixPoints;
            }
        }
        return data;
    }

});

/**
 *
 * @module Layer.Plot.Contour
 */
/**
 * 等值线填色
 *
 * Features :
 *      1. 判断多边形的关系-排序-填色
 *
 * Update Note：
 *      + v1.3.0-dev ：修正图例中没有的填色为null，而非白色
 *      + v1.4.4 : 增加line上fixColor属性判断，用于编辑时忽略legendData,直接用给定的颜色
 *
 * @class LW.Tinter
 * @extends L.Class
 */
LW.Tinter = L.Class.extend({
    options: {
        editable: false
    },

    /**
     *
     * @param options
     */
    initialize: function (options) {
        L.setOptions(this, options);
    },

    /**
     * 获取等值面数据
     * @method getIsolineData
     * @param legendData;
     * @param isolineData {Array} 跟踪得到的等值线数据
     * @returns {Array}
     */
    getPlaneData: function (legendData,isolineData) {
        // 设置多边形关系判断
        this._setLineRelationShip(isolineData);

        // 修正子面值与父面值一致的值
        // for (var i = 0; i < isolineData.length; i++) {
        //     var line = isolineData[i];
        //     if (line.cid) {
        //         for (var j = 0; j < line.cid.length; j++) {
        //             var cline = isolineData[line.cid[j]];
        //             if(cline.linevalue == line.linevalue){
        //                 var idx = Sun.Util.Array.getItemIndexByField(legendData,'min',line.linevalue);
        //                 if(idx>0)
        //                     cline.linevalue = legendData[idx-1].min;
        //             }
        //         }
        //     }
        // }

        // 面数据
        var planeData = [];
        for (var i = 0; i < isolineData.length; i++) {
            var line = isolineData[i];
            var value ,color;
            if(line.fixColor){ // Tip:增加line上fixColor属性判断，用于编辑是忽略legendData,直接用给定的颜色
                value = line.linevalue;
                color = line.fixColor;
            }
            else {
                value = line.tinterValue = line.tinterValue || (line.linevalue + getTinterValue(line));
                color = Sun.Util.LegendData.getColorOfRangeLegend(legendData, value,'rgba(0,0,0,0)');
            }
            var plane = {id: i, planevalue: value, pointitems: [line.pointitems],planecolor:color};
            if (line.cid) {
                for (var j = 0; j < line.cid.length; j++) {
                    var cline = isolineData[line.cid[j]];
                    plane.pointitems.push(cline.pointitems);
                }
            }
            planeData.push(plane);

            if (this.options.editable) {//Tip:用于色斑图编辑洞关联
                if (!isNaN(line.pid)) {
                    var cids = isolineData[line.pid].cid;
                    var cindex = cids.indexOf(i) + 1;
                    plane.linkHoleId = line.pid + '_' + cindex;
                }
            }
        }
        return planeData;

        function getColor(legendData, v1, v2) {
            var val = v1 < v2 ? v1 + (v2 - v1) / 2 : v2 + (v1 - v2) / 2;
            return Sun.Util.LegendData.getColorOfRangeLegend(legendData, val,'rgba(0,0,0,0)');
        }

        function getTinterValue(line) {
            if(isValidPid(line) && isolineData[line.pid].linevalue == line.linevalue){
                var count=0;
                getPid(line);
                return count%2==0 ? 0.01 : -0.01;
            }
            else
                return (isValidPid(line) && isolineData[line.pid].linevalue > line.linevalue) ? -0.01 : 0.01;

            function getPid(line) {
                if(isValidPid(line) && isolineData[line.pid].linevalue == line.linevalue){
                    count++;
                    getPid(isolineData[line.pid]);
                }
            }

            function isValidPid(line) {
                return typeof line.pid != 'undefined' && !isNaN(line.pid) && line.pid !=-1;
            }
        }
    },

    _setLineRelationShip: function (data) {
        for (var i = 0; i < data.length; i++) {
            var line0 = data[i];
            var p0 = line0.pointitems[0];
            line0.cid = line0.cid || [];
            for (var j = i + 1; j < data.length; j++) {
                var line1 = data[j];
                var p1 = line1.pointitems[0];
                line0.id = i;
                line1.id = j;
                line1.cid = line1.cid || [];
                if (Sun.Util.Geometry.pointInPolygon(p0[0], p0[1], line1.pointitems)) {
                    // line0在line1里面
                    if (isNaN(line0.pid)) {
                        line0.pid = j;
                        line1.cid.push(i);
                    }
                    else {
                        // 如果line0已经有parent，则比较line1与line0原parent（line2）的关系
                        // 如果line1在line2中，line0的parent变成line1，line2删掉line0这个child，多一个line1这个child
                        var line2 = data[line0.pid];
                        if (Sun.Util.Geometry.pointInPolygon(p1[0], p1[1], line2.pointitems)) {
                            line2.cid.splice(line2.cid.indexOf(i), 1);
                            line0.pid = j;
                            line1.cid.push(i);
                        }
                    }
                }
                else if (Sun.Util.Geometry.pointInPolygon(p1[0], p1[1], line0.pointitems)) {
                    if (isNaN(line1.pid)) {
                        line1.pid = i;
                        line0.cid.push(j);
                    }
                    else {
                        line2 = data[line1.pid];
                        if (Sun.Util.Geometry.pointInPolygon(p0[0], p0[1], line2.pointitems)) {
                            line2.cid.splice(line2.cid.indexOf(j), 1);
                            line1.pid = i;
                            line0.cid.push(j);
                        }
                    }
                }
            }
        }
    }
});

/**
 * 基于平铺canvas渲染的图层，一般不单独使用，而是继承使用
 *
 * @class LW.CanvasLayer
 * @extends L.Layer
 */
LW.CanvasLayer = L.Layer.extend({
    options:{
        /**
         * 不透明度
         * @property opacity
         * @default 0.8
         */
        opacity: 0.8,
        /**
         * 渲染器
         * @property renderer
         * @default LW.canvas()
         */
        renderer: LW.canvas()
    },

    getElement:function (){
        return this.options.renderer._container;
    },

    getEvents: function () {
        return {
            _zoomend: this._zoomend,
            // resize: this._resize,
            movestart: this._movestart,
            moveend: this._update
        };
    },

    beforeAdd: function (map) {
        this._map = map;
        this._renderer = map.getRenderer(this);
    },

    onAdd: function () {
        this._renderer = this._map.getRenderer(this);
        this._update();
    },

    onRemove: function () {
        if (this._map.hasLayer(this._renderer))
            this._map.removeLayer(this._renderer);
    },

    _zoomend:function (e) {},

    _movestart:function(e){},

    _resize:function(e){},

    _update:function (e) {},

    /**
     * 清除
     * @method clear
     */
    clear: function () {
        if(this.options.renderer && this.options.renderer._bounds){
            var size = this.size = this.options.renderer._bounds.getSize();
            this.options.renderer._ctx.clearRect(0, 0, size.x, size.y);
        }
    },
    /**
     * 设置填色透明度
     * @method setOpacity
     * @param opacity
     */
    setOpacity:function (opacity) {
        this.options.opacity = opacity;
        this._update();
    },

    /**
     * 重置遮罩
     * @method resetMask
     * @param maskGeoJson {LW.maskGeoJson}
     */
    resetMask:function (maskGeoJson) {
        this.options.renderer.resetMask(maskGeoJson);
        this._update();
    }

});

/**
 * 等值线图层
 * Update Note：
 *      + v1.3.0-dev ：planeColor为null的，不予绘制
 */
LW.IsolineLayer = L.FeatureGroup.extend({
    options: {
        stroke: true,
        fill: true,
        color: '#A52829',
        weight: 1,
        hexColor: false,
        // fillColor: same as color by default
        fillOpacity: 1,
        pointerEvents: 'none',
        patternFill:false,
        geoInstance:LW.spline,
        nonBubblingEvents: ['click']
    },

    initialize: function (options) {
        this._layers = {};
        L.setOptions(this, options);
    },
    setData: function (data,separately) {
        this.data = data;
        // this.clearLayers();//因主要用在色斑图，未用于数值预报，然后多个色斑图展示不允许在此清空，遂先注释
        var options = L.extend({},this.options);
        if(data.planeitems){
            for (var i = 0; i < data.planeitems.length; i++) {
                var o = data.planeitems[i];
                if(o.planecolor){
                    // var options = Sun.Util.Data.clone(this.options);
                    // options.closed = parseInt(o.linetype) != 0;
                    options.fillColor = o.planecolor;
                    options.stroke = separately ? false : this.options.stroke;
                    var geo = options.geoInstance(o.pointitems,options).addTo(this);
                    geo.value = o.planevalue;
                    geo.id = o.id;
                    geo.fill = true;
                    geo.stroke = !separately;
                }
            }
        }

        if(separately || !data.planeitems){
            var options1 = L.extend({},this.options);
            for (i = 0; i < data.lineitems.length; i++) {
                var item = data.lineitems[i];
                options1.fill = false;
                var spline = options1.geoInstance(item.pointitems, options1).addTo(this);
                spline.value = item.linevalue;
                spline.stroke = true;
            }
        }
    },

    getLayerByID: function (id) {
        for (var s in this._layers) {
            var m = this._layers[s];
            if (m.id == id)
                return m;
        }
    },
    setLineColor: function (color) {
        this.options.color = color;
        this.eachLayer(function (layer) {
            layer.setStyle({'color':color})
        }, this);
    },
    setFillVisible: function (visible) {
        this.options.fill = visible;
        this.eachLayer(function (layer) {
            if(layer.fill)
                layer.setStyle({'fill':visible})
        }, this);
    },
    setLineVisible: function (visible) {
        this.options.stroke = visible;
        this.eachLayer(function (layer) {
            if(layer.stroke)
                layer.setStyle({'stroke':visible})
        }, this);
    },
    _updateStyle: function (geo) {
        if (geo instanceof LW.Spline) {
            geo.options.color = this.options.color;
            geo.options.fill = this.options.fill;
            geo.options.stroke = this.options.stroke;
            geo._updateStyle();
        }
    }
    // setPointerEvents:function(value){
    //     this.options.pointerEvents = value;
    //     this.eachLayer(this._updateStyle);
    // }
});

LW.isolineLayer = function (options) {
    return new LW.IsolineLayer(options);
};

/**
 * 等值面图层
 */

LW.IsosurfaceLayer = L.FeatureGroup.extend({
    options: {
        stroke: true,
        fill: true,
        color: '#A52829',
        weight: 1,
        hexColor: false,
        // fillColor: same as color by default
        fillOpacity: 1
    },

    initialize: function (options) {
        this._layers = {};
        L.setOptions(this, options);
    },
    setData: function (data) {
        if (this._map) {
            this.clearLayers();
            for (var i = 0; i < data.planeitems.length; i++) {
                var o = data.planeitems[i];
                var options = Sun.Util.Data.clone(this.options);
                if (Sun.Util.Common.isValid(o.planecolor))
                    options.fillColor = options.hexColor ? o.planecolor : Sun.Util.Color.toHexColor(o.planecolor);
                else
                    options.fill = false;
                options.interactive = false;
                var geo = LW.geometryUnion(o.subplaneitems, options).addTo(this);
                geo.value = o.planevalue;
                geo.id = i;
            }
        }
    },
    getLayerByID: function (id) {
        for (var s in this._layers) {
            var m = this._layers[s];
            if (m.id == id)
                return m;
        }
    },
    everyMarker: function (fun) {
        for (var s in this._layers) {
            var m = this._layers[s];
            m.options.fill = this.options.fill;
            m.options.stroke = this.options.stroke;
            fun(m);
        }
    },
    setFillVisible: function (visible) {
        this.options.fill = visible;
        this.everyMarker(this._updateStyle);
    },
    setLineVisible: function (visible) {
        this.options.stroke = visible;
        this.everyMarker(this._updateStyle);
    },
    _updateStyle: function (geo) {
        if (geo instanceof LW.GeometryUnion)
            geo._updateStyle();
    }
});

LW.isosurfaceLayer = function (options) {
    return new LW.IsosurfaceLayer(options);
};

/**
 * 等值线标注图层
 */
LW.IsolabelLayer = LW.CanvasLayer.extend({
    options: {
        color: '#A52829',
        font: '12px Microsoft Yahei',
        labelRotate:false,
        bold:true,
        renderer: LW.canvas({pane:'gridPane',interactive:false})
    },

    initialize:function(options){
        L.setOptions(this,options);
    },

    setData: function (data) {
        this.data = data;
        this._update();
        return this;
    },

    resetMask: function (mask) {
        this.options.maskGeoJson = mask;
        if (mask) {
            var maskBounds = this.maskBounds = L.latLngBounds([]);
            for (var key in mask._layers) {
                var layer = mask._layers[key];
                layer._latlngs.forEach(function (item) {
                    maskBounds.extend(L.latLngBounds(item));
                })
            }
        }
        this._update();
    },

    _update: function () {
        this.clear();
        if (this.data&&this._renderer) {
            var options = this.options;
            var ctx = this._renderer._ctx;
            ctx.font = options.font;
            ctx.textAlign = 'center';
            ctx.fillStyle = options.color;
            ctx.lineWidth=2;
            ctx.strokeStyle = '#fff';
            for (var i = 0; i < this.data.length; i++) {
                var o = this.data[i];
                var value = o.linevalue;
                if (!isNaN(value)){
                    if(markerShow(value,this.filterOptions))
                        this._setLineLabel(o.pointitems, Sun.Util.Math.toRoundFixed(value, 2));
                }
            }
        }

        function markerShow(value,f_options) {
            if (f_options){
                var min = f_options.min,max=f_options.max;
                return ((value > min && value < max) || (isNaN(min) && value < max) || (isNaN(max) && value > min) ||
                    (f_options.isEqualMin && value === max) || (f_options.isEqualMax && value === min))
            }
            return true;
        }
    },

    // _lableInMask: function (latlng) {
    //     var mask = this.options.maskGeoJson;
    //     var maskBounds = this.maskBounds;
    //     var xy = this._map.latLngToContainerPoint(latlng);
    //     var size = this._map.getSize();
    //     if(xy.x>0 && xy.y>0 && xy.x<size.x && xy.y<size.y){
    //         if (mask) {
    //             for (var key in mask._layers) {
    //                 var layer = mask._layers[key];
    //                 for(var i = 0; i < layer._latlngs.length;i++){
    //                     var inMask = Sun.Util.Geometry.latlngInPolygon(latlng, layer._latlngs[i],maskBounds);
    //                     if(inMask)
    //                         return true;
    //                 }
    //             }
    //             return false;
    //         }
    //         else
    //             return true;
    //     }
    //     else
    //         return false;
    //
    // },
    _lableInMask: function (latlng,xy) {
        var mask = this.options.maskGeoJson;
        var maskBounds = this.maskBounds;
        var size = this._map.getSize();
        if(xy.x>0 && xy.y>0 && xy.x<size.x && xy.y<size.y){
            if (mask) {
                var p = this._map.latLngToLayerPoint(latlng);
                for (var key in mask._layers) {
                    var layer = mask._layers[key];
                    var parts = layer._parts;
                    for(var i = 0; i < parts.length;i++){
                        if(parts[i].length>2){
                            var points = parts[i].map(function (item) {
                                return [item.x,item.y];
                            });
                            var inMask = Sun.Util.Geometry.pointInPolygon(p.x,p.y, points);
                            if(inMask)
                                return true;
                        }
                    }
                }
                return false;
            }
            else
                return true;
        }
        else
            return false;

    },

    _setLineLabel: function (locations, value) {
        if (this._map) {
            // TODO:此处应将截取点的代码提出，然后将点转化坐标的方法放入适配器中，以后再优化(剖面中copy此段代码)
            var map = this._map;
            var firstLocation = locations[0];
            var lastLocation = locations[0];
            var p0 = map.latLngToContainerPoint(firstLocation);
            var labeled = false;
            var flag = false;
            // var rotate = this.options.labelRotate;
            var ctx = this._renderer._ctx;
            for (var i = 0; i < locations.length - 1; i++) {
                var loc1 = locations[i];
                var loc2 = locations[i + 1];
                var loc = L.latLng((loc1[0] + loc2[0]) / 2, (loc1[1] + loc2[1]) / 2);
                var p1 = map.latLngToContainerPoint(lastLocation);
                var p2 = map.latLngToContainerPoint(loc);
                // if (p1.distanceTo(p2) >= 300) {
                if (distance(p1,p2) >= Math.pow(300,2)) {
                    if (this._lableInMask(loc,p2)) {
                        // var p3 = map.latLngToContainerPoint(loc2);
                        // var rotation = rotate?Math.atan2(p3.y - p1.y, p3.x - p1.x) * 180 / Math.PI:null;
                        drawMarker(value,p2/*,rotation*/);
                    }
                    lastLocation = loc;
                    labeled = true;
                }
                else if (!labeled && distance(p0,p2) >= Math.pow(20,2))
                    flag = true;
            }
            if (!labeled && flag) {
                i = parseInt(locations.length / 2);
                loc1 = locations[i];
                i = i + 1 >= locations.length ? 0 : i + 1;
                loc2 = locations[i];
                loc = L.latLng((loc1[0] + loc2[0]) / 2, (loc1[1] + loc2[1]) / 2);

                p1 = map.latLngToContainerPoint(loc);
                if (this._lableInMask(loc,p1)) {
                    // p3 = map.latLngToContainerPoint(loc2);
                    // rotation = rotate?Math.atan2(p3.y - p1.y, p3.x - p1.x) * 180 / Math.PI:null;
                    drawMarker(value,p1/*,rotation*/);
                }
            }
        }
        function distance(p1,p2) {
            return Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2)
        }

        function drawMarker(value, p, rotate) {
            // ctx.translate(p.x, p.y);
            // ctx.rotate(rotate);
            // ctx.translate(-p.x, -p.y);

            ctx.strokeText(value, p.x, p.y);
            ctx.fillText(value, p.x, p.y);

            // ctx.setTransform(Sun.Common.dpr, 0, 0, Sun.Common.dpr, 0, 0);
        }
    },

    showAllMarker: function () {
        this.filterOptions = null;
        this._update();
    },

    filterMarker: function (minValue, isEqualMin, maxValue, isEqualMax) {
        this.filterOptions = {min: minValue, isEqualMin: isEqualMin, max: maxValue, isEqualMax: isEqualMax};
        this._update();
    }
});

LW.isolabelLayer = function (options) {
    return new LW.IsolabelLayer(options);
};
/**
 * 数值预报、色斑图图层；剖面等
 * @module Layer.Plot
 */

/**
 * 数值预报图层
 *
 * Features :
 *      1. 包含等值线、等值面、标注、格点值等
 *      2. 主要是非风类数值预报所用图层及色斑图图层
 *      3. 需引用d3.js
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.0.3 ：支持用数据的边界作为遮罩
 *      + v1.0.4 ：增加图层未添加在地图上仍可设置数据的功能
 *      + v1.0.4-dev ：增加过滤功能
 *      + v1.1.0-dev ：增加色斑图不显示时，格点值根据色谱描边的功能
 *      + v1.4.0 ：修正色谱中没有的色块，不填色，而非填白色，主要是修正降水色谱不传0，希望得到透明的效果，需基于sun1.0.13
 *      + v1.4.0-dev : 色斑图增加canvas渲染器，格点图层也增加遮罩，标注图层改为canvas渲染
 *      + v1.4.8/v1.5.1 : 格点值图层改为基于gridModel的LW.GridLayer，相应的属性也变成LW.GridLayer中的属性
 *      + v1.5.1 ：增加网格值过滤的功能
 *
 *
 * @class LW.NwpLayer
 * @extends L.LayerGroup
 * @demo demo/plot/contour/contour_grid.html  {nwp_nc}
 * @demo demo/plot/contour/nwp.html  {nwp_json}
 */

LW.NwpLayer = L.LayerGroup.extend({
    options: {

        /**
         * 是否绘制等值线
         * @property stroke
         * @type {boolean}
         * @default true
         */
        stroke: true,

        /**
         * 等值线颜色
         * @property color
         * @type {string}
         * @default '#A52829'
         */
        color: '#A52829',

        /**
         * 等值线粗细
         * @property weight
         * @type {int}
         * @default 1
         */
        weight: 1,

        /**
         * 等值线透明度
         * @property opacity
         * @type {number}
         * @default 1
         */
        opacity: 1,

        /**
         * 是否填色
         * @property fill
         * @type {boolean}
         * @default true
         */
        fill: true,

        /**
         * 填色透明度
         * @property fillOpacity
         * @type {number}
         * @default 0.7
         */
        fillOpacity: 0.7,

        /**
         * 是否标注
         * @property label
         * @type {boolean}
         * @default true
         */
        label: true,

        /**
         * 标注颜色
         * @property labelColor
         * @type {string}
         * @default '#A52829'
         */
        labelColor: '#A52829',

        /**
         * 标注字体
         * @property font
         * @type {string}
         * @default '12px'
         */
        font: '12px Microsoft Yahei',

        /**
         * 标注是否旋转
         * @property labelRotate
         * @type {boolean}
         * @default false
         */
        labelRotate:false,

        /**
         * 是否展示格点值
         * @property grid
         * @type {boolean}
         * @default true
         */
        grid: true,

        /**
         * 网格图层属性
         * @property gridOptions
         * @type {object}
         * @param {LW.GridLayer}  详见LW.GridLayer的Options
         * @default
         */
        gridOptions: {
            elements:['value'],
            elementsVisible:{value:false},
            pane:'gridPane'
        },

        /**
         * 填充颜色是否为十六进制颜色
         *
         * 接口取数得到数据颜色为十进制
         *
         * @property hexColor
         * @type {boolean}
         * @default false
         */
        hexColor: false,

        /**
         * 渲染器
         *
         * 如果不使用默认需要在new时传入渲染器
         *
         * @property renderer
         * @type {L.Renderer}
         * @default L.svg()
         */
        renderer: LW.clipPathSvg(),

        /**
         * 是否用数据的边界作为遮罩，用于隐藏图形最外一圈线条
         * 仅支持麦卡托投影
         * @property boundMask
         * @type {boolean}
         * @default true
         */
        boundMask: true,

        isolineInstance: LW.isosurfaceLayer,
        geoInstance: LW.spline,
        /**
         * 在canvas为渲染器时，曲线算法比较耗性能，在某些等级下只展示折线来优化性能。
         * 尤其是数值预报这种网格密集型数据。站点色斑图可以根据情况配置较低的数值
         * @property curveZoom
         * @type {int}
         * @default 7
         */
        curveZoom:7,

        /**
         * 等值线是否分开跟踪和展示
         * @property lineSeparately
         * @type {boolean}
         * @default false
         */
        lineSeparately:false,

        /**
         * 等值线分开跟踪和展示时的等值线间隔，lineSeparately为true有效
         * @property lineGap
         * @type {int}
         * @default 4
         */
        lineGap:4
    },

    isolineLayer: null,
    isolabelLayer: null,

    initialize: function (options) {
        this._layers = {};
        L.setOptions(this, options);
        var _options = this.options;
        var maskGeoJson = _options.renderer.options.maskGeoJson;
        // 等值面图层
        this.isolineLayer = _options.isolineInstance({
            fillOpacity: _options.fillOpacity, color: _options.color, hexColor: _options.hexColor,
            fill: _options.fill, stroke: _options.stroke, weight: _options.weight,curveZoom:_options.curveZoom,
            renderer: _options.renderer, interactive:_options.interactive,geoInstance:_options.geoInstance,
            editable: _options.editable, patternFill:_options.patternFill
        });
        this.addLayer(this.isolineLayer);

        // 标注图层
        if (_options.label) {
            this.isolabelLayer = LW.isolabelLayer({color: _options.labelColor, font: _options.font,
                labelRotate:_options.labelRotate,renderer: LW.canvas({pane:'gridPane',interactive:false})});
            this.addLayer(this.isolabelLayer);
            if(maskGeoJson)
                this.isolabelLayer.resetMask(maskGeoJson);
        }

        // 网格图层
        if (_options.grid) {
            var gridOptions = this.options.gridOptions;
            gridOptions.renderer = LW.canvas({grid:true,maskGeoJson:maskGeoJson,pane:gridOptions.pane||'gridPane',interactive:false});
            var gridModel = new LW.GridModel({dataType: 'json'});
            this.gridLayer = LW.gridLayer(gridModel,gridOptions);
            this.addLayer(this.gridLayer);
        }

    },

    onAdd: function (map) {
        for (var i in this._layers) {
            map.addLayer(this._layers[i]);
        }
        if (this.data){
            this.setData(this.data);
        }
    },


    /**
     * 设置遮罩
     * @method setMask
     * @param maskGeoJson {L.GeoJSON} 遮罩geojson
     * @param boundMask
     */
    setMask: function (maskGeoJson,boundMask) {
        this.options.renderer.resetMask(maskGeoJson);
        if(this.isolabelLayer)
            this.isolabelLayer.resetMask(maskGeoJson);
        if(this.gridLayer)
            this.gridLayer.resetMask(boundMask ? false : maskGeoJson);
    },

    /**
     * 设置图层数据，并绘制
     * @method setData
     * @param data {Array}
     */
    setData: function (data) {
        this.data = data;
        this.clear();
        if (this._map && data) {
            // if (this.options.boundMask)
            //     this._setBoundMask();
            this.isolineLayer.setData(data,this.options.lineSeparately);
            if (this.options.label)
                this.isolabelLayer.setData(data.lineitems);
            if (this.options.grid)
                this.gridLayer.setData(data);
            if (!this.options.stroke && this.options.label)
                this._setLabelVisible(false);
        }
    },

    /**
     * 设置数据边界为遮罩，首次设置数据后设置，而后在数据范围发生变化时设置
     * Tips:需开启options.boundMask
     * @method setBoundMask
     */
    setBoundMask:function () {
        var data = this.data;
        if(data && this.options.boundMask){
            var maskdata = {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature", "id": "1", "properties": {"name": "bound"}, "geometry": {
                        "type": "Polygon",
                        "coordinates": [[[data.startlon + data.nlon, data.startlat + data.nlat],
                            [data.startlon + data.nlon, data.endlat - data.nlat],
                            [data.endlon - data.nlon, data.endlat - data.nlat],
                            [data.endlon - data.nlon, data.startlat + data.nlat]]]
                    }
                }]
            };
            if(!this.mask)
                this.mask = LW.maskGeoJson(maskdata,true).addTo(this);
            else{
                this.mask.clearLayers();
                this.mask.addData(maskdata);
            }
            this.setMask(this.mask,true);
        }
    },

    /**
     * 清除图层
     * @method clear
     */
    clear: function () {
        this.isolineLayer.clearLayers();
        if (this.options.label){
            this.isolabelLayer.setData(null);
            this.isolabelLayer.clear();
        }
        if (this.options.grid) {
            this.gridLayer.setData(null);
            this.gridLayer.clear();
        }
    },

    /**
     * 设置格点要素显隐
     * @method setGridElementVisible
     * @param element {string}
     * @param visible {boolean}
     */
    setGridElementVisible: function (element,visible) {
        this.gridLayer.setGridElementVisible(element,visible);
    },

    /**
     * 设置填色显隐
     * @method setFillVisible
     * @param value {boolean} 显隐值
     */
    setFillVisible: function (value) {
        this.isolineLayer.setFillVisible(value);
    },

    /**
     * 设置等值线显隐
     * @method setLineVisible
     * @param value {boolean} 显隐值
     */
    setLineVisible: function (value) {
        this.options.stroke = value;
        //等值线
        this.isolineLayer.setLineVisible(value);
        //标注
        if (this.options.label)
            this._setLabelVisible(value);
    },

    _setLabelVisible: function (value) {
        if (value && !this.hasLayer(this.isolabelLayer)) {
            this.addLayer(this.isolabelLayer);
            this.isolabelLayer._update();
        }
        else if (!value && this.hasLayer(this.isolabelLayer))
            this.removeLayer(this.isolabelLayer);
    },

    /**
     * 设置样式
     * @method setStyle
     * @param style {object} eg:{fillOpacity:0.5}
     */
    setStyle : function (style) {
        var _setStyle=function (m) {
            m.setStyle(style)
        };
        L.setOptions(this.isolineLayer, style);
        this.isolineLayer.eachLayer(_setStyle, this);
    },

    /**
     * 显示所有， 用于过滤后的恢复
     * @method showAll
     */
    showAll: function () {
        var _showAllGeo = function (m) {
            L.setOptions(m, {fillOpacity: this.options.fillOpacity, opacity: 1});
            m._updateStyle();
        };
        this.isolineLayer.eachLayer(_showAllGeo, this);
        if(this.isolabelLayer)
            this.isolabelLayer.showAllMarker();
        if(this.gridLayer)
            this.gridLayer.showAllRange();
    },
    /**
     * 过滤 注：若filter的value为无有效值则直接过滤
     * @method filter
     * @param minValue {number} 不填或NaN时仅过滤出比maxValue小的值
     * @param isEqualMin {boolean} 是否将等于minValue的值过滤
     * @param maxValue {number} 不填或NaN时仅过滤出比minValue大的值
     * @param isEqualMax {boolean} 是否将等于maxValue的值过滤
     */
    filter: function (minValue, isEqualMin, maxValue, isEqualMax) {
        var setGeoVisible = function (m) {
            if (m instanceof L.Polygon) {
                var value = m.value,
                    options,
                    showOptions = {fillOpacity: this.options.fillOpacity, opacity: 1},
                    hideOptions = {fillOpacity: 0, opacity: 0};
                if (isNaN(minValue) && isNaN(maxValue))
                    options = showOptions;
                else if (isNaN(minValue)) {
                    options = value <= maxValue ? showOptions : hideOptions;
                    if (isEqualMax && value == maxValue)
                        options = hideOptions;
                }
                else if (isNaN(maxValue)) {
                    options = value >= minValue ? showOptions : hideOptions;
                    if (isEqualMin && value == minValue)
                        options = hideOptions;
                }
                else {
                    options = value <= maxValue && value >= minValue ? showOptions : hideOptions;
                    if (isEqualMin && value == minValue)
                        options = hideOptions;
                    if (isEqualMax && value == maxValue)
                        options = hideOptions;
                }
                L.setOptions(m, options);
                m._updateStyle();
            }
        };
        this.isolineLayer.eachLayer(setGeoVisible, this);
        if(this.isolabelLayer)
            this.isolabelLayer.filterMarker(minValue, isEqualMin, maxValue, isEqualMax);
        if(this.gridLayer)
            this.gridLayer.setDataRange({min:minValue,max:maxValue});
    }
});

/**
 * @class LW.NwpLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.NwpLayer}
 */
LW.nwpLayer = function (options) {
    return new LW.NwpLayer(options);
};


/**
 *
 * @module Layer.Plot
 */
/**
 * 色斑图图层
 *
 * Features ：
 *      1. 原理：由站点通过插值、跟踪、填色然后绘制生成
 *      2. 渲染器为svg时需引用d3.js
 *      3. options.bounds是网格的边界，一般用遮罩的边界，要保证数据与边界是几乎对应的，否则插值没有数据依据，导致误差较大
 *      4. options.rows,options.columns是网格的行列，和省、市边界的形状关系很大，竖向型配置行多列少，横向型配置列多行少，近似正方形配置行列一样多。
 *      5. 色板图图例数据只能由小到大，图例min/max必须收尾相接，不能跳空
 *      Tip：由于色斑图算法的特性，是描述所有站点的趋势，而不是针对每个点独立的描述，所以可能出现等值线无法包含某些点情况，加大网格密度的会有所好转，但不能避免所有的情况
 *
 * Update Note ：
 *      + v1.0.0 ：Created
 *      + v1.0.1 ：色斑图插值、跟踪、填色前端完成
 *      + v1.0.2 ：增加色斑图可动态配置遮罩功能
 *      + v1.0.4 ：增加可从网格数据生成色斑图的功能
 *      + v1.1.0-dev ：增加克里金和径向基函数插值方法，及其可选配置
 *      + v1.3.0-dev : 通过简化等值线的点让等值线展示的更平滑，和删除点数小于某值的等值线的功能
 *      + v1.4.0-dev : 色斑图增加canvas渲染器，格点图层也增加遮罩，标注图层改为canvas渲染,如果没有编辑，推荐使用canvas渲染器
 *      + v1.4.4 : 增加根据模式填充图例进行填色的功能，需基于sun@1.0.16
 *      + v1.5.3 : 增加等值线可以分开根据间隔渲染的功能，用fillData属性配置。
 *      + v1.5.4 : 1. 修复等值线跟踪递归栈溢出的问题
 *                 2. 增加跟踪的差值修复值d_value可以配置的功能,在跟踪0.1间隔等值线时需要配置0.01以保证跟踪正常
 *      + v1.5.6 : 增加数据数量小于iPointMinNum时依然可以跟踪出色斑图的功能
 *
 * Bug Feedback ：(请将以下内容整理发送王海伦测试)
 *      1. 错误的色斑图截图
 *      2. 简单的错误描述
 *      3. 数据保存成文件
 *      4. 遮罩文件
 *      5. 图例数据
 *      6. 色斑图的配置截图，包含bounds,rows,columns等
 *
 * @class LW.ContourLayer
 * @extends LW.NwpLayer
 * @demo demo/plot/contour/contour.html  {色斑图}
 * @demo demo/plot/contour/contour_pattenfill.html  {色斑图--模式填充}
 * @demo demo/plot/contour/contour_visib.html  {色斑图--能见度}
 * @demo demo/plot/contour/contour_mask_change.html  {色斑图--改变遮罩}
 * @demo demo/plot/contour/contour_grid.html  {色斑图--格点数据}
 */
LW.ContourLayer = LW.NwpLayer.extend({
    options: {
        hexColor: true,
        grid: false,
        /**
         * 网格列数(越大则性能越差，但插值会更准确)
         * @property columns
         * @type {int}
         * @default 50
         */
        columns: 50,
        /**
         * 网格行数(越大则性能越差，但插值会更准确)
         * @property rows
         * @type {int}
         * @default 50
         */
        rows: 50,

        /**
         * 参与插值的离散点最少数量
         * @property iPointMinNum
         * @type {int}
         * @default 3
         */
        iPointMinNum: 3,
        /**
         * 插值指数，离散点的比重的指数
         * @property pow
         * @type {int}
         * @default 5
         */
        pow: 5,

        /**
         * 查找的最大行数
         * @property seekMaxRow
         * @type {int}
         * @default 50
         */
        seekMaxRow:50,
        /**
         * 查找的最列数
         * @property seekMaxColumn
         * @type {int}
         * @default 50
         */
        seekMaxColumn:50,

        /**
         * 插值的方法
         * 选项 :
         *      1. idw -- 反距离加权插值
         *      2. kriging -- 克里金插值，不适合大数据量的插值，会比较慢且准度不够
         *      3. rbf -- 径向基函数插值
         * @property method
         * @type {string}
         * @default 'idw'
         */
        method:'idw',

        /**
         * 跟踪的差值修正。如果图例有2位小数，需要改成0.01
         * @property d_value
         * @type {string}
         * @default 0.1
         */
        d_value: 0.1,

        /**
         * 等值线粗细
         * @property weight
         * @type {int}
         * @default 1
         */
        weight: 1,

        /**
         * 插值边界
         * @property bounds
         * @type {L.latLngBounds}
         * @default null
         */
        bounds: null,

        /**
         * 离散点值缩放比（主要用于能见度，其缩放比为0.001）
         * @property valueScale
         * @type {number}
         * @default 1
         */
        valueScale: 1,

        /**
         * 是否用数据的边界作为遮罩
         * @property boundMask
         * @type {Boolean}
         * @default false
         */
        boundMask: false,

        /**
         * 是否计算填色数据。如果仅需要展示等值线，不需要展示填色，可以将该属性设成false以提高性能
         * @property fillData
         * @type {Boolean}
         * @default true
         */
        fillData:true,

        curveZoom:1,

        latField:'STATIONLAT',

        lonField:'STATIONLON',

        isolineInstance: LW.isolineLayer
    },

    initialize: function (options) {
        LW.NwpLayer.prototype.initialize.call(this, options);
        options = this.options;
        this.contourModel = new LW.ContourModel({
            latField:options.latField,lonField:options.lonField,
            method:options.method,iPointMinNum:options.iPointMinNum,pow:options.pow,d_value:options.d_value,
            minValue:options.minValue,maxValue:options.maxValue,fillData:options.fillData,
            seekMaxRow:options.seekMaxRow,seekMaxColumn:options.seekMaxColumn,editable: this.options.editable});
        this.setBounds(options.bounds);
    },

    /**
     * 设置插值边界
     * @method setBounds
     * @param bounds {L.latLngBounds} 插值的边界
     */
    setBounds: function (bounds) {
        if(bounds){
            this.options.bounds = bounds;
            this.contourModel.setGridBounds(bounds,this.options.rows,this.options.columns);
        }
    },

    /**
     * 重置网格属性
     * @param rows {int} 网格密度-行
     * @param columns {int} 网格密度-列
     * @param options {object} 其他网格属性
     * @param redraw {boolean} 是否重绘
     */
    resetGridOptions:function (rows,columns,options,redraw) {
        redraw = typeof redraw == 'undefined' ? true : redraw;
        var cModel = this.contourModel;
        if(rows) this.options.rows = cModel.rows = parseInt(rows);
        if(columns) this.options.columns = cModel.columns = parseInt(columns);
        L.setOptions(this.contourModel,options);
        if(redraw) this.showContour();
    },

    /**
     * 重置等值线数据
     * @param separately {boolean} 是否分开展示，true:分开展示，基于gap,min,max计算等值线，false:不分开展示，展示图例中的等值线
     * @param gap {int} [optional] 分开展示的等值线间隔
     * @param min {int} [optional] 分开展示的等值线最小值，设置NaN则使用数据中的最小值
     * @param max {int} [optional] 分开展示的等值线最大值，设置NaN则使用数据中的最大值
     */
    resetIsolineOptions:function (separately,gap,min,max){
        this.options.lineSeparately = separately;
        this.options.lineGap = gap;
        this.contourModel.options.minValue = min;
        this.contourModel.options.maxValue = max;
        this.showContour();
    },

    _resetContour:function () {
        this.clear();
        this.source = this.contourModel.getContourDataOfZdz();
        this.setData(this.source);
    },

    /**
     * 显示色斑图
     * @method showContour
     * @param zdzData {Array|rbush} 自动站数据（离散数据）tip:有效值数量需大于等于3个
     * @param valueField {string} 值字段名
     * @param legendData {Array} 图例数据
     */
    showContour: function (zdzData, valueField, legendData) {
        this.clear();
        this.source = this.contourModel.getContourDataOfZdz(zdzData, valueField, legendData);
        if(this.options.lineSeparately)
            this.source.lineitems = this.contourModel.getIsolineData(this.options.lineGap);
        this.setData(this.source);

    },

    showContourOfDensity: function(data,gap,legendData){
        this.clear();
        this.source = this.contourModel.getContourDataOfDensity(data,gap,legendData);
        this.setData(this.source);
    },

    /**
     * 由网格数据生成色斑图
     * @method showContourByGridData
     * @param source {Array} 网格数据
     * @param legendData {Array} 图例数据
     */
    showContourByGridData: function (source, legendData) {
        if(source){
            this.source = this.contourModel.getContourDataOfGrid(source,legendData);
            // 设置数据绘制
            this.setData(source);
        }
    },

    /**
     * 由nc网格数据生成色斑图
     * @method showContourByNcGrid
     * @param source {ArrayBuffer} nc数据
     * @param legendData
     * @param isWind Tip:Sun@1.0.16 changeGridNcToJson方法删除了isWind
     */
    showContourByNcGrid:function (source,legendData,isWind) {
        var data = Sun.Util.Data.changeGridNcToJson(new Uint8Array(source),'speed');
        this.showContourByGridData(data,legendData);
    },

    showContourByLineData:function (data,legendData) {
        var tinter = new LW.Tinter();
        var cLegend = this.contourModel ? this.contourModel.legendData : undefined;
        legendData = legendData || cLegend || this.legendData;
        if(legendData) this.legendData = legendData;
        data.planeitems = tinter.getPlaneData(legendData,data.lineitems);
        this.source = data;
        this.setData(data);
    },

    /**
     * 通过简化等值线的点让等值线展示的更平滑，和删除点数小于某值的等值线
     * 需要引用turf.js
     * @method simplifiedLines
     * @param x_smooth {number} 平滑系数，推荐使用0-1之间数值,传0值则不平滑,
     *                          由于是采用简化等值线的点来实现平滑，所以有可能出现外圈太过平滑和里面交叉的情况，此时建议使用更小值或者传0不平滑
     * @param x_deleteRinglet {int} 删除小圈系数，删除点数少于指定数值的小圈,传0值则不删除
     * @param withoutBoundary {boolean} 是否不含边界，因为边界的概化可能导致边界处形状的不准确。
     */
    simplifiedLines:function (x_smooth,x_deleteRinglet,withoutBoundary) {
        var data = Sun.Util.Data.deepClone(this.source);
        if(data && data.lineitems){
            var lines = x_deleteRinglet>0 ? [] : data.lineitems;
            if(x_deleteRinglet>0) {
                for (var i = 0; i < data.lineitems.length; i++) {
                    var item = data.lineitems[i];
                    if (item.pointitems.length > x_deleteRinglet) {
                        item.pid = NaN;
                        item.cid = [];
                        lines.push(item);
                    }
                }
                data.lineitems = lines;
            }
            if(x_smooth>0){
                if(withoutBoundary){
                    var bounds = turf.polygon([[[data.startlon, data.startlat],[data.startlon, data.endlat],
                        [data.endlon, data.endlat],[data.endlon, data.startlat],[data.startlon, data.startlat]]]);
                }
                for(var j=0;j<lines.length;j++){
                    if(lines[j].pointitems.length>4){
                        var _line = lines[j].pointitems.map(function (item) {
                            return [item[1],item[0]];
                        });
                        _line.push(_line[0]);
                        var poly = turf.polygon([_line]);
                        var simplified;
                        if(withoutBoundary){
                            if(turf.booleanContains(bounds, poly))//多边形再边界里
                                simplified = turf.simplify(poly, x_smooth/100, false);
                            else/* if (turf.booleanOverlap(poly, bounds))*/
                                continue;
                        }
                        else
                            simplified = turf.simplify(poly, x_smooth/100, false);
                        var coordinates = simplified.geometry.coordinates[0];
                        lines[j].pointitems = coordinates.map(function (item) {
                            return [item[1],item[0]];
                        })
                    }
                }
            }
            // 填色
            if(x_smooth>0 || x_deleteRinglet>0)
                data.planeitems = this.contourModel.getPlaneData(lines);
            this.setData(data);
        }
    },

    /**
     * 计算色斑图面积（单位：平方米）
     * [Deprecated]
     * @method getArea
     * @param legendData
     * @param geojson
     * @param data
     * @param outValue
     * @returns {*}
     */
    getArea:function(legendData,geojson,data,outValue){
        legendData = legendData || this.contourModel.legendData;
        geojson = geojson || this.options.renderer.options.maskGeoJson.data;
        data = data || Sun.Util.Data.deepClone(this.source);
        outValue = outValue || -1;
        // 重置图例面积
        legendData.forEach(function (item) {
            item.area = 0;
        });

        // 根据区域格点标记区域外的网格值为最小值
        if(!this.regionGrid)
            this.regionGrid = Sun.Util.Grid.getRegionGrid(this.contourModel,geojson);

        var contourModel = this.contourModel;
        var minValue = this.contourModel.minValue;
        for(var i=0;i<data.data.length;i++){
            data.data[i] = this.regionGrid[i]>0 ? data.data[i] : outValue;
        }
        contourModel.setGridByData(data);

        // 跟踪
        data.lineitems = contourModel.getIsolineData();
        // 填色
        data.planeitems = contourModel.getPlaneData(data.lineitems);
        this.setData(data);
        // 还原contourModel的网格
        contourModel.setGridByData(this.source);

        // 面积计算
        culArea();
        // 去除辅助计算的圈的面积
        legendData.forEach(function (item) {
            if(item.max<minValue)
                item.area = 0;
        });
        return legendData;

        function culArea() {
            data.lineitems.forEach(function (item) {
                var coords = item.pointitems.map(function (c) {
                    return [c[1],c[0]];
                });
                coords.push(coords[0]);
                var poly = turf.polygon([coords]);
                item._area = turf.area(poly);
            });
            data.lineitems.forEach(function (item) {
                var subArea = 0;
                if (item.cid) {
                    item.cid.forEach(function (id) {
                        subArea += data.lineitems[id]._area;
                    })
                }
                item.area = item._area-subArea;

                var idx = Sun.Util.LegendData.getColorIndex(legendData,item.tinterValue);
                if(idx !== -1){
                    var legendItem = legendData[idx];
                    legendItem.area = legendItem.area || 0;
                    legendItem.area += item.area;
                }
            });
        }
    }

});

/**
 * @class LW.ContourLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.ContourLayer}
 */
LW.contourLayer = function (options) {
    return new LW.ContourLayer(options);
};


/**
 * 双线性插值的渐变网格图层
 *
 * Features :
 *      1. 组合LW.GradientLayer和LW.GridLayer
 *      2. 支持单个网格或多个嵌套网格
 *      3. 根据色谱渐变展示
 *
 * Update Note：
 *      + v1.4.7 ：Created
 *      + v1.5.1 ：增加过滤功能
 *      + v1.5.2 ：增加基于像素的间隔可配置的功能，主要用于基于canvas 2d的风流场的性能优化
 *
 * @class LW.GradientGridLayer
 * @extends L.LayerGroup
 * @demo demo/plot/contour/gradientLayer.html {渐变图层}
 */

LW.GradientGridLayer = L.LayerGroup.extend({
    options: {

        legendData:[],

        maskGeoJson:null,

        /**
         * 网格图层属性
         * @property gridOptions
         * @type {object}
         * @param {LW.GridLayer}  详见LW.GridLayer的Options
         */
        gridOptions: {
            elements:['value'],
            elementsVisible:{value:false},
            gridPosition:'leftbottom',
            pane:'gridPane'
        },
        /**
         * 填充图层属性
         * @property fillOptions
         * @type {object}
         * @default
         */
        fillOptions:{
            pane:'overlayPane'
        }
    },

    initialize: function (gridModel,options) {
        this._layers = {};
        L.setOptions(this, options);

        var fillOptions = this.options.fillOptions;
        fillOptions.renderer = LW.canvas({maskGeoJson:this.options.maskGeoJson,pane:fillOptions.pane||'overlayPane',interactive:false,fitDpr:false});
        this.fillLayer = LW.gradientLayer(gridModel,fillOptions);
        this.addLayer(this.fillLayer);

        var gridOptions = this.options.gridOptions;
        gridOptions.renderer = LW.canvas({maskGeoJson:this.options.maskGeoJson,pane:gridOptions.pane||'gridPane',interactive:false});
        this.gridLayer = LW.gridLayer(gridModel,gridOptions);
        this.addLayer(this.gridLayer);

        this.setLegendData(this.options.legendData);
    },

    /**
     * 设置图层数据，并绘制
     * @method setData
     * @param data {Array}
     */
    setData: function (data) {
        this.gridLayer.setData(data);
    },

    /**
     * 清除图层
     * @method clear
     */
    clear: function () {
        this.setData(null);
        this.fillLayer.clear();
        this.gridLayer.clear();
    },

    resetMask:function (maskGeoJson) {
        this.fillLayer.resetMask(maskGeoJson);
        this.gridLayer.resetMask(maskGeoJson);
    },

    setLegendData: function (legendData) {
        this.fillLayer.setLegendData(legendData);
        this.gridLayer.setLegendData(legendData);
    },

    setFillVisible:function(visible){
        if(!visible && this.hasLayer(this.fillLayer))
            this.removeLayer(this.fillLayer);
        else if(visible && !this.hasLayer(this.fillLayer))
            this.addLayer(this.fillLayer);
    },

    setGridElementVisible: function (element,visible) {
        this.gridLayer.setGridElementVisible(element,visible);
    },
    /**
     * 显示所有， 用于过滤后的恢复
     * @method showAll
     */
    showAll: function () {
        this.gridLayer.showAllRange();
        if(this.gridLayer)
            this.gridLayer.showAllRange();
    },
    /**
     * 过滤 注：若filter的value为无有效值则直接过滤
     * @method filter
     * @param minValue {number} 不填或NaN时仅过滤出比maxValue小的值
     * @param isEqualMin {boolean} 是否将等于minValue的值过滤
     * @param maxValue {number} 不填或NaN时仅过滤出比minValue大的值
     * @param isEqualMax {boolean} 是否将等于maxValue的值过滤
     */
    filter: function (minValue, isEqualMin, maxValue, isEqualMax) {
        this.gridLayer.setDataRange({min:minValue,max:maxValue});
        if(this.fillLayer)
            this.fillLayer.setDataRange({min:minValue,max:maxValue});
    }
});
/**
 *
 * @class LW.GradientGridLayer
 * @constructor
 * @param gridModel {LW.GridModel|LW.GridModelManager} 格点数据模型
 * @param options {object} 外部属性，可重设Properties
 * @param layers {object} 初始图层，可以不传
 * @returns {LW.GradientGridLayer}
 */
LW.gradientGridLayer = function (gridModel,options, layers) {
    return new LW.GradientGridLayer(gridModel,options, layers);
};
LW.GradientLayer = LW.CanvasLayer.extend({
    options: {
        contour:true,
        legendData:[],
        blur:false,
        opacity:0.8,
        gap:2,
        renderer: LW.noTranslateCanvas({interactive:false})
    },
    range:{
        min:NaN,
        max:NaN
    },
    initialize:function(gridModel,options){
        L.setOptions(this,options);
        if(this.options.mask)
            this.setMaskGeojson(this.options.mask);
        this.gridModel = gridModel;
        this.setLegendData(this.options.legendData);
        if(window.Worker && this.options.blur)
            this.worker = new Worker(LW.workerPath + 'blur.js');

        var self = this;
        this.gridModel.on('transform',function(){
            self._update();
        });
    },

    /**
     * 设置图例数据
     * @method setLegendData
     * @param legendData
     */
    setLegendData: function (legendData) {
        if (legendData) {
            this.options.legendData = legendData;
            var segments = Sun.Util.LegendData.getColorSegments(legendData,1,this.options.opacity);
            this.colorScale = Sun.Util.Color.segmentedColorScale(segments);
        }
    },

    /**
     * 设置数据
     * @method setData
     * @param data {ArrayBuffer|json} 数据，可为nc流数据或者json数据
     */
    setData: function (data) {
        if((data instanceof ArrayBuffer && data.byteLength>0) || Object.prototype.toString.call(data).toLowerCase()==="[object object]"){
            this.gridModel.setData(data);
        }
        else{
            this.gridModel.data = null;
            this.clear();
        }
    },


    createBacker: function () {
        var size = this.size;
        var imageData = this._renderer._ctx.getImageData(0, 0, size.x, size.y);
        var data = imageData.data;  // layout: [r, g, b, a, r, g, b, a, ...]
        return {
            imageData: imageData,
            setRGBA: function (x, y, rgba) {
                var i = (y * size.x + x) * 4;
                data[i] = rgba[0];
                data[i + 1] = rgba[1];
                data[i + 2] = rgba[2];
                data[i + 3] = rgba[3];
                return this;
            }
        };
    },

    /**
     * 展示所有范围的值，用于setDataRange后恢复
     * @method showAllRange
     */
    showAllRange:function () {
        this.setDataRange({min:NaN,max:NaN});
    },

    /**
     * 设置数据展示区间
     * @method setDataRange
     * @param range {object} {min:NaN,max:NaN}
     */
    setDataRange:function (range) {
        this.range=range;
        this._update();
    },

    _update: function () {
        if (this.gridModel.data && this._map) {
            // var d1 = Date.now();
            this.clear();
            this._draw();
            // var d2 = Date.now();
            // console.log('gradient update:'+(d2-d1)/1000+'s');
        }
    },

    _draw : function () {
        if (this.options.contour)
            this.backer = this.createBacker();
        this._batchInterpolate();
        this.showProduct();
        this._renderer.setMask();
    },

    _batchInterpolate:function(){
        var map = this._map, options = this.options, size = this.size;
        var gridModel = this.gridModel,bounds = gridModel.bounds;
        var backer = this.backer,colorScale = this.colorScale;
        var getValue = gridModel.options.wind?this._getUV:this._getValue;
        var range = this.range;

        var _bounds = new L.Bounds(map.latLngToContainerPoint(bounds.getNorthWest()),
            map.latLngToContainerPoint(bounds.getSouthEast()));
        var cBounds = this.cBounds = clampedBounds(_bounds, size);
        this.columns = columnsInterpolate();

        function clampedBounds (bounds, size) {
            var x = Math.round(Math.max(bounds.min.x, 0));//Tip:安卓微信浏览器bounds可能返回非整数
            var y = Math.round(Math.max(bounds.min.y, 0));
            var xMax = Math.round(Math.min(bounds.max.x, size.x));
            var yMax = Math.round(Math.min(bounds.max.y, size.y));
            return {x: x, y: y, xMax: xMax, yMax: yMax, width: xMax - x + 1, height: yMax - y + 1};
        }

        function columnsInterpolate() {
            var cx = cBounds.x, xMax = cBounds.xMax;
            var cy = cBounds.y, yMax = cBounds.yMax;
            var gap = options.gap;
            var columns = [];
            for (var x = cx; x <= xMax; x += gap) {
                var column = [];
                for (var y = cy; y <= yMax; y += gap) {
                    var coord = map.containerPointToLatLng([x, y]);
                    var color = [255, 255, 255, 0];
                    var value = null;
                    if (coord) {
                        var lng = coord.lng, lat = coord.lat;
                        lng = Math.max(bounds.getWest(), lng);
                        lat = Math.max(bounds.getSouth(), lat);
                        value = gridModel.getInterpolation(lat, lng);
                        if (value != null && isShow(value)) {
                            color = colorScale(getValue(value, options.speedScale));
                        }
                    }
                    // column[y] = column[y + 1] = value;
                    var _gap = gap;
                    while (_gap--)
                        column[y + _gap] = value;

                    // if (backer)
                    //     backer.setRGBA(x, y, color).setRGBA(x + 1, y, color)
                    //         .setRGBA(x, y + 1, color).setRGBA(x + 1, y + 1, color);

                    if(backer){
                        for(var x_i=0;x_i<gap;x_i++)
                            for(var x_j=0;x_j<gap;x_j++){
                                backer.setRGBA(x+x_i, y+x_j, color)
                            }
                    }
                }
                // columns[x] = columns[x + 1] = column;
                _gap = gap;
                while (_gap--)
                    columns[x + _gap] = column;
            }
            return columns;
        }

        function isShow(value) {
            if(isNaN(range.min) && isNaN(range.max))
                return true;
            else if(isNaN(range.min))
                return value<=range.max;
            else if(isNaN(range.max))
                return value>=range.min;
            else
                return value>=range.min && value<=range.max;
        }
    },


    _getValue:function (value) {
        return value;
    },

    _getUV:function (value,speedScale) {
        var scale = speedScale || 1;
        value[0] = value[0] * scale;
        value[1] = value[1] * scale;
        return value[2];
    },

    showProduct:function () {
        if (this.options.contour) {
            var ctx = this._renderer._ctx;
            var size = this.size;
            if (this.worker) {
                this.worker.onmessage = function (a) {
                    ctx.putImageData(a.data, 0, 0);
                };
                this.worker.postMessage({
                    imageData: this.backer.imageData,
                    width: size.x,
                    height: size.y,
                    radius: 1
                });
            }
            ctx.putImageData(this.backer.imageData, -2, 0);//Tip:不明原因超出一些像素。用-2去调整这种现象
        }
    }
});

LW.gradientLayer = function (gridModel,options) {
    return new LW.GradientLayer(gridModel,options);
};

/**
 * @module Layer.Plot
 */

/**
 * 数值预报风图层
 *
 * Features :
 *      1. 组合LW.FlowWindLayer和LW.GridLayer
 *      2. 支持单个网格或多个嵌套网格
 *      3. 包含色斑图、流场线、格点值、格点风等
 *      4. 主要是风类数值预报所用图层
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.0.4-dev ：
 *          1. gridDistanceScale属性弃用，用gridDistanceMinWidth属性来设置格点间隔
 *          2. 图层未添加在地图上仍可设置数据的功能
 *      + v1.1.0-dev ：增加色斑图不显示时，格点值根据色谱描边的功能
 *      + v1.4.0 : 基于gridModel生成风场
 *      + v1.4.7 : 从LW.GradientGridLayer继承实现
 *      + v1.5.3 : 增加浪的支持
 *      + v1.5.4 : 增加流线长度，透明度，线宽等配置。优化流场动效的展示
 *
 * @class LW.FlowWindGridLayer
 * @extends L.LayerGroup
 * @demo demo/plot/contour/nwpWind.html  {风场}
 * @demo demo/plot/contour/nwpWave.html  {浪}
 * @demo demo/other/gifExport.html  {流场导出gif}
 */

LW.FlowWindGridLayer = LW.GradientGridLayer.extend({
    options: {
        /**
         * 网格图层属性
         * @property gridOptions
         * @type {object}
         * @param {LW.GridLayer}  详见LW.GridLayer的Options
         */
        gridOptions: {
            elements:['value','wind'],
            elementsVisible:{value:false,wind:false},
            pane:'gridPane'
        },
        /**
         * 流动风场图层属性
         * @property flowWindOptions
         * @type {object}
         * @param {LW.FlowWindLayer}  详见LW.FlowWindLayer的Options
         */
        flowWindOptions: {
            /**
             * 模糊渲染js地址,可以不传，不传渲染时像素颗粒感会较严重,效果不佳
             * 暂时不使用外部传入路径，使用默认路径即可
             * 废弃属性
             */
            //blurJsUrl: '/blur.js'
        }

    },

    initialize: function (gridModel,options) {
        this._layers = {};
        L.setOptions(this, options);

        var windOptions = this.options.flowWindOptions;
        windOptions.renderer = LW.canvas({maskGeoJson:this.options.maskGeoJson,pane:windOptions.contourPane||'overlayPane',interactive:false,fitDpr:false});
        windOptions.flowWindRender = LW.canvas({pane:windOptions.windPane||'gridPane',interactive:false});
        this.flowWindLayer = LW.flowWindLayer(gridModel,windOptions);
        this.addLayer(this.flowWindLayer);

        var gridOptions = this.options.gridOptions;
        gridOptions.renderer = LW.canvas({maskGeoJson:this.options.maskGeoJson,pane:gridOptions.pane||'gridPane',interactive:false});
        this.gridLayer = LW.gridLayer(gridModel,gridOptions);
        this.addLayer(this.gridLayer);

        this.setLegendData(this.options.legendData);
    },

    /**
     * 设置图层数据，并绘制
     * @method setData
     * @param data {Array}
     */
    setData: function (data) {
        this.gridLayer.setData(data);
    },

    /**
     * 清除图层
     * @method clear
     */
    clear: function () {
        this.setData(null);
        this.flowWindLayer.clear();
        this.gridLayer.clear();
    },

    /**
     * 重置遮罩
     * @param maskGeoJson
     */
    resetMask:function (maskGeoJson) {
        this.flowWindLayer.resetMask(maskGeoJson);
        this.gridLayer.resetMask(maskGeoJson);
    },

    /**
     * 重置图例
     * @param legendData
     */
    setLegendData: function (legendData) {
        this.flowWindLayer.setLegendData(legendData);
        this.gridLayer.setLegendData(legendData);
    },

    /**
     * 重设flowWindLayer的options
     * @param options
     */
    setFlowOptions:function (options){
        L.setOptions(this.flowWindLayer,options);
        this.flowWindLayer._update();
    },

    /**
     * 设置填色的显隐
     * @param visible
     */
    setFillVisible:function(visible){
        this.flowWindLayer.setFillVisible(visible);
    },

    /**
     * 设置流场线显隐
     * @method setFlowWindVisible
     * @param value {boolean} 显隐值
     */
    setFlowWindVisible: function (value) {
        // this.flowWindLayer.options.flowWind=value;
        // this.flowWindLayer._update();
        this.flowWindLayer.setFlowWindVisible(value);
    },

    /**
     * 设置格点要素显隐
     * @method setFlowWindVisible
     * @param element {string} eg:'value'/'wind'/'arrow'
     * @param value {boolean} 显隐值
     */
    setGridElementVisible: function (element,visible) {
        this.gridLayer.setGridElementVisible(element,visible);
    }
});

/**
 *
 * @class LW.FlowWindGridLayer
 * @constructor
 * @param gridModel {LW.GridModel|LW.GridModelManager} 格点数据模型
 * @param options {object} 外部属性，可重设Properties
 * @param layers {object} 初始图层，可以不传
 * @returns {LW.FlowWindGridLayer}
 */
LW.flowWindGridLayer = function (gridModel,options, layers) {
    return new LW.FlowWindGridLayer(gridModel,options, layers);
};

/**
 * 数值预报图层风流场
 *
 * Features :
 *      1. 包括色斑图和流线，但是如果需要性能比较好，建议只有该图层的流线，色斑图用gradientGlLayer
 *      2. 支持风流线和浪场
 *
 * @class LW.FlowWindLayer
 * @extends LW.GradientLayer
 */
LW.FlowWindLayer = LW.GradientLayer.extend({
    options: {
        /**
         * 是否有流线
         * @property flowWind
         * @type {boolean}
         * @default true
         */
        flowWind: true, //是否有流场
        /**
         * 是否是彩色流线
         * @property flowWindColorful
         * @type {boolean}
         * @default true
         */
        flowWindColorful: true, //是否是彩色流线
        /**
         * 是否有色斑图
         * @property contour
         * @type {boolean}
         * @default false
         */
        contour:false,
        /**
         * 是否是浪
         * @property isWave
         * @type {boolean}
         * @default false
         */
        isWave:false,
        /**
         * 格点场渲染间隔，只有风场时配置5，有色斑图时配置2
         * @property gap
         * @type {int}
         * @default 5
         */
        gap:5,
        /**
         * 色斑图透明度
         * @property opacity
         * @type {number}
         * @default 0.9
         */
        opacity: 0.9,//对比度
        /**
         * 调节流线长度，流场推荐0.7-0.97之间
         * @property fadeOpacity
         * @type {number}
         * @default 默认流场0.87，浪场0.75
         */
        fadeOpacity:null,
        /**
         * 调节流线线宽
         * @property lineWidth
         * @type {number}
         * @default 1
         */
        lineWidth:1,
        /**
         * 最大强度
         * @property maxIntensity
         * @type {number}
         * @default 0.7
         */
        maxIntensity: 0.7,
        /**
         * 调节流线快慢
         * @property speedScale
         * @type {number}
         * @default 0.15
         */
        speedScale: 0.15,
        /**
         * 调节线条密度
         * @property particleMultiplier
         * @type {number}
         * @default 3
         */
        particleMultiplier: 3
    },

    NULL_VECTOR: [NaN, NaN, null],

    _containsPoint: L.Util.falseFn,

    initialize: function (gridModel,options) {
        LW.GradientLayer.prototype.initialize.call(this,gridModel,options);
        this.flowWindRender = this.options.flowWindRender || LW.noTranslateCanvas();
    },

    onAdd: function () {
        this._renderer = this._map.getRenderer(this);
        this.setFlowWindVisible(this.options.flowWind);
    },
    onRemove: function () {
        if (this._map.hasLayer(this._renderer))
            this._map.removeLayer(this._renderer);
        this.removeRenderer(this.flowWindRender);
    },

    /**
     * 设置渐变色斑底图显隐
     * @method setFillVisible
     * @param value
     */
    setFillVisible: function(value){
        // this[value?'addRenderer':'removeRenderer'](this._renderer);
        if(this.options.contour !== value){
            this.options.contour = value;
            this._update();
        }
    },

    /**
     * 设置流线显隐
     * @method setFlowWindVisible
     * @param value
     */
    setFlowWindVisible: function (value) {
        this.options.flowWind = value;
        this[value?'addRenderer':'removeRenderer'](this.flowWindRender);
        if(value)
            this._update();
    },

    addRenderer: function (renderer) {
        if (this._map && !this._map.hasLayer(renderer))
            this._map.addLayer(renderer);
    },

    removeRenderer: function (renderer) {
        if (this._map && this._map.hasLayer(renderer))
            this._map.removeLayer(renderer);
    },

    /**
     * 清空
     * @method clear
     */
    clear: function () {
        if(this._renderer){
            var size = this.size = this._renderer._bounds.getSize();
            this._renderer._ctx.clearRect(0, 0, size.x, size.y);
        }
        if(this.flowWindRender){
            if(this.animation)
                this.animation.field.cancel = true;
            var bounds = this.flowWindRender._bounds;
            if(bounds){
                var size = this.size = bounds.getSize();
                this.flowWindRender._ctx.clearRect(0, 0, this.size.x, this.size.y);
            }
        }
    },

    showProduct:function () {
        LW.GradientLayer.prototype.showProduct.call(this);
        if(this.options.flowWind)
            this._frameAnimate();
    },

    _frameAnimate:function(){
        this.animation = this._createAnimation();
    },

    _createAnimation: function(){
        var options = this.options,cBounds = this.cBounds,map = this._map;
        var ctx = this.flowWindRender._ctx,size = this.size;

        var animation = {};

        var field = animation.field = createField(this.columns,this.cBounds);
        animate(field);

        function createField (columns, bounds) {
            function field(x, y) {
                var column = columns[Math.round(x)];
                return column && column[Math.round(y)] || [NaN, NaN, null];
            }

            field.isDefined = function (x, y) {
                return field(x, y)[2] !== null;
            };

            field.release = function () {
                columns = [];
            };

            field.randomize = function (o) {  // UNDONE: this method is terrible
                var x, y;
                var safetyNet = 0;
                do {
                    x = Math.round(Sun.Util.Math.random(bounds.x, bounds.xMax));
                    y = Math.round(Sun.Util.Math.random(bounds.y, bounds.yMax));
                } while (!field.isDefined(x, y) && safetyNet++ < 2);
                o.x = x;
                o.y = y;
                return o;
            };

            field.cancel = false;

            return field;
        }

        function animate (field) {

            var INTENSITY_SCALE_STEP = 10;
            var PARTICLE_MULTIPLIER = options.particleMultiplier;//调节线条密度
            var PARTICLE_REDUCTION = 0.75;
            var FRAME_RATE = 40;
            var bounds = cBounds;
            var MAX_PARTICLE_AGE,fadeFillStyle,evolve;

            if (options.isWave) {
                MAX_PARTICLE_AGE = 40;
                evolve = evolveWaves;
                fadeFillStyle ="rgba(0, 0, 0,"+(options.fadeOpacity||0.75)+")";
            } else {
                MAX_PARTICLE_AGE = 20;
                evolve = evolveParticles;
                fadeFillStyle = "rgba(0, 0, 0,"+(options.fadeOpacity||0.87)+")"; // FF Mac alpha behaves oddly
            }
            // maxIntensity is the velocity at which particle color intensity is maximum
            var colorStyles = options.flowWindColorful ? windIntensityColorfulScale() :
                windIntensityColorScale(INTENSITY_SCALE_STEP,options.maxIntensity);
            var buckets = colorStyles.map(function () {
                return [];
            });
            var particleCount = Math.round(bounds.width * PARTICLE_MULTIPLIER);
            if (L.Browser.mobile) {
                particleCount *= PARTICLE_REDUCTION;
            }
            // var fadeFillStyle = Sun.Util.Common.isFF() ? "rgba(255, 255, 255, 0.95)" : "rgba(255, 255, 255, 0.97)";  // FF Mac alpha behaves oddly

            var particles = [];
            for (var i = 0; i < particleCount; i++) {
                particles.push(field.randomize({age: Sun.Util.Math.random(0, MAX_PARTICLE_AGE)}));
            }

            var scale = map.getZoom();
            var easeFactor = new Float32Array(MAX_PARTICLE_AGE);
            for (var k = 0; k < easeFactor.length; k++) {
                easeFactor[k] = Math.sin(-Math.PI / 2 + k / 7) / 2 + 1 / 2; // fade in/out line intensity
            }
            function evolveWaves(){
                var adj = 200 / scale * Math.pow(Math.log(scale) / Math.log(200), 2.5); // use shallower exponential speed scale

                buckets.forEach(function (bucket) {
                    bucket.length = 0;
                });
                particles.forEach(function (particle) {
                    if (particle.age >= MAX_PARTICLE_AGE) {
                        field.randomize(particle).age = 0;
                    }
                    var x = particle.x;
                    var y = particle.y;
                    var v = field(x, y);  // graph at current position
                    var dx = v[0];
                    var dy = v[1];
                    var m  = v[2];
                    var xt = x + dx * adj;
                    var yt = y + dy * adj;
                    if (m === null || !field.isDefined(xt, yt)) {
                        particle.age = MAX_PARTICLE_AGE;  // particle has escaped the grid, never to return...
                    }
                    else {
                        // Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.
                        particle.x = xt;
                        particle.y = yt;

                        var mag = Math.sqrt(dx * dx + dy * dy) / 2.5;
                        dx /= mag;
                        dy /= mag; // Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.

                        var si = colorStyles.indexFor(m * easeFactor[particle.age]);
                        buckets[si].push({
                            age:particle.age,
                            x:x - dy,
                            y:y + dx,
                            xt:x + dy,
                            yt:y - dx
                        });
                    }
                    particle.age += 1;
                });
            }

            function evolveParticles() {
                buckets.forEach(function (bucket) {
                    bucket.length = 0;
                });
                particles.forEach(function (particle) {
                    if (particle.age > MAX_PARTICLE_AGE) {
                        field.randomize(particle).age = 0;
                    }
                    var x = particle.x;
                    var y = particle.y;
                    var v = field(x, y);  // graph at current position
                    var m = v[2];
                    if (m === null) {
                        particle.age = MAX_PARTICLE_AGE;  // particle has escaped the grid, never to return...
                    }
                    else {
                        var xt = x + v[0];
                        var yt = y + v[1];
                        if (field.isDefined(xt, yt)) {
                            // Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.
                            particle.xt = xt;
                            particle.yt = yt;
                            buckets[colorStyles.indexFor(m)].push(particle);
                        }
                        else {
                            // Particle isn't visible, but it still moves through the field.
                            particle.x = xt;
                            particle.y = yt;
                        }
                    }
                    particle.age += 1;
                });
            }

            function draw() {
                ctx.fillStyle = fadeFillStyle;
                ctx.lineWidth = options.lineWidth;
                ctx.globalAlpha = 1;
                // Fade existing particle trails.
                var prev = ctx.globalCompositeOperation;
                ctx.globalCompositeOperation = "destination-in";
                ctx.fillRect(0, 0, size.x, size.y);
                ctx.globalCompositeOperation = prev;
                ctx.globalAlpha = options.opacity;

                // Draw new particle trails.
                buckets.forEach(function (bucket, i) {
                    if (bucket.length > 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = colorStyles[i];
                        bucket.forEach(function (particle) {
                            ctx.moveTo(particle.x, particle.y);
                            ctx.lineTo(particle.xt, particle.yt);
                            particle.x = particle.xt;
                            particle.y = particle.yt;
                        });
                        ctx.stroke();
                    }
                });
            }

            function windIntensityColorScale (step, maxWind) {
                var result = [];
                for (var j = 185; j <= 255; j += step) {
                    result.push(Sun.Util.Color.asColorStyle(j, j, j, 1));
                }
                result.indexFor = function (m) {  // map wind speed to a style
                    return Math.floor(Math.min(m, maxWind) / maxWind * (result.length - 1));
                };
                return result;
            }

            function windIntensityColorfulScale () {
                var legendData =options.legendData;
                var result = [];
                for (var i = 0; i < legendData.length; i++) {
                    result.push(legendData[i].color);
                }
                result.indexFor = function (m) {  // map wind speed to a style
                    return Sun.Util.LegendData.getColorIndex(legendData, m);
                };
                return result;
            }

            (function frame() {
                try {
                    if (field.cancel) {
                        field.release();
                        return;
                    }
                    evolve();
                    draw();
                    setTimeout(frame, FRAME_RATE);
                }
                catch (e) {
                    console.log(e);
                }
            })();
        }

        return animation;
    }
});

LW.flowWindLayer = function (gridModel,options) {
    return new LW.FlowWindLayer(gridModel,options);
};




/**
 * 数据模型
 * @module Layer.Plot
 */
/**
 * 网格图层
 *
 * Features :
 *      1. 根据网格模型填色、填值、风杆等
 *      2. 可设置遮罩
 *
 * Update Note：
 *      + v1.1.0-dev ：Created
 *      + v1.3.0-dev ：将格点值图层和格点填色图层分为两个渲染器渲染
 *      + v1.4.2 : 1. 增加渲染器为L.canvas的支持,为了支持padding属性，提升视觉体验。
 *                 2. 增加网格合并绘制的功能，提升性能体验。
 *                 3. 改变视区外网格过滤的计算，提升性能体验。
 *      + v1.4.7 : 将遮罩改为在渲染器中设置
 *      + v1.5.2 : 增加网格线显示的配置
 *      + v1.5.3 : 1. setDataRange的支持可以仅显示定值的功能
 *                 2. 填色渲染的一些性能优化
 *                 3. 增加网格风杆描边的配置
 *      + v1.5.4 : 1. 增加可外部配置值处理方法的功能，对应的属性为valueFn
 *                 2. 增加pattern填充的功能，需要sun@1.0.24支持
 *      + v1.5.5 : 1. 修复mergerDraw时，图层的过滤显示异常的问题
 *
 * @class LW.GridLayer
 * @extends LW.CanvasLayer
 * @demo demo/gridEdit/gridEdit.html {格点编辑}
 */
LW.GridLayer = LW.CanvasLayer.extend({
    options:{
        /**
         * 格点的要素，可有数值--value,风杆--wind,网格填色--fill,箭头--arrow
         * @property elements
         * @type {Array}
         * @default ['value']
         */
        elements:['value'],
        /**
         * 要素的显影
         * @property elements
         * @type {Object}
         * @default {value:true,wind:false,fill:false,arrow:false}
         */
        elementsVisible:{value:true,wind:false,fill:false,arrow:false},

        /**
         * 是否展示网格线
         * @type {Boolean}
         * @property gridLine
         * @default false
         */
        gridLine:false,

        /**
         * 单个网格线展示
         * @type {Boolean}
         * @property gridEachLine
         * @default false
         */
        gridEachLine:false,

        /**
         * 网格线颜色
         * @type {string}
         * @property gridLineColor
         * @default '#73B4F2'
         */
        gridLineColor:'#73B4F2',

        /**
         * 网格线显示等级范围
         * @type {Array}
         * @property gridLineZooms
         * @default [6,18]
         */
        gridLineZooms:[6,18],
        /**
         * 图例数据
         * @property elements
         * @type {Array}
         */
        legendData:[],
        /**
         * 格点值颜色
         * @type {String}
         * @property valueColor
         * @default '#222'
         */
        valueColor: '#222',
        /**
         * 格点值描边
         * @type {boolean|String}
         * @property valueStroke
         * @default false
         */
        valueStroke: false,
        /**
         * 显示值的方法，即对数据传过来的值不直接展示，而是加工后展示，可以用该方法实现
         * 如可视化需求：降水0不展示，其他降水值向下取整。其他要素均展示向下取整
         * @property valueFn
         * @type {function}
         * @default null
         */
        valueFn:null,
        /**
         * 格点值字体
         * @type {String}
         * @property font
         * @default '14px  Microsoft YaHei'
         */
        font:'14px Microsoft YaHei',

        /**
         * 异常网格的样式，gridItem中值为{value:value,abnormal:true}将应用该样式,eg: { element: color,... }
         * @type {Object}
         * @property abnormalStyle
         * @default null
         */
        abnormalStyle: {value:null},
        /**
         * 格点风是否根据色谱填色
         * @type {Boolean}
         * @property gridWindColorful
         * @default false
         */
        gridWindColorful:false,
        /**
         * 格点风线宽
         * @type {Int}
         * @property windWidth
         * @default 1
         */
        gridWindLineWidth:1,
        /**
         * 网格风是否描边 eg:false|'#fff'
         * @type {boolean|string}
         * @property gridWindStroke
         * @default false
         */
        gridWindStroke:false,
        /**
         * 网格风是否描边
         * @type {int}
         * @property gridWindStrokeWidth
         * @default 3
         */
        gridWindStrokeWidth:3,
        /**
         * 格点最小间隔的宽度，单位px
         * @property distanceWidth
         * @type {Number}
         * @default 40
         */
        distanceWidth: 40,

        /**
         * 格点位置
         *      1. 'center'--格点的中心为格点的经纬度
         *      2. 'leftbottom'--格点的左下为格点的经纬度
         * @property gridPosition
         * @type {string}
         * @default 'center'
         */
        gridPosition:'center',

        /**
         * 格点的最大最小等级
         */
        gridZooms:[3,18],

        /**
         * 是否网格合并绘制，以提高性能
         * @property mergerDraw
         * @type {Boolean}
         * @default true
         */
        mergerDraw:true,
        /**
         * 网格渲染器
         * Tip:一个渲染器即一个canvas，若项目中有多个这个图层，一定要新建渲染器
         * @property renderer
         * @type {LW.Canvas}
         * @default LW.canvas()
         */
        renderer:LW.canvas(),
        /**
         * 填色渲染器
         * Tip:一个渲染器即一个canvas，若项目中有多个这个图层，一定要新建渲染器
         * @property fillRenderer
         * @type {LW.Canvas}
         * @default LW.canvas()
         */
        fillRenderer:LW.canvas()
    },

    range:{
        min:NaN,
        max:NaN
    },

    initialize:function (gridModel,options) {
        L.setOptions(this, options);
        if(this.options.elements.indexOf('fill')!=-1){
            this._fillRenderer = this.options.fillRenderer;
        }
        this.gridModel = gridModel;
        var self = this;
        this.gridModel.on('transform',function(){
            self._update();
        });
    },
    beforeAdd: function (map) {
        this._map = map;
        if (this._fillRenderer && !this._map.hasLayer(this._fillRenderer))
            this._map.addLayer(this._fillRenderer);
        L.Path.prototype.beforeAdd.call(this,map);
    },

    onRemove: function () {
        LW.CanvasLayer.prototype.onRemove.call(this);
        if (this._fillRenderer && this._map.hasLayer(this._fillRenderer))
            this._map.removeLayer(this._fillRenderer);
    },

    clear: function () {
        if(this._renderer){
            var bounds = this._renderer._bounds,size = bounds.getSize();
            if(this._renderer instanceof LW.NoTranslateCanvas)
                bounds = L.bounds([0,0],size);
            this._renderer._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
        }
        if(this._fillRenderer)
            this._fillRenderer._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
    },

    /**
     * 设置格点要素的显影
     * @method setGridElementVisible
     * @param element {String} 可选择options.elements中的要素
     * @param visible {Boolean}
     */
    setGridElementVisible: function (element,visible) {
        if(this.options.elementsVisible[element] !== visible){
            this.options.elementsVisible[element] = visible;
            this._update();
        }
    },

    /**
     * 设置图例数据
     * @method setLegendData
     * @param legendData
     */
    setLegendData: function (legendData) {
        this.options.legendData=legendData;
    },

    /**
     * 设置遮罩
     * @method setMask
     * @param mask
    */

    setMask:function(maskGeoJson){
        this.options.renderer.options.maskGeoJson = maskGeoJson;
        this.options.fillRenderer.options.maskGeoJson = maskGeoJson;
        this._update();
    },


    /**
     * 设置数据
     * @method setData
     * @param data {ArrayBuffer|json} 数据，可为nc流数据或者json数据
     * @param applyRegions {Array} [可选] 设置应用的区域
     *          一维网格。若设定区域时，指定区域对应的网格设置新的数据，非该指定的区域，保留原先网格值，需要有设置好的options.regionGrid
     * @param keepValidGrid {Boolean} [可选] 是否保留原先网格的有效值，若新数据的某个网格为无效值时，保留原先网格值
     * @param applyWindSpeed {Boolean} [可选] 该参数用于options.wind为true,但应用的数据只希望应用风速时使用
     */
    setData: function (data,applyRegions,keepValidGrid,applyWindSpeed) {
        if(!data){
            this.gridModel.data = null;
            this.clear();
            return;
        }
        if(data.isGrid)
            this.gridModel.resetGrid(data.grid,data.editedKeys);
        else if((data instanceof ArrayBuffer && data.byteLength>0) || Object.prototype.toString.call(data).toLowerCase()==="[object object]"){
            this.gridModel.setData(data,applyRegions,keepValidGrid,applyWindSpeed);
            // this._showBounds();
        }
    },

    _showBounds:function () {
        var data = this.gridModel.data.data;
        for(var key in data){
            var item = data[key];
            var bound = L.latLngBounds([[item.startlat,item.startlon],[item.endlat,item.endlon]]);
            L.rectangle(bound,{fill:false}).addTo(map);
            LW.labelMarker(bound.getCenter()).addTo(map).setData(key);
        }
    },

    /**
     * 重设模型的gird数据
     * @method resetGrid
     * @param grid {Array} 二维格点数据
     */
    resetGrid: function (grid) {
        this.gridModel.resetGrid(grid);
    },

    /**
     * 展示所有范围的值，用于setDataRange后恢复
     * @method showAllRange
     */
    showAllRange:function () {
        this.setDataRange({min:NaN,max:NaN});
    },

    /**
     * 设置数据展示区间.参数说明：
     *      1. range为object时，显示min/max之间的网格。eg:{min:NaN,max:NaN}
     *      2. range为array时，仅显示array中指定值。eg:[2,3]
     * @method setDataRange
     * @param range {object|Array}
     */
    setDataRange:function (range) {
        this.range=range;
        this._update();
    },

    _update: function () {
        if (this.gridModel.data && this._map) {
            // var t1 = new Date();
            this.clear();
            this._draw();
            // var t2 = new Date();
            // console.log('grid update:',(t2.getTime()-t1.getTime())/1000+'s');
        }
    },

    _draw : function () {
        var data = this.gridModel.data;
        var map = this._map,options = this.options,zoom = map.getZoom();
        var renderer = this._renderer,ctx = renderer._ctx,bounds = renderer._bounds;
        var range = this.range;
        var maskCoords = this.maskCoords;
        var transformFn = renderer instanceof LW.NoTranslateCanvas ? 'latLngToContainerPoint' : 'latLngToLayerPoint';
        if(renderer instanceof LW.NoTranslateCanvas)
            bounds = L.bounds([0,0],bounds.getSize());
        if(this._fillRenderer){
            var fillRenderer = this._fillRenderer;
            var fillCtx = this._fillRenderer._ctx;
            fillCtx.globalAlpha = options.opacity;
        }

        if(this.gridModel instanceof LW.GridModel){
            _drawData(data,this.gridModel);
            _setMask();
        }
        else if(this.gridModel instanceof LW.GridModelManager){
            for(var key in data.data){
                _drawData(data.data[key],this.gridModel.gridModels[key]);
            }
            _setMask();
        }

        function _drawData(data,gridModel) {
            if(data){
                var x0 = parseFloat(data.startlon), y0 = parseFloat(data.startlat);
                var x1 = parseFloat(data.endlon), y1 = parseFloat(data.endlat);
                var dx = parseFloat(data.nlon), dy = parseFloat(data.nlat);
                var xs = parseFloat(data.lonsize)-1,ys = parseFloat(data.latsize)-1;
                var _bounds = L.bounds(map[transformFn]([y0,x0]),map[transformFn]([y1,x1]));
                if(!_bounds.overlaps(bounds))
                    return;// 数据边界和视区边界无交集，无需绘制

                var grid = gridModel.grid;
                var continuous = gridModel.options.continuous;
                // var bIdx = getBoundIdx();
                var bIdx = gridModel.getRankByBounds(map.getBounds());
                if(_ElementVisible('fill'))
                    _eachDraw();
                if(options.gridLine && zoom >= options.gridLineZooms[0] && zoom <= options.gridLineZooms[1])
                    _drawLine();
                if(zoom >= options.gridZooms[0] && zoom <= options.gridZooms[1]){//zoom在规定的等级内
                    if((_ElementVisible('value') || _ElementVisible('wind') || _ElementVisible('arrow')))
                        _gapDraw();
                }
            }


            function _hasElement(element) {
                return options.elements.indexOf(element)!==-1;
            }

            function _ElementVisible(element) {
                return options.elements.indexOf(element)!==-1 && options.elementsVisible[element];
            }

            function _eachDraw() {
                for (var i = bIdx.row_min; i <= bIdx.row_max; i++) {
                    var row = grid[i],firstColumn = true;
                    for (var j = bIdx.column_min; j <= bIdx.column_max; j++) {
                        var gValue = _getValue(row[j]);
                        if (_isShowGrid(gValue.value) && !gridModel.isHide(row[j],i,j)) {
                            var lat = y0 + dy * i, lng = x0 + dx * j;
                            var latLng1 = options.gridPosition === 'center' ? L.latLng(lat - dy / 2, lng - dx / 2) : L.latLng(lat, lng);
                            var latLng2 = options.gridPosition === 'center' ? L.latLng(lat + dy / 2, lng + dx / 2) : L.latLng(lat + dy, lng + dx);

                            var p,p_next,dw,dh;

                            // if (p.x + Math.abs(dw) >= bounds.min.x && p.y + Math.abs(dh) >= bounds.min.y &&
                            //     p.x - Math.abs(dw) <= bounds.max.x && p.y - Math.abs(dh) <= bounds.max.y) {//在视区范围内
                                if(!options.mergerDraw){//Tip:不合并绘制每格单独计算w/h.合并绘制每行计算w/h
                                    _setCellSize();
                                    _drawRect(gValue, p, dw, dh);
                                }
                                else{
                                    var cellNext = j < bIdx.column_max ? row[j + 1] : null, cellPrev = j > bIdx.column_min ? row[j - 1] : null;
                                    var nextHide = cellNext!=null ? (!_isShowGrid(_getValue(cellNext).value) || gridModel.isHide(cellNext,i,j)) : false;// 之前用cellNext?A:B遗漏了0的判定
                                    var prevHide = cellPrev!=null ? (!_isShowGrid(_getValue(cellPrev).value) || gridModel.isHide(cellPrev,i,j)) : false;
                                    //var rowEnd = p.x >= bounds.max.x;// 边界一些奇怪的情况，不等有的时候最后无法画出，等于有的时候又会多绘制一次
                                    // var rowStart = j === bIdx.column_min;
                                    if(firstColumn)
                                        _setCellSize();
                                    _drawRect(gValue, p, dw, dh,options.mergerDraw,
                                        firstColumn || prevHide,j === bIdx.column_max  || nextHide,latLng1,latLng2);
                                    firstColumn = false;
                                    //if (rowEnd) break;
                                }
                            // }
                        }
                    }
                }

                function _setCellSize(){
                    // Tip1:由于麦卡托不同纬度下单位纬度间隔的距离不一致，所以需要每次重算，然而distanceTo方法太耗性能，所以用点的xy直接计算
                    // Tip2:理论上麦卡托单位间隔内的长度相等。但是计算出来是整数。存在精度误差。所以不能用单位宽度直接计算
                    p = map[transformFn](latLng1);
                    p_next = map[transformFn](latLng2);
                    dw = p_next.x - p.x;
                    dh = p_next.y - p.y;
                }
            }

            function _drawLine() {
                if (!fillCtx) return;
                fillCtx.strokeStyle = options.gridLineColor;
                fillCtx.lineWidth = 1;
                var row_max = bIdx.row_max+1,column_max = bIdx.column_max+1;
                for (var i = 0; i <= row_max; i++) {
                    var lat = y0 + dy * i, lng1 = x0 + dx * bIdx.column_min, lng2 = x0 + dx * column_max;
                    var latLng1 = options.gridPosition === 'center' ? L.latLng(lat - dy / 2, lng1 - dx / 2) : L.latLng(lat, lng1);
                    var latLng2 = options.gridPosition === 'center' ? L.latLng(lat - dy / 2, lng2 - dx / 2) : L.latLng(lat, lng2);
                    var p1 = map[transformFn](latLng1),
                        p2 = map[transformFn](latLng2);
                    fillCtx.moveTo(p1.x,p1.y);
                    fillCtx.lineTo(p2.x,p2.y);
                }
                for (var j = 0; j <= column_max; j++) {
                    var lat1 = y0 + dy * bIdx.row_min,lat2 = y0 + dy * row_max, lng = x0 + dx * j;
                    latLng1 = options.gridPosition === 'center' ? L.latLng(lat1 - dy / 2, lng - dx / 2) : L.latLng(lat1, lng);
                    latLng2 = options.gridPosition === 'center' ? L.latLng(lat2 - dy / 2, lng - dx / 2) : L.latLng(lat2, lng);
                    p1 = map[transformFn](latLng1);
                    p2 = map[transformFn](latLng2);
                    fillCtx.moveTo(p1.x,p1.y);
                    fillCtx.lineTo(p2.x,p2.y);
                }
                fillCtx.stroke();
            }

            function _gapDraw() {
                // 渲染间隔 Tip: map的latLngToLayerPoint是保留整数。计算的精度误差导致效果不好
                var p1 = latLngToLayerPoint(L.latLng(y0, x0));
                var p2 = latLngToLayerPoint(L.latLng(y0, x0 + dx));
                var d = p1.distanceTo(p2);
                var xi = options.distanceWidth / d;//Tip:因文本为横向，所以采用xi间隔，宽松点更好看
                xi = xi < 1 ? 1 : xi;
                xi = xi > (grid.length - 1) / 2 ? (grid.length - 1) / 2 : xi;
                xi = Math.ceil(xi);


                //Tip：为了保证拖动地图时，网格值不会因为起始不一致而跳动，导致体验不好，牺牲一点性能，索引不从row_min/column_min开始
                for (var i = 0; i <= bIdx.row_max; i += xi) {
                    var row = grid[i];
                    for (var j = 0; j <= bIdx.column_max; j += xi) {
                        var gValue = _getValue(row[j]);
                        if(_isShowGrid(gValue.value) && !gridModel.isHide(row[j],i,j)){
                            var latLng = L.latLng(y0 + dy * i, x0 + dx * j);
                            // var p = map.latLngToContainerPoint(latLng);
                            var p = map[transformFn](latLng);
                            if (p.x > bounds.min.x && p.y > bounds.min.y
                                && p.x < bounds.max.x && p.y < bounds.max.y) {
                                if (gridModel.options.wind && _hasElement('wind'))
                                    _drawWind(gValue, p);
                                else if(gridModel.options.wind && _hasElement('arrow'))
                                    _drawArrow(gValue,p);
                                else if(_hasElement('value'))
                                    _drawValue(gValue, p);
                            }
                        }
                    }
                }
            }

            function latLngToLayerPoint (latlng) {
                var projectedPoint = map.project(L.latLng(latlng));
                return projectedPoint._subtract(map.getPixelOrigin());
            }

            function getBoundIdx() {
                var tFn = renderer instanceof LW.NoTranslateCanvas ? 'containerPointToLatLng' : 'layerPointToLatLng';
                var latlngBounds = L.latLngBounds(map[tFn](bounds.min),map[tFn](bounds.max));
                var se = gridModel.get4GridsIndexByLatlng(latlngBounds.getSouthEast());
                var nw = gridModel.get4GridsIndexByLatlng(latlngBounds.getNorthWest());
                var row_min = Math.min(se.f_row,nw.f_row),
                    row_max = Math.max(se.c_row,nw.c_row),
                    column_min = Math.min(se.f_column,nw.f_column),
                    column_max = Math.max(se.c_column,nw.c_column);
                row_min  = row_min < 0 ? 0 : row_min;
                row_max  = row_max > ys ? ys : row_max;
                column_min  = column_min < 0 ? 0 : column_min;
                column_max  = column_max > xs ? xs : column_max;
                return {row_min:row_min,row_max:row_max,column_min:column_min,column_max:column_max};
            }

            function _isShowGrid(value) {
                return Sun.Util.isArray(range) ? getFixValueVisible() : getMinMaxVisible();

                function getFixValueVisible() {
                    return range.indexOf(value) != -1;
                }

                function getMinMaxVisible() {
                    if(isNaN(range.min) && isNaN(range.max))
                        return true;
                    else if(isNaN(range.min))
                        return value<=range.max;
                    else if(isNaN(range.max))
                        return value>=range.min;
                    else
                        return value>=range.min && value<=range.max;
                }
            }

            function _getValue(grid) {
                var value = typeof grid == "object" ? grid : {value:grid};
                var valid = !gridModel.isInvalid(value.value || value);
                value.valid = valid;
                // var value = {value:grid,valid:valid};
                if(gridModel.options.wind){
                // if(_hasElement('wind') || _hasElement('arrow')){
                    var wind = valid?Sun.Util.Weather.wind_getWindByUV(grid,data.precision):{speed:data.invalidValue,dir:data.invalidValue};
                    value = {value:wind.speed,dir:wind.dir,valid:valid};
                }
                return value;
            }

            function _drawValue(value, p,yOffset) {
                if (!ctx) return;
                if (options.elementsVisible.value){
                    yOffset = yOffset || 5;
                    ctx.font = options.font;
                    ctx.fillStyle = value.abnormal && options.abnormalStyle.value ? options.abnormalStyle.value :
                        (typeof options.valueColor == "function" ? options.valueColor(value) : options.valueColor);
                    ctx.textAlign = "center";
                    var value = options.valueFn ? options.valueFn(value) : value.value;
                    if (options.valueStroke) {
                        ctx.strokeStyle = options.valueStroke;
                        ctx.lineWidth = 2;
                        ctx.strokeText(value, p.x, p.y + yOffset);
                    }
                    ctx.fillText(value, p.x, p.y + yOffset);
                }
            }

            function _drawWind(value, p) {
                if (!ctx) return;
                _drawValue(value,p,10);
                ctx.lineWidth = options.gridWindLineWidth||1;
                ctx.strokeStyle = options.gridWindColorful?
                    Sun.Util.LegendData.getColorOfRangeLegend(options.legendData, value.value):options.valueColor;
                if (options.elementsVisible.wind && value.valid)
                    Sun.Util.Geometry.drawWindByPosition(ctx, value.value, value.dir, p,false,null,null,null,
                        options.gridWindStroke,options.gridWindStrokeWidth);
            }

            function _drawArrow(value, p) {
                if (!ctx) return;
                _drawValue(value,p,10);
                ctx.strokeStyle = options.valueColor;
                if (options.elementsVisible.arrow && value.valid)
                    Sun.Util.Geometry.drawArrow(ctx, p, value.dir-180);
            }

            var s_x,width,prevColor,p_start;
            function _drawRect(value,p,w,h,unionDraw,rowStart,rowEnd,latLng,latLng2) {
                if (!fillCtx) return;
                var getColorFun = continuous?Sun.Util.LegendData.getColorOfRangeLegend:Sun.Util.LegendData.getColor;
                var color = value.valid?getColorFun(options.legendData,value.value,'#ffffff00'):'#ffffff00';
                if(!unionDraw){
                    fillCtx.fillStyle = color.pattern || color;
                    fillCtx.fillRect(p.x, p.y,w,h/*-data.latSign*/);
                    if(options.gridEachLine && color != '#ffffff00'){
                        fillCtx.strokeStyle = options.gridLineColor;
                        fillCtx.strokeRect(p.x, p.y, w, h)
                    }
                }
                else{
                    if(rowStart)
                        _reset();
                    else if(getColor(prevColor) !== getColor(color)){
                        _draw();
                        _reset();
                    }
                    if(rowEnd && getColor(prevColor) === getColor(color))
                        _draw();
                }

                function _reset() {
                    p_start = latLng;
                    prevColor = color;
                }

                function getColor(c){
                    return c.color ? c.color : c;
                }

                function _draw() {
                    var c = prevColor.pattern || prevColor;
                    fillCtx.fillStyle = c;
                    if (c != '#ffffff00') {
                        p = map[transformFn](p_start);
                        var p_next = map[transformFn](rowEnd?latLng2:latLng);
                        var w = p_next.x - p.x;
                        fillCtx.fillRect(p.x, p.y, w, h/*-data.latSign*/);
                    }
                }
            }
        }

        function _setMask() {
            renderer.setMask();
            if(fillRenderer)
                fillRenderer.setMask();
        }
    }
});

/**
 * @class LW.GridLayer
 * @constructor
 * @param gridModel {LW.GridModel|LW.GridModelManager} 格点数据模型
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.GridLayer}
 */
LW.gridLayer = function (gridModel,options) {
    return new LW.GridLayer(gridModel,options);
};


/**
 * 经纬网格线图层
 *
 * Features :
 *      1. 根据配置的等级经纬间隔展示经纬线网格线
 *      2. 根据设置的文本范围展示经纬信息文本
 *
 * Update Note：
 *      + v1.5.2 : Created
 *      + v1.5.5 : 将文本由marker改为外部文本，为了适应文本在框外，地图仅显示框内的部门的需求。需要传入tickContainer。
 *      + v1.5.6 : 1. 删除labelBox的配置，由tickContainer的位置进行计算得到新的labelBox
 *                 2. 增加没有tickContainer时，由map的范围或指定的经纬范围定位label的功能
 *
 * @class LW.GridLineLayer
 * @extends L.FeatureGroup
 * @demo demo/plot/grid/gridline.html {经纬网格线}
 * @demo demo/plot/grid/gridline_noframe.html {经纬网格线_无框}
 *
 */
LW.GridLineLayer = L.FeatureGroup.extend({
    options: {
        /**
         * 经纬网格线的样式
         * @property style
         */
        style: {
            color: '#9a9a9a',
            weight: 1,
            dashArray:'5,5',
            opacity: 1,
            outOfBox:true,
            renderer:L.canvas()
        },
        /**
         * 经纬度文字的样式
         * @property labelStyle
         */
        labelStyle:{
            offset:{
                s:[0, -20],
                n:[0, 0],
                w:[5, -25],
                e:[-55, -25]
            },
            textAlign:{s:'left',n:'left',w:'left',e:'right'},
            visible:{s:true,n:true,w:true,e:true},
            scale:false,
            color:'#333',
            fontSize:'12px'
        },
        // /**
        //  * 所需要显示的经纬像素网格左上和右下的位置,相对于map的位置
        //  * @property labelBox
        //  * @type {Array}
        //  * @default [[100,100],[900,900]]
        //  */
        // labelBox:[[100,100],[900,900]],
        /**
         * 不同等级经纬间隔的显示配置
         * @property zoomInterval
         */
        zoomInterval: [//equalMin
            {min: 0, max: 2, interval: 20},
            {min: 2, max: 4, interval: 10},
            {min: 4, max: 6, interval: 5},
            {min: 6, max: 7, interval: 2},
            {min: 7, max: 9, interval: 1},
            {min: 9, max: 10, interval: 0.5},
            {min: 10, max: 11, interval: 0.2},
            {min: 11, max: 13, interval: 0.05},
            {min: 13, max: 14, interval: 0.02},
            {min: 14, max: 18, interval: 0.01}
        ]
    },

    initialize: function (tickContainer,map,options) {
        this.map = map;
        if(options && options.labelStyle)
            options.labelStyle = L.extend({}, this.options.labelStyle,options.labelStyle);
        if(options && options.style)
            options.style = L.extend({}, this.options.style,options.style);
        L.setOptions(this, options);
        this._layers = {};
        this.craticuleLayer = L.geoJSON(null,this.options.style).addTo(this);
        this.labelLayer = L.featureGroup().addTo(this);
        this.tickContainer = tickContainer;
        this.setLabelBox();
    },

    onAdd: function (map) {
        this._map = map;
        L.GeoJSON.prototype.onAdd.call(this,map);
        map.on('moveend', this._reset, this);
        this._reset();
    },

    onRemove: function (map) {
        L.GeoJSON.prototype.onRemove.call(this,map);
        map.off('moveend', this._reset, this);
        this._map = null;
    },

    /**
     * 设置网格线显隐
     * @method setLineVisible
     * @param visible {boolean}
     */
    setLineVisible:function(visible){
        if (visible && !this._map.hasLayer(this.craticuleLayer))
            this._map.addLayer(this.craticuleLayer)
        else if(!visible && this._map.hasLayer(this.craticuleLayer))
            this._map.removeLayer(this.craticuleLayer);
    },

    /**
     * 设置网格线样式
     * @method setLineStyle
     * @param style
     */
    setLineStyle:function(style){
        this.craticuleLayer.resetOptionsStyle(style);
    },

    /**
     * 设置文本样式
     * @method setLabelStyle
     * @param style
     */
    setLabelStyle:function(style){
        this.options.labelStyle = L.extend({}, this.options.labelStyle,style);
        this._reset();
    },

    /**
     * 根据tickContainer的样式设置需要显示的经纬像素网格左上和右下的位置
     * @method setLabelBox
     * @param update 是否刷新 {boolean}
     */
    setLabelBox:function(update,tickContainer){
        // this.options.labelBox = labelBox;
        if(tickContainer)
            this.tickContainer = tickContainer;
        else
            tickContainer = this.tickContainer;
        var map = this.map;

        if(tickContainer) {
            var left = tickContainer.offsetLeft - map._container.offsetLeft,
                top = tickContainer.offsetTop - map._container.offsetTop;
            // 按边框宽度是2来计算
            this.labelBox = [[left + 2, top], [left + tickContainer.offsetWidth, top + tickContainer.offsetHeight - 5]];
        }
        if(update)
            this._reset();
    },

    setBounds: function (bounds,update){
        this.tickContainer = null;
        this.frameBounds = L.latLngBounds(bounds);
        if(update)
            this._reset();
    },

    _reset: function(){
        var map = this._map;
        if(map){
            var zoom = map.getZoom(),labelBox = this.labelBox;
            var bounds = this.options.style.outOfBox || ! this.tickContainer ? map.getBounds() :
                L.latLngBounds(map.containerPointToLatLng(labelBox[0]),map.containerPointToLatLng(labelBox[1]));
            if(!bounds.equals(this.mapBounds)){
                this.mapBounds = bounds;
                var zoomInterval = this.options.zoomInterval;
                var interval;
                for(var i=0;i<zoomInterval.length;i++){
                    var item = zoomInterval[i];
                    if(zoom>=item.min && zoom<item.max){
                        interval = item.interval;
                        break;
                    }
                }
                var data = this.data = interval ? this._getGraticule(interval,bounds) : null;
                this.craticuleLayer.setData(data);
            }

            var left = map._container.offsetLeft,top = map._container.offsetTop;
            var labelBounds = !this.tickContainer ? (this.frameBounds || map.getBounds()) :
                L.latLngBounds(map.containerPointToLatLng(labelBox[0]),map.containerPointToLatLng(labelBox[1]));
            this._setLabelData(this.data,labelBounds);
        }
    },

    _setLabelData: function(data,bounds){
        this.labelLayer.clearLayers();
        var tickContainer = this.tickContainer;
        if(tickContainer){
            var labelBox = this.labelBox;
            L.DomUtil.empty(tickContainer);
        }
        var map = this._map;
        if(data && map){
            var self = this,style = this.options.labelStyle;
            for(var i=0;i<data.features.length;i++){
                var item = data.features[i];
                var name = item.properties.name,text = '';
                if(isDir(name,'E')|| isDir(name,'W')){
                    text = isDir(name,'WE') ? '0' : (isDir(name,'W') ? name.slice(1) : name);
                    if(style.visible.s)
                        addLabel([bounds.getSouth(),parseFloat(name)],style.offset.s,style.textAlign.s,text,90);
                    if(style.visible.n)
                        addLabel([bounds.getNorth(),parseFloat(name)],style.offset.n,style.textAlign.n,text,90,[4,0]);
                }
                else if(isDir(name,'S')|| isDir(name,'N')){
                    text = isDir(name,'NS') ? '0' : (isDir(name,'S') ? name.slice(1) : name);
                    if(style.visible.w)
                        addLabel([parseFloat(name),bounds.getWest()],style.offset.w,style.textAlign.w,text,0,[0,4]);
                    if(style.visible.e)
                        addLabel([parseFloat(name),bounds.getEast()],style.offset.e,style.textAlign.e,text);
                }
            }
        }

        function isDir(name,dir) {
            return name.indexOf(dir) !== -1;
        }

        function addLabel(latlng, offset, textAlign,text, rotation, anchor) {
            if(bounds.contains(latlng)){
                if(tickContainer){
                    var point = map.latLngToContainerPoint(latlng);
                    var label = L.DomUtil.create('p','',tickContainer);
                    var offsetX = offset[0]-labelBox[0][0];
                    var offsetY = offset[1]-labelBox[0][1];
                    label.style.marginLeft = offsetX + 'px';
                    label.style.marginTop  = offsetY + 'px';
                    label.style.textAlign  = textAlign;
                    L.DomUtil.setPosition(label,point);
                    label.innerText = text;
                }
                else{
                    var options = L.extend({iconAnchor: offset,textAlign:textAlign},
                        {color: style.color,fontSize:style.fontSize,edge:false});
                    LW.labelMarker(latlng,{iconOptions: options}).setData(text).addTo(self.labelLayer);
                }
                if(style.scale)
                    LW.labelMarker(latlng,{iconOptions: {color: style.color,iconSize: L.point(8, 8),iconAnchor: L.point(anchor)}})
                        .setData('━',rotation).addTo(self.labelLayer);
            }
        }
    },

    _getFrame: function() {
        return { "type": "Polygon",
            "coordinates": [
                this._getMeridian(-180).concat(this._getMeridian(180).reverse())
            ]
        };
    },

    _getGraticule: function (interval,bounds) {
        var features = [];

        var w = bounds.getWest(),e = bounds.getEast(),s = bounds.getSouth(),n=bounds.getNorth(),gap = interval;
        if(interval<1){
            var precision = (1/interval).toString().length;
            w = w*10*precision,e=e*10*precision,s=s*10*precision,n=n*10*precision;
            gap = gap*10*precision;
        }
        // Meridians
        var lng0 = Math.ceil(w/gap)*interval,lng1 = Math.floor(e/gap)*interval;
        for (var lng = lng0; lng <= lng1; lng = lng + interval) {
            if(interval<1)
                lng = Sun.Math.round(lng,precision);
            features.push(this._getFeature(this._getMeridian(lng), {
                "name": lng.toString() + (lng ? (lng>0?'E':'W'):'WE')
            }));
        }

        // Parallels
        var lat0 = Math.ceil(s/gap)*interval,lat1 = Math.floor(n/gap)*interval;
        for (var lat = lat0; lat <= lat1; lat = lat + interval) {
            if(interval<1)
                lat = Sun.Math.round(lat,precision);
            features.push(this._getFeature(this._getParallel(lat), {
                "name": lat.toString() + (lat ? (lat>0?'N':'S'):'NS')
            }));
        }

        return {
            "type": "FeatureCollection",
            "features": features
        };
    },

    _getMeridian: function (lng) {
        lng = this._lngFix(lng);
        var coords = [];
        var bounds = this.mapBounds;
        var start = bounds.getSouth(), end = bounds.getNorth(),
        // var start = -90, end = 90,
            gap = (end-start)/2;
        for (var i = 0; i <= 2; i++) {//若是兰伯特投影，则经纬应为间隔1，加密经纬线的点集
            coords.push([lng, start+gap*i]);
        }
        return coords;
    },

    _getParallel: function (lat) {
        var coords = [];
        var bounds = this.mapBounds;
        var start = bounds.getWest(), end = bounds.getEast(),
            // var start = -180, end = 180,
            gap = (end-start)/2;
        for (var i = 0; i <= 2; i++) {
            var lng = start+gap*i;
            coords.push([this._lngFix(lng), lat]);
        }
        return coords;
    },

    _getFeature: function (coords, prop) {
        return {
            "type": "Feature",
            "geometry": {
                "type": "LineString",
                "coordinates": coords
            },
            "properties": prop
        };
    },

    _lngFix: function (lng) {
        if (lng >= 180) return 179.999999;
        if (lng <= -180) return -179.999999;
        return lng;
    }

});
/**
 * @class LW.GridLineLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.GridLineLayer}
 */
LW.gridLineLayer = function (tickContainer,map,options) {
    return new LW.GridLineLayer(tickContainer,map,options);
};


/**
 * 多等值线图层
 *
 * Features :
 *      1. 基于micaps14类数据
 *      2. 支持不闭合曲线
 *      3. 闭合曲线仅填色，暂不支持透明度设置，因为没有挖洞，设置透明度后颜色不正常
 *
 * Update Note：
 *      + v1.5.3 ：Created
 *      + v1.5.4 ：增加闭合曲线填色
 *
 * @class LW.MultiIsolineLayer
 * @extends L.FeatureGroup
 * @demo demo/plot/micaps/isoline.html {等值线}
 * @demo demo/plot/micaps/contour.html {等值面}
 * @demo demo/plot/micaps/symbolLines.html {标志线}
 */
LW.MultiIsolineLayer = L.FeatureGroup.extend({
    options:{
        elements:{
            // height: {color: '#333'},
            // tmp: {color: '#BD4F58'}
        },
        dashArray:'5,10',
        renderer: L.canvas()
    },

    initialize:function (options) {
        L.setOptions(this, options);
        L.FeatureGroup.prototype.initialize.call(this);

        // 线图层
        this.lineLayer = L.featureGroup().addTo(this);

        // 标注图层
        for(var key in this.options.elements){
            var element = this.options.elements[key];
            var labelLayer = LW.csLabelLayer({textMinZoom:0,name_color:element.color,name_offset:{x:0,y:4},
                renderer: LW.canvas({pane: 'markerPane'})}).addTo(this);
            element.labelLayer = labelLayer;
        }
    },

    /**
     * 设置数据，线和面分开是为了适应多种线，一种面的情况
     * @param isolineData {Object|null} eg:{height:{},tmp:{}} Tips:数据中key需与options.element中的key一一对应
     * @param isoPlaneData {Object|null} eg:{planes:[],legend:[]}
     */
    setData:function (isolineData,isoPlaneData) {
        this.clear();
        this._setIsoline(isolineData);
        this._setIsoplane(isoPlaneData);
    },


    setSymbolLines:function (source){
        this.clear();
        this._setSymbols(source);
        this._setSymbolLine(source);
    },

    clear:function () {
        this.lineLayer.clearLayers();
        for(var key in this.options.elements){
            var element = this.options.elements[key];
            element.labelLayer.setData(null);
        }
    },

    _setIsoline:function (source){
        if(source){
            for(var key in source){
                var data = source[key],element = this.options.elements[key];
                if(data && element){
                    var labelData = [];
                    for(var i=0; i<data.lines.length; i++){
                        var o = data.lines[i];
                        var value = o.points.value;
                        var options = {closed:false,fill:false,weight:o.lines.lineWidth,color:element.color,
                            dashArray:value>=0?null:this.options.dashArray};
                        options.renderer = this.options.renderer;
                        var spline = LW.cSpline(o.lines.data, options).addTo(this.lineLayer);
                        for(var j=0; j<o.points.data.length;j++){
                            var latlng = o.points.data[j];
                            labelData.push({NAME:value,LOCATION:[[latlng[1],latlng[0]]]});
                        }
                    }
                    element.labelLayer.setData(labelData);
                }
            }
        }
    },

    _setIsoplane:function (source){
        if(source){
            var data = source.planes,legend = source.legend,element = this.options.elements.fill;
            var labelData = [];
            for(var i=0; i<data.length; i++){
                var o = data[i];
                var value = o.points.value;
                var color = Sun.Util.LegendData.getColorOfRangeLegend(legend,value);
                var options = {closed:true,fill:true,stroke:false,fillOpacity: 1,fillColor:color,
                    dashArray:value>=0?null:this.options.dashArray};
                options.renderer = this.options.renderer;
                var spline = L.polygon(o.lines.data, options).addTo(this.lineLayer);
            }
        }
    },

    _setSymbols:function (source){
        var data = source.symbols;
        for(var i=0;i<data.length;i++){
            var item = data[i];
            var text = item.code == '160' ? 'H' : 'L';
            var html = ('<div style="text-align: center;font-weight: bold;color: {2}">' +
                '<p style="font-size: 30px;margin: -10px 0;">{0}</p>' +
                '<span style="font-size:18px;text-decoration:underline">{1}</span></div>')
                .format(text,item.str,item.code == '160'?'blue':'red');
            L.marker(item.latlng,{icon:L.divIcon({
                    iconSize: [100, 100],
                    html: html,
                    className: ''
            })}).addTo(this.lineLayer);
        }
    },

    _setSymbolLine:function (source){
        var data = source.symbolLines_withProp;
        for(var i=0;i<data.length;i++){
            var item = data[i].lines;
            var code = item.code,color = Sun.Color.rgbToHex(item.r,item.g,item.b);
            var options = {closed:false,fill:false,weight:item.lineWidth,color:color}
            options.renderer = this.options.renderer;
            switch (code) {
                case "0":
                    L.polyline(item.data, options).addTo(this.lineLayer);
                    break;
                case "1102":
                    options.weight = item.lineWidth*3;
                    options.doubleLine = item.lineWidth;
                    options.lineCap = 'butt';
                    L.polyline(item.data, options).addTo(this.lineLayer);
                    break;
                case "1115":
                    L.polyline(item.data, options)
                        .arrowheads({size: '10px', fill:true,frequency: 'endonly'}).addTo(this.lineLayer);
                    break;
            }
        }
    }
});

/**
 * @class LW.MultiIsolineLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.MultiIsolineLayer}
 */
LW.multiIsolineLayer = function (options) {
    return new LW.MultiIsolineLayer(options);
};

/**
 * 图片模式填充图层
 *
 * Features :
 *      1. 通常用于降水相态和降水量的同时叠加
 *      2. 需要配置只能值的图片
 *
 * Update Note：
 *      + v1.5.3 ：Created
 *
 * @class LW.PatternLayer
 * @extends LW.CanvasLayer
 * @demo demo/plot/contour/gradientPphLayer.html {降水相态}
 * @demo demo/geometry/geojsonPattern.html {geojson模式填充}
 */
LW.PatternLayer = LW.CanvasLayer.extend({
    options:{
        /**
         * 图片地址配置
         * @property images
         * @type {Array}
         * @default [//2-雨夹雪 3-雪 4-冻雨
             {key:2,url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0VCODZDQjQ1NjQ2RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGRjExMjY3ODc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGRjExMjY3Nzc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNCQkRDNjM1NEEwMDkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNFQjg2Q0I0NTY0NkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6RbW9CAAAA5UlEQVR42pTSOwoCMRAG4E18IIL4ABsV7AQbbSwFwdrTeAA9Qk5jaamNgnew0UJQS5/xH3YCw4LuOPCxmd3MkGRjvfeR4BJ5KhvF4aDM4xrnRsNQFy4ewASWsIZzpAhq4H58n2oa0LMKQxjDArZw1awgnMEMVjym4vmX+Z6JN/FpGubEOInmlSAja+wfe87CCJrJl5qgZXehA0U4wIPO0CqLK9DnvAVtvgfeKlfQ4CYhepCXf0GzChmFsH1tA7reOZHXQ622wQWeIj+FXNtgDzu4wRE2cJdX2ShvLe37Da9wLh8BBgD4Q44I7/z87gAAAABJRU5ErkJggg=='},
             {key:3,url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0VCODZDQjQ1NjQ2RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1QUE4NjgyRDc2MDYxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1QUE4NjgyQzc2MDYxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNCQkRDNjM1NEEwMDkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNFQjg2Q0I0NTY0NkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7STpAeAAAAiUlEQVR42mL4//8/AxLuR+MTxEwMENAPxPxQtiCUTxyAmsQPxM5QF/gAsSAOG1PRxRhBmvCYX4jETkViz0Z3gSDU5n6oS/iJdQFy4AlCaX5SApOB0lhgBJtCAWAiUX0/uQbgTieEQplQOkEOA+zxjD9VFhLrApzphNjowplOGEiM936qpwOAAAMAwYTNPG09T/MAAAAASUVORK5CYII='},
             {key:4,url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0VCODZDQjQ1NjQ2RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGRjExMjY3NDc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGRjExMjY3Mzc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNCQkRDNjM1NEEwMDkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNFQjg2Q0I0NTY0NkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7iakEoAAAAiElEQVR42mL6//8/AxLuR+MTxEwMENAPxPxQtiCUTxSAGdAAxCZQtjUQNxFrACPI2XjkC4kxAOZskM3OQLwFiM8A8UdSvFAHxEeh7DNQLxEFWLA49SMxTkf3AtmAiUT1/eQagDOdEGsAznRCTBjgTSfEBiLOdEKsF3CmExYiDcCZTihOBwABBgDRB1kdZBYQngAAAABJRU5ErkJggg=='}
            ]
         */
        images:[//2-雨夹雪 3-雪 4-冻雨
            {key:2,url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0VCODZDQjQ1NjQ2RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGRjExMjY3ODc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGRjExMjY3Nzc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNCQkRDNjM1NEEwMDkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNFQjg2Q0I0NTY0NkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6RbW9CAAAA5UlEQVR42pTSOwoCMRAG4E18IIL4ABsV7AQbbSwFwdrTeAA9Qk5jaamNgnew0UJQS5/xH3YCw4LuOPCxmd3MkGRjvfeR4BJ5KhvF4aDM4xrnRsNQFy4ewASWsIZzpAhq4H58n2oa0LMKQxjDArZw1awgnMEMVjym4vmX+Z6JN/FpGubEOInmlSAja+wfe87CCJrJl5qgZXehA0U4wIPO0CqLK9DnvAVtvgfeKlfQ4CYhepCXf0GzChmFsH1tA7reOZHXQ622wQWeIj+FXNtgDzu4wRE2cJdX2ShvLe37Da9wLh8BBgD4Q44I7/z87gAAAABJRU5ErkJggg=='},
            {key:3,url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0VCODZDQjQ1NjQ2RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1QUE4NjgyRDc2MDYxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1QUE4NjgyQzc2MDYxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNCQkRDNjM1NEEwMDkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNFQjg2Q0I0NTY0NkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7STpAeAAAAiUlEQVR42mL4//8/AxLuR+MTxEwMENAPxPxQtiCUTxyAmsQPxM5QF/gAsSAOG1PRxRhBmvCYX4jETkViz0Z3gSDU5n6oS/iJdQFy4AlCaX5SApOB0lhgBJtCAWAiUX0/uQbgTieEQplQOkEOA+zxjD9VFhLrApzphNjowplOGEiM936qpwOAAAMAwYTNPG09T/MAAAAASUVORK5CYII='},
            {key:4,url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExODA4M0VCODZDQjQ1NjQ2RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGRjExMjY3NDc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGRjExMjY3Mzc2MTkxMUU4ODdCOThFQTZBRkM4MDc2RSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MDQ4MDExNzQwNzIwNjgxMTgwODNCQkRDNjM1NEEwMDkiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMTgwODNFQjg2Q0I0NTY0NkQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7iakEoAAAAiElEQVR42mL6//8/AxLuR+MTxEwMENAPxPxQtiCUTxSAGdAAxCZQtjUQNxFrACPI2XjkC4kxAOZskM3OQLwFiM8A8UdSvFAHxEeh7DNQLxEFWLA49SMxTkf3AtmAiUT1/eQagDOdEGsAznRCTBjgTSfEBiLOdEKsF3CmExYiDcCZTihOBwABBgDRB1kdZBYQngAAAABJRU5ErkJggg=='}
        ],
        renderer:L.canvas()
    },
    initialize:function (gridModel,options){
        L.setOptions(this, options);
        this.gridModel = gridModel;
        var self = this;
        this.gridModel.on('transform',function(){
            self._update();
        });
    },

    setData: function (data) {
        if(!data){
            this.gridModel.data = null;
            this.clear();
            return;
        }
        else
            this.gridModel.setData(data);
    },

    _update:function (){
        if (this.gridModel.data && this._map) {
            var t1 = new Date();
            this.clear();

            if(this.pattern)
                this._draw();
            else{
                var pattern = this.pattern = {};
                var self = this,options = this.options,len = options.images.length,count=0;
                options.images.forEach(function (item){
                    var img = new Image();
                    img.src = item.url;
                    img.onload = function (){
                        pattern[item.key] = self._renderer._ctx.createPattern(img, "repeat");
                        count++;
                        if(count == len)
                            self._draw();
                    }
                })
            }
            var t2 = new Date();
            console.log('pattern update:',(t2.getTime()-t1.getTime())/1000+'s');
        }
    },

    _draw : function () {
        var data = this.gridModel.data;
        var map = this._map,options = this.options;
        var renderer = this._renderer,ctx = renderer._ctx,bounds = renderer._bounds;
        var transformFn = renderer instanceof LW.NoTranslateCanvas ? 'latLngToContainerPoint' : 'latLngToLayerPoint';

        var x0 = parseFloat(data.startlon), y0 = parseFloat(data.startlat);
        var x1 = parseFloat(data.endlon), y1 = parseFloat(data.endlat);
        var dx = parseFloat(data.nlon), dy = parseFloat(data.nlat);
        var xs = parseFloat(data.lonsize)-1,ys = parseFloat(data.latsize)-1;
        var _bounds = L.bounds(map[transformFn]([y0,x0]),map[transformFn]([y1,x1]));
        if(!_bounds.overlaps(bounds))
            return;// 数据边界和视区边界无交集，无需绘制

        var ctx = this.options.renderer._ctx;
        var gridModel = this.gridModel;
        var grid = gridModel.grid;
        var bIdx = gridModel.getRankByBounds(map.getBounds());
        for (var r = bIdx.row_min; r <= bIdx.row_max; r++) {
            var r0 = grid[r+1],r1 = grid[r];
            if(r0 && r1){
                for (var c = bIdx.column_min; c <= bIdx.column_max; c++) {
                    var g00 = r0[c], g10 = r0[c+1], g01 = r1[c], g11 = r1[c+1];
                    if(g00 && g01 && g10 && g11){
                        for(var key in this.pattern){
                            var ptn = this.pattern[key];
                            ctx.fillStyle = ptn;
                            var weight = getWeight(key, g00, g10, g01, g11)
                            if(weight>0){
                                var lat = y0 + dy * r, lng = x0 + dx * c;
                                var latLng1 = L.latLng(lat+dy, lng),latLng2 = L.latLng(lat, lng + dx);
                                var p,p_next,dw,dh;
                                p = map[transformFn](latLng1);
                                p_next = map[transformFn](latLng2);
                                dw = p_next.x-p.x;
                                dh = p_next.y-p.y;
                                draw(weight,p.x,p.y,dw,dh);
                                // ctx.strokeText(key+'_'+weight,p.x,p.y); // for test
                            }
                        }
                    }
                }
            }
        }

        function getWeight(pKey,g00, g10, g01, g11){
            var weight = 0;
            if(g00 == pKey) weight += 8;
            if(g10 == pKey) weight += 4;
            if(g11 == pKey) weight += 2;
            if(g01 == pKey) weight += 1;
            return weight;
        }

        function draw(weight,x,y,w,h) {
            switch (weight) {
                case 0:
                    return;
                case 3:
                    return void ctx.fillRect(x, y + h/2, w, h/2);
                case 6:
                    return void ctx.fillRect(x + w/2, y, w/2, h);
                case 9:
                    return void ctx.fillRect(x, y, w/2, h);
                case 12:
                    return void ctx.fillRect(x, y, w, h/2);
                case 15:
                    return void ctx.fillRect(x, y, w, h)
            }
            switch (ctx.beginPath(), weight) {
                case 1:
                    ctx.moveTo(x, y + h/2),
                        ctx.lineTo(x, y + h),
                        ctx.lineTo(x + w/2, y + h);
                    break;
                case 2:
                    ctx.moveTo(x + w, y + h/2),
                        ctx.lineTo(x + w, y + h),
                        ctx.lineTo(x + w/2, y + h);
                    break;
                case 4:
                    ctx.moveTo(x + w/2, y),
                        ctx.lineTo(x + w, y),
                        ctx.lineTo(x + w, y +h/2);
                    break;
                case 5:
                    ctx.moveTo(x, y + h/2),
                        ctx.lineTo(x + w/2, y),
                        ctx.lineTo(x + w, y),
                        ctx.lineTo(x + w, y + h/2),
                        ctx.lineTo(x + w/2, y + h),
                        ctx.lineTo(x, y + h);
                    break;
                case 7:
                    ctx.moveTo(x, y +h/2),
                        ctx.lineTo(x + w/2, y),
                        ctx.lineTo(x + w, y),
                        ctx.lineTo(x + w, y + h),
                        ctx.lineTo(x, y + h);
                    break;
                case 8:
                    ctx.moveTo(x, y + h/2),
                        ctx.lineTo(x, y),
                        ctx.lineTo(x + w/2, y);
                    break;
                case 10:
                    ctx.moveTo(x, y),
                        ctx.lineTo(x + w/2, y),
                        ctx.lineTo(x + w, y + h/2),
                        ctx.lineTo(x + w, y + h),
                        ctx.lineTo(x + w/2, y + h),
                        ctx.lineTo(x, y + h/2);
                    break;
                case 11:
                    ctx.moveTo(x + w/2, y),
                        ctx.lineTo(x + w, y + h/2),
                        ctx.lineTo(x + w, y + h),
                        ctx.lineTo(x, y + h),
                        ctx.lineTo(x, y);
                    break;
                case 13:
                    ctx.moveTo(x, y),
                        ctx.lineTo(x + w, y),
                        ctx.lineTo(x + w, y + h/2),
                        ctx.lineTo(x + w/2, y + h),
                        ctx.lineTo(x, y + h);
                    break;
                case 14:
                    ctx.moveTo(x, y),
                        ctx.lineTo(x + w, y),
                        ctx.lineTo(x + w, y + h),
                        ctx.lineTo(x + w/2, y + h),
                        ctx.lineTo(x, y + h/2)
            }
            ctx.closePath();
            ctx.fill();
        }
    }
})

/**
 * @class LW.PatternLayer
 * @constructor
 * @param gridModel {LW.GridModel|LW.GridModelManager} 格点数据模型
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.PatternLayer}
 */
LW.patternLayer = function (gridModel,options) {
    return new LW.PatternLayer(gridModel,options);
};

/**
 * 热力图
 *
 * Features :
 *      1. 根据站点和权重生成热力图
 *      2. 需要引用heatmap.js
 *
 * Update Note ：
 *      + v1.5.4 ：Created
 *
 * @class LW.HeatmapOverlay
 * @extends L.Layer
 * @demo demo/plot/heatmap/heatmap.html  {热力图}
 */
LW.HeatmapOverlay = L.Layer.extend({
    options: {
        /**
         * 半径
         * @property radius
         * @default 0.004
         */
        radius: 0.004,
        scaleRadius: true,
        useLocalExtrema:false,
        /**
         * 经度字段名
         * @property latField
         * @default 'lat'
         */
        latField: 'lat',
        /**
         * 纬度字段名
         * @property lngField
         * @default 'lon'
         */
        lngField: 'lon',
        /**
         * 强度值字段名
         * @property valueField
         * @default 'value'
         */
        valueField: 'value',
        /**
         * 最大透明度
         * @property maxOpacity
         * @default .6
         */
        maxOpacity: .6,
        /**
         * 渐变色谱
         * @property gradient
         * @default {
                '0.2': 'rgba(0,0,255,0.1)',
                '0.4': 'rgba(2,192,241,0.3)',
                '0.6': 'rgba(44,222,148,0.5)',
                '0.8': 'rgba(254,237,83,0.7)',
                '1.0': 'rgba(255,64,28,0.9)'
            }
         */
        gradient: {
            // enter n keys between 0 and 1 here
            '0.2': 'rgba(0,0,255,0.1)',
            '0.4': 'rgba(2,192,241,0.3)',
            '0.6': 'rgba(44,222,148,0.5)',
            '0.8': 'rgba(254,237,83,0.7)',
            '1.0': 'rgba(255,64,28,0.9)'
        }
    },

    initialize: function (options) {
        L.setOptions(this, options);
        this._el = L.DomUtil.create('div', 'leaflet-zoom-hide');
        this._data = [];
        this._max = 1;
        this._min = 0;
        this.options.container = this._el;
    },

    onAdd: function (map) {
        this._map = map;

        var size = map.getSize();
        this._width = size.x;
        this._height = size.y;

        this._el.style.width = size.x + 'px';
        this._el.style.height = size.y + 'px';
        this._el.style.position = 'absolute';

        this._origin = this._map.layerPointToLatLng(new L.Point(0, 0));

        map.getPanes().overlayPane.appendChild(this._el);

        if (!this._heatmap) {
            this._heatmap = window.h337.create(this.options);
        }

        // this resets the origin and redraws whenever
        // the zoom changed or the map has been moved
        map.on('moveend', this._reset, this);
        this._draw();
    },

    addTo: function (map) {
        map.addLayer(this);
        return this;
    },

    onRemove: function (map) {
        // remove layer's DOM elements and listeners
        map.getPanes().overlayPane.removeChild(this._el);
        map.off('moveend', this._reset, this);
    },
    _draw: function () {
        if (!this._map) {
            return;
        }

        var mapPane = this._map.getPanes().mapPane;
        var point = mapPane._leaflet_pos;

        // reposition the layer
        this._el.style[LW.HeatmapOverlay.CSS_TRANSFORM] = 'translate(' +
            -Math.round(point.x) + 'px,' +
            -Math.round(point.y) + 'px)';

        this._update();
    },
    _update: function () {
        var bounds, zoom, scale;
        var generatedData = {max: this._max, min: this._min, data: []};

        bounds = this._map.getBounds();
        zoom = this._map.getZoom();
        scale = Math.pow(2, zoom);

        if (this._data.length == 0) {
            if (this._heatmap) {
                this._heatmap.setData(generatedData);
            }
            return;
        }


        var latLngPoints = [];
        var radiusMultiplier = this.options.scaleRadius ? scale : 1;
        var localMax = 0;
        var localMin = 0;
        var valueField = this.options.valueField;
        var len = this._data.length;

        while (len--) {
            var entry = this._data[len];
            var value = entry[valueField];
            var latlng = entry.latlng;

            // we don't wanna render points that are not even on the map ;-)
            // if (!bounds.contains(latlng)) {
            //     continue;
            // }
            // local max is the maximum within current bounds
            localMax = Math.max(value, localMax);
            localMin = Math.min(value, localMin);

            var point = this._map.latLngToContainerPoint(latlng);
            var latlngPoint = {x: Math.round(point.x), y: Math.round(point.y)};
            latlngPoint[valueField] = value;

            var radius;

            if (entry.radius) {
                radius = entry.radius * radiusMultiplier;
            } else {
                radius = (this.options.radius || 2) * radiusMultiplier;
            }
            latlngPoint.radius = radius;
            latLngPoints.push(latlngPoint);
        }
        if (this.options.useLocalExtrema) {
            generatedData.max = localMax;
            generatedData.min = localMin;
        }

        generatedData.data = latLngPoints;

        this._heatmap.setData(generatedData);
    },

    /**
     * 设置热力图数据。
     * 如果数据中min/max有值，则使用数据中的min/max。否则min/max默认为0/1。数据需要传入前处理成0-1之间的值
     * @method setData
     * @param data {Object} {min,max,data<Array>}
     */
    setData: function (data) {
        this._max = data.max || this._max;
        this._min = data.min || this._min;
        var latField = this.options.latField, lngField = this.options.lngField;
        var valueField = this.options.valueField;

        // transform data to latlngs
        var data = data.data;
        var len = data.length;
        var d = [];
        while (len--) {
            var entry = data[len];
            var latlng = new L.LatLng(entry[latField], entry[lngField]);
            var dataObj = {latlng: latlng};
            dataObj[valueField] = entry[valueField];
            if (entry.radius) {
                dataObj.radius = entry.radius;
            }
            d.push(dataObj);
        }
        this._data = d;

        this._draw();
    },
    // experimential... not ready.
    addData: function (pointOrArray) {
        if (pointOrArray.length > 0) {
            var len = pointOrArray.length;
            while (len--) {
                this.addData(pointOrArray[len]);
            }
        } else {
            var latField = this.options.latField || 'lat';
            var lngField = this.options.lngField || 'lng';
            var valueField = this.options.valueField || 'value';
            var entry = pointOrArray;
            var latlng = new L.LatLng(entry[latField], entry[lngField]);
            var dataObj = {latlng: latlng};

            dataObj[valueField] = entry[valueField];
            this._max = Math.max(this._max, dataObj[valueField]);
            this._min = Math.min(this._min, dataObj[valueField]);

            if (entry.radius) {
                dataObj.radius = entry.radius;
            }
            this._data.push(dataObj);
            this._draw();
        }
    },
    _reset: function () {
        this._origin = this._map.layerPointToLatLng(new L.Point(0, 0));

        var size = this._map.getSize();
        if (this._width !== size.x || this._height !== size.y) {
            this._width = size.x;
            this._height = size.y;

            this._el.style.width = this._width + 'px';
            this._el.style.height = this._height + 'px';

            this._heatmap._renderer.setDimensions(this._width, this._height);
        }
        this._draw();
    }
});

LW.HeatmapOverlay.CSS_TRANSFORM = (function() {
        var div = document.createElement('div');
        var props = [
            'transform',
            'WebkitTransform',
            'MozTransform',
            'OTransform',
            'msTransform'
        ];

        for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (div.style[prop] !== undefined) {
                return prop;
            }
        }
        return props[0];
    })();
/**
 * @class LW.HeatmapOverlay
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.HeatmapOverlay}
 */
LW.heatmapOverlay = function (options) {
    return new LW.HeatmapOverlay(options);
};

(function () {

    var transition = {
        point2latlng: function(x, t) {
            var e = this.getR(t);
            return L.latLng(360 * Math.atan(Math.pow(Math.E, x.y / e)) / Math.PI - 90, x.x / t)
        },
        latlng2point:function(latlng, t) {
            var e = this.getR(t);
            return L.point(latlng.lng * t, e * Math.log(Math.tan(Math.PI / 4 + latlng.lat * Math.PI / 360)))
        },
        getR:function(x) {
            return 180 / Math.PI * x;
        }
    };

    {
        L.LatLng.prototype.offset = function(x) {
            return L.latLng(this.lat - x.lat, this.lng - x.lng);
        }
        L.LatLng.div = function(latlng,t){
            return L.point(latlng.lng / t, latlng.lat / t);
        };
        L.Point.mul = function(x, t) {
            return L.latLng(x.y * t, x.x * t);
        };
    }

    var gradient = function (steps, legend) {
        this.steps = steps;
        this.gradient = legend;
        this.colors = null;
        this.setMinMax()
    };
    gradient.prototype = {
        setColors: function (x) {
            this.wasModified || (this.defaultGradient = utils.clone(this.gradient)),
                this.wasModified = !0,
                this.gradient = x,
                this.setMinMax(),
            this.colors && this.forceGetColor()
        },
        setMinMax : function () {
            this.min = this.gradient[0][0];
            this.max = this.gradient[this.gradient.length - 1][0];
        },
        forceGetColor : function () {
            return this.colors = null,
                this.getColor()
        },
        color : function (x, t, e) {
            var _ = this.RGBA(x);
            return "rgba(" + _[0] + "," + _[1] + "," + _[2] + "," + (t || _[3] / (e || 256)) + ")"
        },
        colorInvert : function (x, t, e) {
            var _ = this.RGBA(x);
            return "rgba(" + (255 - _[0]) + "," + (255 - _[1]) + "," + (255 - _[2]) + "," + (t || _[3] / (e || 256)) + ")"
        },
        colorRGB : function (x) {
            var t = this.RGBA(x);
            return "rgb( " + t[0] + ", " + t[1] + ", " + t[2] + ")"
        },
        colorDark : function (x, t) {
            var e = this.RGBA(x);
            return "rgba(" + (e[0] - t) + "," + (e[1] - t) + "," + (e[2] - t) + ",1)"
        },
        RGBA : function (x) {
            var t = this.value2index(x);
            return [this.colors[t], this.colors[++t], this.colors[++t], this.colors[++t]]
        },
        getMulArray : function (color, t) {
            var i, data = [], len = color.length;
            for (i = 0; i < len; i++)
                data.push(color[i] * t);
            return data
        },
        lerpArray : function (color0, color1, scale) {
            var i, _scale = 1 - scale, len = color0.length, data = [];
            for (i = 0; i < len; i++) {
                data.push(color0[i] * _scale + color1[i] * scale)
            }
            return data
        },
        rgb2yuv : function (color) {
            var data = [], e = .299 * color[0] + .587 * color[1] + .114 * color[2];
            data.push(e);
            data.push(.565 * (color[2] - e));
            data.push(.713 * (color[0] - e));
            data.push(color.slice(3));
            return data;
        },
        yuv2rgb : function (color) {
            return [color[0] + 1.403 * color[2], color[0] - .344 * color[1] - .714 * color[2], color[0] + 1.77 * color[1]].concat(color.slice(3));
        },
        gradYuv : function (color0, color1, scale, _) {// _ = true
            var lerp = this.lerpArray(color0, color1, scale);
            if (_) {
                var s1 = this.vec2size(color0[1], color0[2]),
                    s2 = this.vec2size(color1[1], color1[2]);
                if (s1 > .05 && s2 > .05) {
                    var s = this.vec2size(lerp[1], lerp[2]),
                        _s = s1 * (1 - scale) + s2 * scale;
                    if (s > .01) {
                        var l = _s / s;
                        lerp[1] *= l;
                        lerp[2] *= l;
                    }
                }
            }
            return lerp
        },
        vec2size : function (x, t) {
            return Math.sqrt(x * x + t * t);
        },
        getGradientColor : function (type, color0, color1, scale, i) {
            var color, a = 1, s = 256;
            switch (type) {
                case "YUV":
                    var _color = this.gradYuv(this.rgb2yuv(this.getMulArray(color0, 1 / 255)), this.rgb2yuv(this.getMulArray(color1, 1 / 255)), scale, true);
                    color = this.yuv2rgb(_color);
                    break;
                default:
                    color = this.lerpArray(color0, color1, scale),
                        a = 1 / 255,
                        s = 1
            }
            for (var d = color[3] * a, j = 0; j < 4; j++) {
                var l = color[j];
                i && j < 3 && (l *= d),
                    color[j] = Math.max(0, Math.min(l * s, 255))
            }
            return color
        },
        createGradientArray : function (type, t, e, steps, b) {// t = false,e = true
            steps = steps || this.steps, b = b || 1;
            var n = new Uint8Array(4 * (steps + (t ? 1 : 0))), a = 0, s = (this.max - this.min) / steps,
                legend = this.gradient,
                d = 1, color0 = legend[0], color1 = legend[d++];
            for (var i = 0; i < steps; i++) {
                var value = (this.min + s * i) * b;
                value > color1[0] && d < legend.length && (color0 = color1,
                    color1 = legend[d++]);
                var scale = (value - color0[0]) / (color1[0] - color0[0]),
                    u = this.getGradientColor(type, color0[1], color1[1], scale, e);
                for (var g = 0; g < 4; g++)
                    n[a++] = u[g]
            }
            if (t) {
                for (this.neutralGrayIndex = a, g = 0; g < 4; g++)
                    n[a++] = 130;
            }
            return n;
        },
        getColor : function () {
            return this.colors ? this : (this.colors = this.createGradientArray("YUV", false, true),
                this.startingValue = this.min,
                this.step = (this.max - this.startingValue) / this.steps,
                this.value2index = function (x) {
                    return isNaN(x) ? this.neutralGrayIndex : Math.max(0, Math.min(4 * (this.steps - 1), (x - this.startingValue) / this.step << 2));
                }
                , this)
        }
    };


    /**
     * 渐变webgl网格图层
     *
     * Features :
     *      1. 基于webgl实现
     *      2. 基于GridInt16流数据
     *
     * Update Note：
     *      + v1.5.2 : Created
     *      + v1.5.3 : 增加网格风，网格箭头的绘制
     *      + v1.5.4 : 1. 增加可外部配置值处理方法的功能，对应的属性为valueFn
     *                 2. DPI不为1时，遮罩会出现偏移的问题修复
     *      + v1.5.5 : 1. 展示精度直接使用数据中的precision字段，需要sun@1.0.26支持
     *                 2. 网格插值方法由双三次插值改为三次样条插值
     *                 3. 修复虚拟机中位置偏移的问题
     *                 4. 修复苹果手机数值读出来有误差，导致无效值被填色的问题
     *
     * @class LW.GradientGlLayer
     * @extends LW.CanvasLayer
     * @demo demo/plot/contour/gradientWebglLayer.html {渐变Gl图层}
     */
    LW.GradientGlLayer = LW.CanvasLayer.extend({
        options: {
            legendData:null,
            /**
             * 填色透明度
             * @property opacity
             * @type {number}
             * @default 0.8
             */
            opacity:0.8,
            fill:true,
            /**
             * 格点图层属性
             * @property gridOptions
             * @type {object}
             * @default
             */
            gridOptions:{
                /**
                 * 格点的要素，可有数值--value,风杆--wind,箭头--arrow
                 * @property gridOptions.elements
                 * @type {Array}
                 * @default ['value']
                 */
                elements:['value'],
                /**
                 * 要素的显影
                 * @property gridOptions.elementsVisible
                 * @type {Object}
                 * @default {value:true,wind:false,arrow:false}
                 */
                elementsVisible:{value:false,wind:false,arrow:false},
                // visible:false,
                /**
                 * 格点值字体字号
                 * @property gridOptions.font
                 * @type {String}
                 * @default '14px Microsoft YaHei'
                 */
                font:'14px Microsoft YaHei',
                /**
                 * 格点值颜色
                 * @property gridOptions.valueColor
                 * @type {String}
                 * @default '#333'
                 */
                valueColor:'#333',
                /**
                 * 格点值描边颜色
                 * @property gridOptions.valueStroke
                 * @type {String|false}
                 * @default false
                 */
                valueStroke:false,
                /**
                 * 显示值的方法，即对数据传过来的值不直接展示，而是加工后展示，可以用该方法实现
                 * 如可视化需求：降水0不展示，其他降水值向下取整。其他要素均展示向下取整
                 * @property valueFn
                 * @type {function}
                 * @default null
                 */
                valueFn:null,
                /**
                 * 是否展示值为0的网格值
                 * @property gridOptions.showZero
                 * @type {boolean}
                 * @default false
                 */
                showZero:false,
                /**
                 * 格点风颜色
                 * @property gridOptions.windColor
                 * @type {String|false}
                 * @default '#fff'
                 */
                windColor:'#222',
                /**
                 * 网格风是否描边 eg:false|'#fff'
                 * @type {boolean|string}
                 * @property gridOptions.gridWindStroke
                 * @default false
                 */
                gridWindStroke:false,
                /**
                 * 网格风描边粗细
                 * @type {int}
                 * @property gridOptions.gridWindStrokeWidth
                 * @default 3
                 */
                gridWindStrokeWidth:3,
                /**
                 * 网格要素显示等级
                 * @type {Array}
                 * @property gridOptions.zooms
                 * @default [3,18]
                 */
                zooms:[3,18]
            },
            /**
             * 填色渲染器
             * @property glRenderer
             * @default LW.glCanvas()
             */
            glRenderer: LW.glCanvas(),
            maskGeoJson:null
        },
        range:{
            min:NaN,
            max:NaN
        },
        initialize:function(gridModel,options){
            options.gridOptions = L.extend({},this.options.gridOptions,options.gridOptions);
            L.setOptions(this,options);
            this.gridModel = gridModel;
            this.resetMask(this.options.maskGeoJson);
            // this.setLegendData(this.options.legendData);

            var self = this;
            this.gridModel.on('transform',function(){
                self._update();
            });
        },

        getElement:function (){
            return this.options.glRenderer._container;
        },

        /**
         * 重置遮罩
         * @method resetMask
         * @param maskGeoJson {LW.maskGeoJson}
         */
        resetMask:function(maskGeoJson){
            this.options.maskGeoJson = maskGeoJson;
            this.options.renderer.resetMask(maskGeoJson);
            this.options.glRenderer.resetMask(maskGeoJson,this.options.fill);
            this._update();
        },

        _initGL:function(){
            if(!this.gl){
                var gl = this.gl = this._glRenderer.gl;

                var vsBuffer = this.vsBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), gl.STATIC_DRAW);

                this.prgObj = glUtil.getPrgObj(gl,this.getVs(),this.getFs());

                this.setLegendData(this.options.legendData);
            }
        },

        beforeAdd: function (map) {
            this._map = map;
            this._glRenderer = this.options.glRenderer;// glRenderer
            // Tip:需要在beforeAdd添加在map上，否则缩放会有问题
            if (this._glRenderer && !this._map.hasLayer(this._glRenderer))
                this._map.addLayer(this._glRenderer);
            this._renderer = map.getRenderer(this);// gridRenderer
            this._initGL();
        },

        onRemove: function () {
            LW.CanvasLayer.prototype.onRemove.call(this);
            if (this._glRenderer && this._map.hasLayer(this._glRenderer))
                this._map.removeLayer(this._glRenderer);
        },

        getVs: function() {
            return 'attribute vec2 aPos;varying vec2 vPos;void main() {gl_Position = vec4(aPos,0.0,1.0);vPos = aPos * 0.5 + 0.5;}';
        },

        getFs: function() {
            return 'precision highp float;uniform highp sampler2D sDataTex;uniform sampler2D sColorTex;uniform vec3 uColorMinMax;uniform int uEPSG;uniform vec4 uDataBounds,uBounds;varying vec2 vPos;uniform vec2 uMinMax;uniform float uRes,DataPrecision,uPxRes,uInvalidValue;float D(float a){return mix(exp(a),a,step(a,-4.));}vec2 r(vec2 b,float a){if(uEPSG==3857){float c=57.29578*a;return vec2(b.x/a,atan(D(b.y/c))*360./3.141593-90.);}else return b/a;}vec2 s(){vec2 a=vPos*(uBounds.zw-uBounds.xy)+uBounds.xy,b=r(a,uPxRes);return b;}float t(float a,float b,float c,float e);float E(vec4 a){return t(a.x,a.y,a.z,a.w);}float t(float b,float c,float e,float f){float a=b*16.*16.*16.+c*16.*16.+e*16.+f;return a==uInvalidValue?32767.:a<32768.?a:a-65536.;}float d(vec2 a){if(a.x<=0.||a.y<=0.||a.x>=1.||a.y>=1.)return 32767.;highp vec4 b=texture2D(sDataTex,a);return E(b*15.);}bool u(float a);vec4 F(float a){if(a>32766.||!u(a/DataPrecision))return vec4(0,0,0,0);float b=a/DataPrecision;return texture2D(sColorTex,vec2((b-uColorMinMax.x)/uColorMinMax.z,.5));}float n(float e,float a,float f){float b=a-e,c=f-a;return b==0.||c==0.?0.:sign(b)!=sign(c)?0.:2./(1./c+1./b);}float h(float i,float a,float b,float j,float c){if(i>32766.||a>32766.||b>32766.||j>32766.)return 32767.;if(a==b)return a;float e=n(i,a,b),f=n(a,b,j),g=-(2.*f+4.*e)+6.*(b-a),m=4.*f+2.*e-6.*(b-a),k=(m-g)/6.,l=g/2.,o=b-a-l-k,p=a;return p+o*c+l*c*c+k*c*c*c;}bool G(float a){float b=a/DataPrecision;return b>=uMinMax.x&&b<=uMinMax.y;}void main(){vec2 a=uDataBounds.zw-uDataBounds.xy,o=s(),c=o-uDataBounds.xy;if(c.x<0.||c.y<0.||c.x>a.x||c.y>a.y)gl_FragColor=vec4(0,0,0,0);else{vec2 b=fract(c/vec2(uRes,uRes)),e=c+vec2(-b.x*uRes,-b.y*uRes),f=c+vec2((1.-b.x)*uRes,-b.y*uRes),j=e-vec2(uRes,0),k=f+vec2(uRes,0),g=c+vec2(-b.x*uRes,(1.-b.y)*uRes),i=c+vec2((1.-b.x)*uRes,(1.-b.y)*uRes),l=g-vec2(uRes,0),m=i+vec2(uRes,0),p=j-vec2(0,uRes),v=e-vec2(0,uRes),w=f-vec2(0,uRes),x=k-vec2(0,uRes),y=l+vec2(0,uRes),z=g+vec2(0,uRes),A=i+vec2(0,uRes),B=m+vec2(0,uRes);float C=h(h(d(p/a),d(v/a),d(w/a),d(x/a),b.x),h(d(j/a),d(e/a),d(f/a),d(k/a),b.x),h(d(l/a),d(g/a),d(i/a),d(m/a),b.x),h(d(y/a),d(z/a),d(A/a),d(B/a),b.x),b.y);gl_FragColor=G(C)?F(C):vec4(0,0,0,0);}}bool u(float a){return true;}'
        },

        /**
         * 设置图例数据
         * @method setLegendData
         * @param legendData
         */
        setLegendData: function (legendData,steps) {
            this.options.legendData = legendData || this.options.legendData;
            legendData = this.options.legendData;
            if(legendData){
                var segments = Sun.Util.LegendData.getColorSegments(legendData,1,this.options.opacity);
                var legend = this.legend = new gradient(steps||2048,segments);
                if (legend && this.gl){
                    legend.getColor();
                    this.colorTex = glUtil.bindTexture(this.gl, this.gl.NEAREST, legend.colors, legend.steps, 1);
                }
            }
        },
        /**
         * 设置填色透明度,如果颜色是6位则使用options.opacity的透明度，如果颜色是8位，则使用color里面的透明度
         * @method setOpacity
         * @param opacity
         */
        setOpacity:function (opacity) {
            this.options.opacity = opacity;
            this.setLegendData();
            this._update();
        },

        /**
         * 设置数据
         * @method setData
         * @param data {ArrayBuffer|json} 数据，可为nc流数据或者json数据
         */
        setData: function (data) {
            if((data instanceof ArrayBuffer && data.byteLength>0))
                this.gridModel.setData(data);
            else
                this.clear();
        },

        /**
         * 设置格点要素的显影
         * @method setGridElementVisible
         * @param element {String} 可选择options.elements中的要素
         * @param visible {Boolean}
         */
        setGridElementVisible: function (element,visible) {
            var elementsVisible = this.options.gridOptions.elementsVisible;
            if(elementsVisible[element] !== visible){
                elementsVisible[element] = visible;
                this._drawGrid();
            }
        },

        /**
         * 设置填色的显影
         * @method setFillVisible
         * @param visible {Boolean}
         */
        setFillVisible: function (visible) {
            this.options.fill = visible;
            if (!visible && this.gl) {
                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            }
            else
                this._render();
        },

        /**
         * 展示所有范围的值，用于setDataRange后恢复
         * @method showAllRange
         */
        showAllRange:function () {
            this.setDataRange({min:NaN,max:NaN});
        },

        /**
         * 设置数据展示区间
         * @method setDataRange
         * @param range {object} {min:NaN,max:NaN}
         */
        setDataRange:function (range) {
            this.range=range;
            this._update();
        },

        clear:function(){
            this.gridModel.data = null;
            if(this.gl){
                this.gl.clearColor(0, 0, 0, 0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            }
            LW.CanvasLayer.prototype.clear.call(this);
        },

        _update: function () {
            if (this.gridModel.data && this._map) {
                // var d1 = Date.now();
                this._draw();
                // var d2 = Date.now();
                // console.log('gradient update',(d2-d1)/1000+'s');
            }
        },

        _draw : function () {
            // 绘制渐变图层
            this._render();
            // 绘制网格
            this._drawGrid();
            // this._glRenderer.setMask();
        },

        _render: function(){
            var map = this._map;
            if(!this.options.fill || !map)
                return ;
            var crs = this._map.options.crs , zoom = this._map.getZoom(),render = this._glRenderer;
            var options = this.options,llBounds = render._latLngBounds;
            var gridModel = this.gridModel,data=gridModel.data,dataBounds = gridModel.bounds;
            var gl = this.gl,prgObj = this.prgObj,range = this.range,mask = !!this.options.maskGeoJson;
            if(gl){
                var pxBounds = L.bounds(crs.latLngToPoint(llBounds.getSouthWest(), zoom),
                    crs.latLngToPoint(llBounds.getNorthEast(), zoom));
                this.res = getRes();
                var pxRes = 1 / this.res;
                var bounds = L.bounds(transition.latlng2point(llBounds.getSouthWest(), pxRes), transition.latlng2point(llBounds.getNorthEast(), pxRes));

                bounds.min = bounds.min.round();
                bounds.max = bounds.max.round();
                var size = bounds.getSize(), b = 1;
                size = size.round();
                // size._multiplyBy(b);

                gl.viewport(0, 0, size.x, size.y);

                if(mask)
                    render.setMask();

                gl.useProgram(prgObj.program);

                // Pass test if stencil value is 1
                if(mask){
                    gl.stencilFunc(gl.EQUAL, 1, 0xFF);
                    gl.stencilMask(0x00);
                    gl.colorMask(1, 1, 1, 1);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, this.vsBuffer);
                gl.enableVertexAttribArray(prgObj.aPos);
                gl.vertexAttribPointer(prgObj.aPos, 2, gl.FLOAT, false, 0, 0);

                // gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.deleteTexture(this.mainTex);
                var m = data.GridType == 11 ? new Uint16Array(data.speed.buffer) : new Uint16Array(data.data.buffer);
                this.mainTex = glUtil.bindTexture(gl, gl.NEAREST, m, data.lonsize, data.latsize);
                glUtil.activeTexture(gl, this.mainTex, 0);
                gl.uniform1i(prgObj.sDataTex, 0);
                gl.uniform4f(prgObj.uDataBounds, dataBounds.getWest(), dataBounds.getSouth(), dataBounds.getEast(), dataBounds.getNorth());

                gl.uniform1f(prgObj.uRes, data.nlon);//经纬度分辨率，由于经纬度间隔约定一致，所以只用nlon,之后有不同情况再做处理
                gl.uniform1f(prgObj.uPxRes, pxRes);
                gl.uniform4f(prgObj.uBounds, bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y);
                gl.uniform1i(prgObj.uEPSG, crs.code.split(":")[1]);
                gl.uniform1f(prgObj.DataPrecision, data.DataPrecision);
                gl.uniform1f(prgObj.uInvalidValue, data.invalidValue);

                var colorTex = this.colorTex, legend = this.legend;
                glUtil.activeTexture(gl, colorTex, 1);
                gl.uniform1i(prgObj.sColorTex, 1);
                gl.uniform3f(prgObj.uColorMinMax, legend.min, legend.max, legend.max - legend.min);

                // gl.uniform2f(prgObj.uMinMax, isNaN(range.min) ? -9997 : range.min, isNaN(range.max) ? 9997 : range.max);
                gl.uniform2f(prgObj.uMinMax, isNaN(range.min) ? -32767 : range.min, isNaN(range.max) ? 32766 : range.max);

                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            }

            function getRes() {
                return (llBounds.getEast() - llBounds.getWest()) / pxBounds.getSize().x;
            }
        },

        _drawGrid:function () {
            var map = this._map;
            if(!map) return;
            LW.CanvasLayer.prototype.clear.call(this);
            var options = this.options.gridOptions;
            if((_ElementVisble('value') || _ElementVisble('wind') || _ElementVisble('arrow'))) {
                var zoom = map.getZoom();
                if (zoom >= options.zooms[0] && zoom <= options.zooms[1]) {
                    var render = this._renderer, ctx = render._ctx, llBounds = this._glRenderer._latLngBounds;
                    var gridModel = this.gridModel, data = gridModel.data, dataBounds = gridModel.bounds,
                        dataRes = data.nlon;
                    var range = this.range;

                    var x = 36;
                    var min = L.LatLng.div(llBounds.getSouthWest().offset(dataBounds.getSouthWest()), dataRes)._floor(),
                        max = L.LatLng.div(llBounds.getNorthEast().offset(dataBounds.getSouthWest()), dataRes)._ceil()
                    var res = this.res;
                    var gap = dataRes / res > x ? 1 : Math.ceil(x / (dataRes / res));
                    gap = getGap(gap);
                    min = L.LatLng.div(llBounds.getSouthWest(), dataRes * gap)._floor()._multiplyBy(gap)._subtract(L.LatLng.div(dataBounds.getSouthWest(), dataRes)._round())

                    for (var i = min.y; i <= max.y; i += gap) {
                        for (var j = min.x; j <= max.x; j += gap) {
                            var grid = gridModel.getGrid(i, j)
                            if(grid || (options.showZero && grid == 0)) {
                                var gValue = _getValue(grid);
                                if (isShowGrid(gValue.value)) {
                                    var latlng = L.latLng(i * dataRes + dataBounds.getSouth(), j * dataRes + dataBounds.getWest());
                                    var p = map.latLngToContainerPoint(latlng);
                                    if (_hasElement('wind'))
                                        _drawWind(gValue, p);
                                    else if (_hasElement('arrow'))
                                        _drawArrow(gValue, p);
                                    else if (_hasElement('value'))
                                        _drawValue(gValue, p);
                                }
                            }
                        }
                    }
                    render.setMask();
                }
            }

            function _hasElement(element) {
                return options.elements.indexOf(element)!==-1;
            }
            function _ElementVisble(element) {
                return options.elements.indexOf(element)!==-1 && options.elementsVisible[element];
            }

            function _getValue(grid) {
                var value = typeof grid == "object" ? grid : {value:grid};
                var valid = !gridModel.isInvalid(value.value || value);
                value.valid = valid;
                if(_hasElement('wind') || _hasElement('arrow')){
                    var wind = valid?Sun.Util.Weather.wind_getWindByUV(grid,data.precision):
                        {speed:data.invalidValue,dir:data.invalidValue};
                    value = {value:wind.speed,dir:wind.dir,valid:valid};
                }
                return value;
            }

            function isShowGrid(value) {
                if(isNaN(range.min) && isNaN(range.max))
                    return true;
                else if(isNaN(range.min))
                    return value<=range.max;
                else if(isNaN(range.max))
                    return value>=range.min;
                else
                    return value>=range.min && value<=range.max;
            }

            function getGap(g) {
                return 1 << Math.floor(Math.log(g + g - 1) / Math.LN2)
            }

            function _drawValue(value, p, yOffset) {
                if (!ctx) return;
                if (options.elementsVisible.value) {
                    yOffset = yOffset || 5;
                    ctx.font = options.font;
                    ctx.textAlign = "center";
                    var value = options.valueFn ? options.valueFn(value) : value.value;
                    if (options.valueStroke) {
                        ctx.strokeStyle = options.valueStroke;
                        ctx.lineWidth = 2;
                        ctx.strokeText(value, p.x, p.y + yOffset);
                    }
                    ctx.fillStyle = options.valueColor;
                    ctx.fillText(value, p.x, p.y + yOffset);
                }
            }

            function _drawWind(value, p) {
                if (!ctx) return;
                _drawValue(value,p,10);
                ctx.lineWidth = options.gridWindLineWidth||1;
                ctx.strokeStyle = options.gridWindColorful?
                    Sun.Util.LegendData.getColorOfRangeLegend(options.legendData, value.value):options.windColor;
                if (options.elementsVisible.wind && value.valid)
                    Sun.Util.Geometry.drawWindByPosition(ctx, value.value, value.dir, p,false,null,null,null,
                        options.gridWindStroke,options.gridWindStrokeWidth);
            }
            function _drawArrow(value, p) {
                if (!ctx) return;
                _drawValue(value,p,10);
                ctx.strokeStyle = options.windColor;
                if (options.elementsVisible.arrow && value.valid)
                    Sun.Util.Geometry.drawArrow(ctx, p, value.dir-180);
            }
        },
    });

    /**
     * @class LW.GradientGlLayer
     * @constructor
     * @param gridModel {LW.GridModel|LW.GridModelManager} 格点数据模型
     * @param options {object} 外部属性，可重设Properties
     * @returns {LW.GradientGlLayer}
     */
    LW.gradientGlLayer = function (gridModel,options) {
        return new LW.GradientGlLayer(gridModel,options);
    };
})();

/**
 * webgl 雷达图层
 * Features :
 *      1. 基于webgl实现
 *      2. 将多张图的拼图合并传入，播放时会取前后两张图插值播放展示
 *
 * Update Note：
 *      + v1.5.6 : Created
 *
 * @class LW.RadarGlLayer
 * @extends  LW.RadarLayer
 * @demo demo/plot/radarGlLayer.html  {webgl雷达}
 */
LW.RadarGlLayer = LW.RadarLayer.extend({
    options: {
        /**
         * 图例数据
         * @property legendData
         * @type {Array}
         * @default null
         */
        legendData: null,
        /**
         * 原始数据范围
         * @property range
         * @type {object}
         * @default {min:-33,max:65}
         */
        range:{min:-33,max:65},//图例范围
        /**
         * 显示数据范围，NaN表示使用range的min/max
         * @property dataRange
         * @type {object}
         * @default {min:NaN,max:NaN}
         */
        dataRange:{min:NaN,max:NaN},
        /**
         * 填色透明度
         * @property opacity
         * @type {number}
         * @default 0.8
         */
        opacity: 0.8,
        /**
         * 播放间隔。单位：ms
         * @property playInterval
         * @type {int}
         * @default 2000
         */
        playInterval:2000,
        /**
         * 填色渲染器
         * @property renderer
         * @default LW.glCanvas()
         */
        renderer: LW.glCanvas(),
    },
    getElement: function () {
        return this.canvas;
    },

    initialize: function (bounds,options) { // (String, LatLngBounds, Object)
        L.setOptions(this, options);
        if (bounds)
            this._bounds = L.latLngBounds(bounds);
        if (!this.canvas)
            this._initCanvas();
        this.setLegendData(this.options.legendData);
    },

    _initCanvas: function () {
        var canvas = this.canvas = L.DomUtil.create('canvas', 'leaflet-radar-layer leaflet-zoom-animated');
        if(this.options.zIndex)
            this.canvas.style.zIndex = this.options.zIndex;
        var gl = this.gl = canvas.getContext("webgl2", {preserveDrawingBuffer: true,stencil: true,premultipliedAlpha: false}) ||
            canvas.getContext("experimental-webgl", {preserveDrawingBuffer: true,stencil: true,premultipliedAlpha: false});

        var vsBuffer = this.vsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), gl.STATIC_DRAW);

        this.prgObj = glUtil.getPrgObj(gl,this.getVs(),this.getFs());
    },

    getVs: function() {
        return 'attribute vec2 aPos;varying vec2 vPos;void main() {gl_Position = vec4(aPos,0.0,1.0);vPos = aPos * 0.5 + 0.5;}';
    },

    getFs(){
        return 'precision highp float;uniform sampler2D u_mainTex;uniform highp sampler2D u_colorTex;uniform int u_index,u_rows,u_columns;uniform float u_play,u_maxValue,u_minValue;uniform vec2 u_dataRange;varying vec2 vPos;float g(float a,bool b){a=b?a*255.:a;return clamp((a-u_minValue)/(u_maxValue-u_minValue),0.,1.);}float h(vec2 b){vec4 a=texture2D(u_mainTex,b);float c=a.g*255.==1.?-1.:1.;return a.r*c;}float o(float a){float b=g(u_dataRange.x,false),c=g(u_dataRange.y,false);return a>=b&&a<=c?1.:b-a<=.05?.9:0.;}void main(){float a=float(u_rows),b=float(u_columns),c=float(u_index);vec2 e=vec2(mod(c,b),floor(c/b)),f=vec2(mod(c+1.,b),floor((c+1.)/b)),j=vec2(mix(e.x/b,(e.x+1.)/b,vPos.x),mix((a-e.y-1.)/a,(a-e.y)/a,vPos.y)),k=vec2(mix(f.x/b,(f.x+1.)/b,vPos.x),mix((a-f.y-1.)/a,(a-f.y)/a,vPos.y));float l=h(j),m=h(k),i=g(mix(l,m,u_play),true);vec4 n=texture2D(u_colorTex,vec2(i,.5));gl_FragColor=vec4(n.rgb,n.a*o(i));}'},

    /**
     * 设置数据
     * @method setData
     * @param data {object} {url,width,height,rows,columns}
     */
    setData: function (data,index){
        this.data = data;
        this.index = index || 0;
        this.setUrl(data.url);
    },
    clear: function(){
        if(this.gl){
            this.gl.clearColor(0, 0, 0, 0);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        }
    },

    draw(){
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.gl.drawArrays(this.gl.TRIANGLE_FAN, 0, 4);
    },
    /**
     * 设置雷达图例
     * @method setLegendData
     * @param legendData {Array} 色谱数据
     */
    setLegendData: function (legendData,draw) {
        this.options.legendData = legendData;
        var w = 1000, h = 10;
        var canvas = Sun.Color.getLinearGradientImage(legendData,w,h,this.options.range);
        // console.log(canvas.toDataURL('image/png'));
        this.colorTex = glUtil.bindImgTexture(this.gl, this.gl.NEAREST, canvas, w, h);

        if(draw){
            glUtil.activeTexture(this.gl, this.colorTex, 1)
            this.gl.uniform1i(this.prgObj.u_colorTex, 1);
            this.draw();
        }
    },

    /**
     * 设置第i张图片
     * @method setIndex
     * @param index {int}
     */
    setIndex: function (index){
        var len = this.data.rows*this.data.columns;
        this.index = index>=0 ? index%len : len - 1;
        this.gl.uniform1i(this.prgObj.u_index, this.index);
        this.gl.uniform1f(this.prgObj.u_play, 0);
        this.draw();
        /**
         * 图片的索引变化发出事件
         * @event change
         * @param index {int} 图片索引
         */
        this.fire('change',{index:this.index})
    },

    /**
     * 展示上一张
     * @method showPrev
     */
    showPrev: function () {
        if (this.timer) this.pause();
        this.setIndex(this.index - 1);
    },

    /**
     * 展示下一张
     * @method showNext
     */
    showNext: function () {
        if (this.timer) this.pause();
        this.setIndex(this.index + 1);
    },

    /**
     * 播放
     * @method play
     */
    play: function (){
        if (this.timer) this.pause();
        var self = this;
        var interval = this.options.playInterval;
        _play();
        this.timer = setInterval(function (){
            self.index++;
            _play();
        },interval)

        function _play(){
            self.setIndex(self.index);

            var play = 0;
            window.clearInterval(self.uplay_timer);
            self.uplay_timer = setInterval(function (){
                setUPlay(play);
                /**
                 * 图片的播放系数变化发出事件
                 * @event change_play
                 * @param play {number} 播放系数
                 */
                self.fire('change_play',{play:play})
                play+=0.01;
                // play = Sun.Math.round(play,2);
            },interval/100)
        }

        function setUPlay(play){
            self.gl.uniform1f(self.prgObj.u_play, play);
            self.draw();
        }
    },

    /**
     * 暂停
     * @method pause
     */
    pause: function (){
        window.clearInterval(this.timer);
        window.clearInterval(this.uplay_timer);
        this.timer = null;
        this.uplay_timer = null;
    },

    _imageLoaded: function () {
        if (this.canvas) {
            var gl = this.gl,prgObj = this.prgObj,data = this.data, range = this.range;
            var options = this.options,size = {x:data.width,y:data.height};
            var self = this;
            if(gl && data){
                this.canvas.width = size.x;
                this.canvas.height = size.y;
                drawImage();
            }
        }


        function drawImage(){
            gl.viewport(0, 0, size.x, size.y);
            gl.useProgram(prgObj.program);

            gl.bindBuffer(gl.ARRAY_BUFFER, self.vsBuffer);
            gl.enableVertexAttribArray(prgObj.aPos);
            gl.vertexAttribPointer(prgObj.aPos, 2, gl.FLOAT, false, 0, 0);

            // gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            // gl.enable(gl.BLEND);
            // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.deleteTexture(self.mainTex);
            self.mainTex = glUtil.bindImgTexture(gl, gl.NEAREST, self._image,self._image.width,self._image.height);
            glUtil.activeTexture(gl, self.mainTex, 0);
            gl.uniform1i(prgObj.u_mainTex, 0);

            gl.uniform1f(prgObj.u_play, 0);
            gl.uniform1i(prgObj.u_index, 0);
            gl.uniform1i(prgObj.u_rows, data.rows);
            gl.uniform1i(prgObj.u_columns, data.columns);
            gl.uniform1f(prgObj.u_width, data.width);
            gl.uniform1f(prgObj.u_height, data.height);
            gl.uniform1f(prgObj.u_maxValue, options.range.max);
            gl.uniform1f(prgObj.u_minValue, options.range.min); //imageData最小值为0
            self.setDataRange();

            var colorTex = self.colorTex;
            glUtil.activeTexture(gl, colorTex, 1)
            gl.uniform1i(prgObj.u_colorTex, 1);

            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }
    },

    /**
     * 设置展示数值范围
     * @param range {object} {min,max}
     */
    setDataRange:function (dataRange,draw){
        if(dataRange)
            this.options.dataRange = dataRange;
        dataRange = this.options.dataRange;
        var range = this.options.range;

        this.gl.uniform2f(this.prgObj.u_dataRange, isNaN(dataRange.min) ? range.min : dataRange.min,
                                              isNaN(dataRange.max) ? range.max : dataRange.max);

        if(draw)
            this.draw();
    }
});

/**
 * @class LW.RadarGlLayer
 * @constructor
 * @param bounds {Array} 雷达图的边界，eg:[[21.843,114.943],[30.13,124.138]]
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.RadarGlLayer}
 */
LW.radarGlLayer = function(bounds, options) {
    return new LW.RadarGlLayer(bounds, options);
};

/**
 * 台风图层
 * @module Layer.Typ
 */
/**
 * 台风组合
 *
 * Features :
 *      1. 管理多个台风图层的Group
 *
 * Update Note：
 *      + v1.3.0-dev ：Created
 *
 * @class LW.TypGroup
 * @extends L.FeatureGroup
 * @demo demo/plot/typ.html  {台风}
 */
LW.TypGroup = L.FeatureGroup.extend({
    options:{
        // 包含TypLayer中的属性
        pane:'typPane',
        /**
         * 是否展示警戒线
         * @property showAlmtLine
         * @type {Boolean}
         * @default true
         */
        showAlmtLine:true,
        /**
         * 警戒线颜色，分24小时警戒线和48小时警戒线
         * @property almtLineColor
         * @type {Object}
         * @default {'24':'#f00','48':'#ff7e00'}
         */
        almtLineColor:{'24':'#f00','48':'#ff7e00'},
        almtLineLabelOpts:{edge: false,bold: true,iconSize: L.point(10, 20),iconAnchor: L.point(-10,0)}
    },

    initialize:function (options) {
        this.typhoons={};
        L.setOptions(this,options);
        L.FeatureGroup.prototype.initialize.call(this,options);
        if(this.options.showAlmtLine)
            this._createAlmtLine();
    },

    /**
     * 添加台风
     * @method addTyphoon
     * @param typData {array|object} 台风数据
     * @param isPlay {boolean} 是否播放
     */
    addTyphoon:function (typData,isPlay) {
        var self = this;
        if(Sun.Util.isArray(typData)){
            typData.forEach(function (item) {
                self.addTyphoon(item,isPlay);
            })
        }
        else{
            var layer = this.typhoons[typData.ID] || LW.typLayer(this.options);
            layer.setForeStations(this.foreStations);
            if(!this.hasLayer(layer)) this.addLayer(layer);
            layer.setData(typData,isPlay);
            this.typhoons[typData.ID] = layer;
        }
    },

    /**
     * 设置台风显隐
     * @method setTyphoonVisible
     * @param id
     * @param visible
     */
    setTyphoonVisible:function (id,visible) {
        var layer = this.typhoons[id];
        if(layer && this.hasLayer(layer) && !visible)
            this.removeLayer(layer);
        else if(layer && !this.hasLayer(layer) && visible)
            this.addLayer(layer);
    },
    /**
     * 删除台风
     * @method deleteTyphoon
     * @param id
     */
    deleteTyphoon:function (id) {
        this.setTyphoonVisible(id,false);
        delete this.typhoons[id];
    },

    /**
     * 删除所有台风
     * @method deleteAllTyphoon
     */
    deleteAllTyphoon:function(){
        this.eachTyphoon(function (typ,id){
            this.deleteTyphoon(id)
        },this);
    },

    /**
     * 根据id获取台风
     * @method getTyphoon
     * @param id
     * @returns {LW.TypLayer}
     */
    getTyphoon: function (id) {
        return this.typhoons[id];
    },

    /**
     * 遍历所有台风
     * @method eachTyphoon
     * @param method
     * @param context
     * @param id
     * @return {LW.TypGroup}
     */
    eachTyphoon: function (method, context,id) {
        if(id){
            if(this.typhoons[id] && this.hasLayer(this.typhoons[id]))
                method.call(context, this.typhoons[id]);
        }
        else{
            for (var _id in this.typhoons) {
                if(this.hasLayer(this.typhoons[_id]))
                    method.call(context, this.typhoons[_id],_id);
            }
        }
        return this;
    },

    getTyphoonEditData:function(key){
        var data = [];
        this.eachTyphoon(function (layer,id) {
            data.push(layer.getEditData(key));
        },this);
        return data;
    },

    /**
     * 设置台风预报站点
     * @method setForeStations
     * @param foreStations {Array} eg：["广州","上海","香港","福州","杭州","台湾","关岛","韩国","日本"]
     * @param [id] {String} 只针对传入id对应的台风生效
     */
    setForeStations:function (foreStations,id) {
        this.foreStations = foreStations;
        this.eachTyphoon(function (layer) {
            layer.setForeStations(foreStations);
        },this,id);
    },

    /**
     * 设置预报路径显隐
     * @method setForePathVisible
     * @param visible {Boolean}
     * @param [id] {String} 只针对传入id对应的台风生效
     */
    setForePathVisible:function (visible,id) {
        this.eachTyphoon(function (layer) {
            layer.setForePathVisible(visible);
        },this,id);
    },

    /**
     * 设置风圈显影
     * @method setWindCircleVisble
     * @param visible {Boolean}
     * @param [id] {String} 只针对传入id对应的台风生效
     */
    setWindCircleVisble:function (visible,id) {
        this.eachTyphoon(function (layer) {
            layer.setWindCircleVisble(visible);
        },this,id);
    },

    /**
     * 设置台风名Tooltip的显隐
     * @method setTooltipVisible
     * @param visible
     * @param id
     */
    setTooltipVisible:function (visible,id) {
        this.eachTyphoon(function (layer) {
            layer.setTooltipVisible(visible);
        },this,id);
    },

    /**
     * 设置影响范围显隐
     * @method setAffectRangeVisible
     * @param visible
     * @param id
     */
    setAffectRangeVisible: function (visible,id){
        this.eachTyphoon(function (layer) {
            layer.setAffectRangeVisible(visible);
        },this,id);
    },

    onAdd: function (map) {
        if(this.almtline && !map.hasLayer(this.almtline))
            map.addLayer(this.almtline);
        L.FeatureGroup.prototype.onAdd.call(this, map);
    },

    onRemove: function (map) {
        if(this.almtline && map.hasLayer(this.almtline))
            map.removeLayer(this.almtline);
        L.FeatureGroup.prototype.onRemove.call(this, map);
    },

    _createAlmtLine:function () {
        this.almtline=L.featureGroup();
        var almtColor = this.options.almtLineColor;
        var labelOpts = this.options.almtLineLabelOpts;

        var latlng_24 = [[0,105],[4.5,113],[11,119],[18,119],[22,127],[34,127]];
        var latlng_48 = [[0,105],[0, 120],[15,132],[34,132]];
        L.polyline(latlng_24, {color: almtColor['24'],weight:2,dashArray:'5,5'}).addTo(this.almtline);
        labelOpts.color = almtColor['24'];
        var labelLayer1 = LW.labelLayer({minZoom: 5,iconOptions:labelOpts}).addTo(this.almtline);
        labelLayer1.setData([{"NAME":"24小时警戒线","LOCATION":[[127,30]]}]);

        L.polyline(latlng_48, {color: almtColor['48'],weight:2,dashArray:'5,5'}).addTo(this.almtline);
        labelOpts = Sun.Util.Data.deepClone(labelOpts);
        labelOpts.color = almtColor['48'];
        var labelLayer2 = LW.labelLayer({minZoom: 5,iconOptions:labelOpts}).addTo(this.almtline);
        labelLayer2.setData([{"NAME":"48小时警戒线","LOCATION":[[132,30]]}]);
    },

    /**
     * 设置警戒线的显隐
     * @method setAlmtLineVisible
     * @param visible
     */
    setAlmtLineVisible:function (visible) {
        if(this.almtline)
            visible?this._map.addLayer(this.almtline):this._map.removeLayer(this.almtline);
    }
});

/**
 * 台风图层
 *
 * Features :
 *      1. 当前台风路径,预报路径
 *      2. 每个台风点的台风预报路径和台风七级、十级风圈
 *      3. 设置buffer展示
 *      4. editData结构：{
 *                          actualItem, // 当前选择的实况点
 *                          forecast:{  // 预报数据，包含预报点，预报点热点，预报风圈半径，预报路径path
 *                              key1:{markers:[],hots:[],radius:[],line,tooltip,text},
 *                              key2:{markers:[],hots:[],radius:[],line,tooltip,text},
 *                              ..
 *                          }
 *                       }
 *
 * Update Note：
 *      + v1.3.0-dev : Created
 *      + v1.5.1 : 1. 实况台风的类型由current改为actual
 *                 2. 增加影响范围及台风编辑的支持
 *                 3. 增加台风播放
 *                 4. 增加showEveryForecast属性，配置是否展示预报台过时的最近预报，在台风编辑时此属性最好为false
 *      + v1.5.3 : 增加获取编辑后数据的方法-getEditData
 *      + v1.5.5 : 1. affectRangeKey改为editKey
 *                 2. 增加hisActualClickable属性，在编辑时该属性配置成false，不允许历史实况进行点击交互
 *                 3. 增加影响范围的显隐功能，优化影响范围的算法，需更新sun@1.0.26
 *
 * @class LW.TypLayer
 * @extends L.FeatureGroup
 * @demo demo/plot/typ.html  {台风}
 */
LW.TypLayer = L.FeatureGroup.extend({
    options:{
        /**
         * 台风等级图例
         * @property levelLegend
         * @type {Array}
         * @default Sun.LegendData.typ.current
         */
        levelLegend:Sun.LegendData.typ.current,
        /**
         * 台风预报路径图例
         * @property forecastLegend
         * @type {Array}
         * @default Sun.LegendData.typ.forecast
         */
        forecastLegend:Sun.LegendData.typ.forecast,
        renderer:L.canvas({pane:'typPane'}),
        underRenderer:L.svg({pane:'shadowPane'}),
        playInterval:100,
        /**
         * 当前台风的icon的样式调整options
         * @property iconOptions
         * @type {Object}
         * @default { radius:5, stroke:false, fillOpacity:1, pane:'typPane' }
         */
        iconOptions:{
            radius:5,
            stroke:false,
            fillOpacity:1,
            pane:'typPane'
        },
        /**
         * 实况路径线宽
         */
        lineWidth:1,
        /**
         * 当前台风的icon的样式调整options
         * @property foreIconOptions
         * @type {Object}
         * @default { radius:5, stroke:true, weight:1, color:'#656565', fillOpacity:1, pane:'typPane' }
         */
        foreIconOptions:{
            radius:5,
            stroke:true,
            weight:1,
            color:'#656565',
            fillOpacity:1,
            pane:'typPane',
            zIndexOffset:500
        },
        /**
         * 预报路径线宽
         * @property foreLineWidth
         * @type {int}
         * @default 2
         */
        foreLineWidth:2,
        /**
         * 被编辑的预报路径线宽
         * @property editForeLineWidth
         * @type {int}
         * @default 3
         */
        editForeLineWidth:3,
        /**
         * 热点的样式调整options
         * @property hotOptions
         * @type {Object}
         * @default { radius:10, stroke:false, pane:'typPane' }
         */
        hotOptions:{
            radius:10,
            stroke:false,
            pane:'typPane',
            zIndexOffset:500
        },
        /**
         * 风圈的样式
         * @property windCircle
         * @type {Object}
         * @default { weight:2, color:'#fff992', fillColor:'#ff9000', fillOpacity:0.4 }
         */
        windCircle:{
            weight:2,
            color:'#fff992',
            fillColor:'#ff9000',
            fillOpacity:0.4,
            renderer:L.canvas({pane:'typPane'})
        },
        /**
         * 最新台风详细框的样式
         * @property windCircle
         * @type {Object}
         * @default { weight:2, color:'#fff992', fillColor:'#ff9000', fillOpacity:0.4 }
         */
        toolTipOptions:{
            direction:'right',
            className:'lw-typ-tooltip',
            offset:L.point(15,0),
            permanent:true
        },
        /**
         * 路径时间文本是否展示
         * @property listTimeVisible
         * @type {Boolean}
         * @default true
         */
        listTimeVisible:true,
        /**
         * 路径时间文本的展示等级
         * @property listTimeShowZoom
         * @type {int}
         * @default 9
         */
        listTimeShowZoom:9,
        /**
         * 路径时间文本的样式，默认的样式在
         * @property listTimeShowZoom
         * @type {Object}
         * @default {className:'lw-typ-tooltip-list',permanent:true}
         */
        listTimeOptions:{
            className:'lw-typ-tooltip-list',
            permanent:true
        },

        /**
         * 是否展示影响范围
         * @property showAffectRange
         * @type {Boolean}
         * @default false
         */
        showAffectRange:false,
        /**
         * 影响范围的首个圈的半径
         * @property firstRadius
         * @type {int}
         * @default 0
         */
        firstRadius:0,
        /**
         * 影响范围的默认半径间隔
         * @property radiusGap
         * @type {int}
         * @default 30
         */
        radiusGap:30,
        /**
         * 影响范围的样式，geojson的样式配置
         * @property affectRangeStyle
         * @type {Object}
         */
        affectRangeStyle:{
            weight:1,
            color:'#ffc366',
            smoothFactor:0.01,
            noClip:true
        },

        /**
         * 被编辑的预报路径的key,影响范围，标注都用该key的预报路径
         * @property editKey
         * @type {String}
         * @default '北京'
         */
        editKey :'北京',

        /**
         * 历史实况是否可点击，在预报路径编辑时不需要历史实况编辑，需将该属性设置为false
         * @property hisActualClickable
         * @type {boolean}
         * @default true
         */
        hisActualClickable:true,

        /**
         * 是否展示预报台过时的最近预报，在台风编辑时此属性最好为false
         * TypProxy中的预报数据，当前实况点关联的预报数据有可能存储历史实况点关联的最新的预报数据，方便展示预报台过时的最近预报
         * Q: 为什么不存储最近预报的实况id?
         * @property showEveryForecast
         * @type {boolean}
         * @default true
         */
        showEveryForecast:true,

        editable:false
    },

    initialize:function (options) {
        L.setOptions(this,options);
        L.FeatureGroup.prototype.initialize.call(this,options);
        this.actualTyp = L.featureGroup();
        this.forecastTyp = L.featureGroup();
        this.affectRange = L.geoJson(null,this.options.affectRangeStyle);
        // this.options.windCircle.renderer = this.options.renderer;//Tip:共用一个renderer，多个台风，风圈出现有的实线有的虚线的情况
        this.quadCircle7 = LW.quadCircle([0,0],this.options.windCircle);
        this.quadCircle10 = LW.quadCircle([0,0],this.options.windCircle);

        var icon = L.icon({
            iconUrl: LW.defaultIconPath()+'typ.gif',
            iconSize: [30, 30],
            zIndexOffset:1000
        });
        this.typGif = L.marker([0,0], {icon: icon,interactive:false,pane:'typPane',zIndexOffset:1000})
            .bindTooltip('',this.options.toolTipOptions);

        this.affectRadius={};
    },

    _affectRangeVisible:true,

    onAdd: function (map) {
        map.addLayer(this.quadCircle7);
        map.addLayer(this.quadCircle10);
        map.addLayer(this.forecastTyp);
        if(this._affectRangeVisible)
            map.addLayer(this.affectRange);
        map.addLayer(this.actualTyp);
        map.addLayer(this.typGif);
        map.on('zoomend',this._zoomend, this);
        L.LayerGroup.prototype.onAdd.call(this, map);
        this._zoomend();
    },

    onRemove: function (map) {
        map.removeLayer(this.quadCircle7);
        map.removeLayer(this.quadCircle10);
        map.removeLayer(this.actualTyp);
        map.removeLayer(this.forecastTyp);
        map.removeLayer(this.affectRange);
        map.removeLayer(this.typGif);
        map.off('zoomend',this._zoomend, this);
        L.LayerGroup.prototype.onRemove.call(this, map);
    },

    _zoomend:function () {
        if(this._map){
            var zoom = this._map.getZoom(),showZoom = this.options.listTimeShowZoom;
            if(this.options.listTimeVisible && this.actualTypList){
                this.actualTypList.forEach(function (m) {
                    zoom<showZoom ?m.closeTooltip() : m.openTooltip();
                })
            }
        }
    },

    /**
     * 设置预报路径显影
     * @method setForePathVisible
     * @param visible
     */
    setForePathVisible:function (visible) {
        visible?this._map.addLayer(this.forecastTyp):this._map.removeLayer(this.forecastTyp);
    },

    /**
     * 设置风圈显影
     * @method setWindCircleVisble
     * @param visible
     */
    setWindCircleVisble:function (visible) {
        visible?this._map.addLayer(this.quadCircle7):this._map.removeLayer(this.quadCircle7);
        visible?this._map.addLayer(this.quadCircle10):this._map.removeLayer(this.quadCircle10);
    },

    /**
     * 设置最新台风详细框显隐
     * @method setTooltipVisible
     * @param visible
     */
    setTooltipVisible:function (visible) {
        visible?this.typGif.openTooltip():this.typGif.closeTooltip();
    },

    /**
     * 设置台风数据
     * @method setData
     * @param data
     * @param isPlay 是否播放
     * @returns {LW.TypLayer}
     */
    setData:function (data,isPlay) {
        this.data = data;
        this.curID = null;//当前实况ID
        this.typID = data.ID;//台风ID
        this.bounds = L.latLngBounds();

        this.clearLayers();
        // 展示实况路径详细
        isPlay ? this._playActualTyp(data.DETAIL,data.NAME):this._setActualTyp(data.DETAIL,data.NAME);
        /**
         * 设置数据时会发出该事件，编辑连接器可以根据需要，用该数据刷新tooltip
         * @event setData
         * @param typID {string} 台风ID
         */
        this.fire('setData',{typID:data.ID},true);
        return this;
    },

    /**
     * 获取当前台风边界
     * @method getBounds
     * @param latlng
     * @returns {L.LatLngBounds}
     */
    getBounds:function (latlng) {
        if(latlng)
            this.bounds.extend(latlng);
        return this.bounds;
    },

    // 展示台风gif
    _setTypGif:function(detail,name){
        var detail0 = detail[0];
        var latlng = [detail0.LATITUDE,detail0.LONGITUDE];
        var date = new Date(detail0.HAPPENTIME.replace(/-/g, '/'));
        this.typGif.setLatLng(latlng)
            .setTooltipContent(name + ' '+ date.format('MM月dd日 hh时')).openTooltip();
    },

    // 播放实况台风路径
    _playActualTyp:function(detail,name){
        this.actualTyp.clearLayers();
        this.actualTypList = [];
        var self = this,i = detail.length-1;
        var item1 = detail[0],item2 = detail[i];
        var latlngBounds = L.latLngBounds([[item1["LATITUDE"], item1["LONGITUDE"]],[item2["LATITUDE"], item2["LONGITUDE"]]]);
        this._map.fitBounds(latlngBounds);
        var interval = setInterval(function () {
            if(i>=0){
                self._setActualItem(detail[i],i>0?detail[i-1]:null,true);
                i--;
                // self._zoomend();
            }
            else{
                clearInterval(interval);
                self._setTypGif(detail,name);
            }
        },this.options.playInterval);
    },

    // 设置实况台风路径
    _setActualTyp:function (detail,name) {
        this.actualTyp.clearLayers();
        this.actualTypList = [];
        for(var i=0;i<detail.length;i++){
            this._setActualItem(detail[i],i>0?detail[i-1]:null,i==0);
        }
        this._setTypGif(detail,name);
        this._zoomend();
    },

    // 设置实况台风路径item
    _setActualItem:function(item,item2,settingCurId){
        var self = this;

        var latlng = L.latLng(item["LATITUDE"], item["LONGITUDE"]);
        this.bounds.extend(latlng);

        var opts = this.options.iconOptions,hotOpts = this.options.hotOptions;
        opts.renderer = this.options.renderer;
        opts.fillColor=hotOpts.fillColor=this._getColor(item);

        var m = L.circleMarker(latlng, opts).addTo(self.actualTyp);
        // Tip:此处的closeTooltip并不能关闭Tooltip
        var date = new Date(item.HAPPENTIME.replace(/-/g, '/'));
        if(item2) m.bindTooltip(date.format('MM月dd日 hh时'),this.options.listTimeOptions).closeTooltip();
        this.actualTypList.push(m);
        var hot = L.circleMarker(latlng, hotOpts).addTo(this.actualTyp);
        hot.id = item.ID;
        hot.data = item;
        if(item2){// Tip: 两个点时才绘制实况路径
            var latlng2 = L.latLng(item2["LATITUDE"], item2["LONGITUDE"]);
            L.polyline([latlng,latlng2], {color: opts.fillColor,weight:this.options.lineWidth,renderer:this.options.renderer}).addTo(this.actualTyp);
        }
        if(settingCurId){
            // Tip: 是否设置id的相关其他展示，播放时依次设置，不播放时就最新点设置
            this.firstID = item.ID;
            this.setCurID(item.ID,m,hot,!!item2,true);
        }
        var clickable = this.options.hisActualClickable;
        if(clickable || (!clickable && settingCurId))
            hot.on("click", function (e) {
                e.originalEvent.stopPropagation();
                self.setCurID(e.target.id,m,hot);
            });
        onMouseEvent(m,hot);

        function onMouseEvent(marker, hot) {
            hot.on("mouseover", function (e) {
                e.originalEvent.stopPropagation();
                self.fire('mouseover',{markerType:'actual',marker:marker,hot:hot},true);
            });
            hot.on("mouseout", function (e) {
                e.originalEvent.stopPropagation();
                self.fire('mouseout',{markerType:'actual',marker:marker,hot:hot},true);
            });
        }
    },


    /**
     * 设置预报站点
     * @method setForeStations
     * @param foreStations
     */
    setForeStations:function (foreStations) {
        this.foreStations = foreStations;
        if(this.curID && this.curLatlng){
            this._setForecastTyp(this.curID,this.curLatlng);
            /**
             * 重设预报台站时会发出该事件，编辑连接器可以根据需要，侦听该事件刷新tooltip
             * @event setForeStations
             */
            this.fire('setForeStations',{},true);
        }
    },

    _hasForeStation:function (station) {
        return this.foreStations&&this.foreStations.indexOf(station)!=-1;
    },

    // 设置预报路径
    _setForecastTyp:function (id,_latlng) {
        this.forecastTyp.clearLayers();
        var fDetail = this.data.FORECAST_DETAIL[id];
        var self = this;

        if(fDetail){
            for (var key in fDetail) {
                if(this._hasForeStation(key))
                    drawOneForePath(key,fDetail[key],this._getForecastColor(key));
            }
        }
        // 更新影响范围
        this.setAffectRange(id,_latlng, true);

        function drawOneForePath(key,data,color) {
            // Tip: 预报路径从当前点开始预报，或者属性为所有最近预报都展示才展示该预报路径
            var options = self.options;
            if(data && data.length>0) {
                if (options.showEveryForecast || data[0].TYPHOONDETAILID === id) {
                    var latlng0 = L.latLng(data[0].TYPHOONDETAILLAT, data[0].TYPHOONDETAILLON);
                    var latlngs = [latlng0];
                    var markers = [];
                    var hots = [];
                    var affectRadius = [];// 如果数据有AFFECTRADIUS字段用，该字段，如果没有，则使用默认算法。
                    data.forEach(function (item, index) {
                        var latlng = L.latLng(item["LATITUDE"], item["LONGITUDE"]);
                        latlngs.push(latlng);
                        var opts = options.foreIconOptions;
                        opts.fillColor = self._getColor(item);
                        var marker = L.circleMarker(latlng, opts).addTo(self.forecastTyp);
                        var hotOpts = {radius: 10, stroke: false, fillOpacity: 0, pane: "typPane"};
                        var hot = L.circleMarker(latlng, hotOpts).addTo(self.forecastTyp);
                        hot.id = item.ID;
                        hot.index = index + 1;// Tip: 预报路径和概率半径多个实况点，所以index+1以对应路径和概率半径数据
                        hot.key = key;
                        hot.data = item;
                        onMouseEvent(marker,hot);
                        markers.push(marker);
                        hots.push(hot);
                        if (item.AFFECTRADIUS) {
                            if (affectRadius.length == 0)
                                affectRadius.unshift(self.editData.actualItem.data.AFFECTRADIUS || options.firstRadius);
                            affectRadius.push(item.AFFECTRADIUS);
                        }
                    });
                    var lineWidth = key == options.editKey ? options.editForeLineWidth : options.foreLineWidth;
                    var line = L.polyline(latlngs, {
                        color: color, weight: lineWidth, dashArray: '5,5',
                        renderer: options.renderer
                    }).addTo(self.forecastTyp);
                    self.editData.forecast[key] = {
                        data: data, markers: markers, hots: hots, line: line,
                        tooltips: {}, texts: '', radius: affectRadius/*self.data.editRadius*/
                    };
                }
            }

            function onMouseEvent(marker, hot) {
                hot.on("click", function (e) {
                    e.originalEvent.stopPropagation();
                    self.setForeID(e.target.id, e.target.key, marker, hot);
                });
                hot.on("mouseover", function (e) {
                    e.originalEvent.stopPropagation();
                    self.fire('mouseover',{markerType:'forecast',marker:marker,hot:hot},true);
                });
                hot.on("mouseout", function (e) {
                    e.originalEvent.stopPropagation();
                    self.fire('mouseout',{markerType:'forecast',marker:marker,hot:hot},true);
                });
            }
        }
    },


    setCurID:function (id,marker,hot,play,dataTrigger) {
        // 设置风圈
        var item = Sun.Util.Array.getItemByField(this.data.DETAIL,'ID',id);
        if(this.curID != id){
            var editable = this.options.editable;
            if((editable && id == this.firstID) || !editable) {//不允许历史实况的编辑
                this.curID = id;
                this.curLatlng = [item.LATITUDE, item.LONGITUDE];
                this.quadCircle7.setLatLng(this.curLatlng);
                this.quadCircle7.setRadius({
                    NE: item.WINDRADIUS7NE * 1000, NW: item.WINDRADIUS7NW * 1000,
                    SE: item.WINDRADIUS7SE * 1000, SW: item.WINDRADIUS7SW * 1000
                });

                var radius = item.WINDRADIUS10 ? {
                    NE: item.WINDRADIUS10NE * 1000, NW: item.WINDRADIUS10NW * 1000,
                    SE: item.WINDRADIUS10SE * 1000, SW: item.WINDRADIUS10SW * 1000
                } : {NE: 0, NW: 0, SE: 0, SW: 0};
                this.quadCircle10.setLatLng([item.LATITUDE, item.LONGITUDE]);
                this.quadCircle10.setRadius(radius);

                if (!play) {
                    this.editData = {actualItem: hot, forecast: {}};
                    // 更新预报路径展示
                    this._setForecastTyp(id, this.curLatlng);
                }
            }
        }

        if(!play)
            this.fire('click',{markerType:'actual',typID:this.data.ID,item:item,marker:marker,hot:hot,dataTrigger:dataTrigger},true);
    },

    setForeID:function (id,key,marker,hot) {
        var data = this.data.FORECAST_DETAIL[this.curID][key];
        var item = Sun.Util.Array.getItemByField(data,'ID',id);
        if(!marker && this.editData){
            var forecast = this.editData.forecast[key];
            hot = Sun.Array.getItemByField(forecast.hots,'id',id);
            marker = forecast.markers[hot.index-1];
        }
        this.fire('click',{markerType:'forecast',typID:this.data.ID,item:item,marker:marker,hot:hot},true);
    },

    /**
     * 设置影响范围
     * @method setAffectRange
     * @param id
     * @param _latlng
     * @param isNewRadius
     */
    setAffectRange:function(id,_latlng,isNewRadius){
        var options = this.options;
        this.affectRange.clearLayers();
        var affectKey = options.editKey;
        if(options.showAffectRange && this._hasForeStation(affectKey)){
            var curForecastData = this.editData.forecast[affectKey];
            if(curForecastData){
                var data = curForecastData.line.getLatLngs();
                if(data && data.length>0) {
                    /**
                     * Tip: 1. radius第一个是实况的半径,通过索引定位指定的半径
                     *      2. 如果数据中无AFFECTRADIUS数据，则使用累加计算出
                     */
                    var radius = curForecastData.radius;
                    if (isNewRadius && !radius.length) {
                        // radius = [];
                        for (var i = 0, r = this.options.firstRadius; i < data.length; i++, r += this.options.radiusGap) {
                            radius.push(r);
                        }
                        curForecastData.radius = radius;
                        this.refreshData();
                        /**
                         * 初始化影响范围半径时发出该事件
                         * @event initAffectRadius
                         * @param radius {array} 初始化的影响范围半径数据
                         */
                        this.fire('initAffectRadius',{radius:radius},true);
                    }

                    try{
                        var union, p1, p2;
                        for (var i = 1; i < data.length; i++) {
                            p1 = [data[i - 1].lng, data[i - 1].lat];
                            p2 = [data[i].lng, data[i].lat];
                            var r1 = radius[i - 1], r2 = radius[i];
                            var d = data[i].distanceTo(data[i - 1])/1000;
                            if(r2-r1<d){//Tip: 若圆2包含圆1则无公切线，直接采用圆2作为影响范围的区域
                                // if (i === 1) { // 实况点和第一个预报点
                                //     if (r1 === 0) {
                                //         var tengents = Sun.Util.Geometry.tangent(p1, p2, r2);
                                //         union = turf.polygon([[p1].concat(tengents).concat([p1])]);
                                //     }
                                //     else {
                                //         var publicTengents = Sun.Util.Geometry.publicTangent(p1, r1, p2, r2);
                                //         union = getUnion(publicTengents, p1, r1)
                                //     }
                                // }
                                // else {
                                    var publicTengents = Sun.Util.Geometry.publicTangent(p1, r1, p2, r2);
                                    union = i == 1 ? getUnion(publicTengents, p1, r1) :
                                        turf.union(union, getUnion(publicTengents));
                                // }
                            }
                            var circle2 = getUnion(null, p2, r2);
                            union = union ? turf.union(union,circle2) : circle2;
                        }
                        this.affectRange.addData(union);
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
            }

            // 设置切点，并获取合并后的图形
            function getUnion(publicTengents,p,radius) {
                var _union;
                if(publicTengents){
                    // var t1 = publicTengents[0].geometry.coordinates,t2 = publicTengents[1].geometry.coordinates;
                    // Tip: sun@1.0.26返回的公切线格式
                    var t1 = publicTengents[0],t2 = publicTengents[1];
                    tengents = [t1[1],t2[1]];
                    var coords = t1.concat(t2.reverse()).concat([t1[0]]);
                    _union = turf.polygon([coords]);
                }

                if(p && radius){
                    var circle = turf.circle(p, radius, 64, 'kilometers');
                    // self.affectRange.addData(circle);
                    _union = _union ? turf.union(circle, _union) : circle;
                }
                return _union;
            }
        }
    },


    /**
     * 设置影响范围的显隐
     * @method setAffectRangeVisible
     * @param visible
     */
    setAffectRangeVisible:function (visible){
        this._affectRangeVisible = visible;
        if(visible)
            this._map.addLayer(this.affectRange);
        else
            this._map.removeLayer(this.affectRange);
    },

    /**
     * 重置影响范围样式
     * @method resetAffectRangeStyle
     * @param style
     */
    resetAffectRangeStyle: function (style){
        this.options.affectRangeStyle = L.Util.extend(this.options.affectRangeStyle, style);
        this.affectRange.setStyle(this.options.affectRangeStyle);
    },

    /**
     * 刷新编辑后的数据，并返回精简的编辑后的数据
     * @method refreshData
     * @param key {string} 预报路径key
     * @return data {object} 当前实况点的编辑后的预报路径的保存数据，不含台风实况历史信息
     */
    refreshData:function(key){
        key = key || this.options.editKey;
        var editData = this.editData;
        var curForecast = editData.forecast[key];
        var actualItem = editData.actualItem;
        var data = {FORECAST:{},ACTUAL:{ID:actualItem.id,AFFECTRADIUS:curForecast.radius[0]}};
        if(curForecast){
            var forecast = [];
            for(var i =0; i<curForecast.hots.length;i++){
                var hot = curForecast.hots[i];
                var item = hot.data;
                var latlng = hot.getLatLng();
                item.LATITUDE = latlng.lat;
                item.LONGITUDE = latlng.lng;
                item.AFFECTRADIUS = curForecast.radius[i+1];
                var tooltip = curForecast.tooltips[hot.id];
                if(tooltip)
                    item.TOOLTIP = {text:tooltip.text,boxOffset:tooltip.options.boxOffset};
                forecast.push(item);
            }
            data['FORECAST'][key] = forecast;
            actualItem.data.AFFECTRADIUS = curForecast.radius[0];
            tooltip = curForecast.tooltips[actualItem.id];
            if(tooltip){
                data['ACTUAL'].TOOLTIP={text:tooltip.text,boxOffset:tooltip.options.boxOffset};
                actualItem.data.TOOLTIP = {boxOffset: tooltip.options.boxOffset};
            }

            return data;
        }
    },
    /**
     * 获取编辑后的预报数据方法，国家海洋局的台风编辑保存结构，含台风实况历史信息
     * @method getEditData
     * @param key
     */
    getEditData:function(key){
        key = key || this.options.editKey;
        var data = Sun.Util.Data.deepClone(this.data);
        var editData = this.editData;
        var curForecast = editData.forecast[key];
        if(curForecast){
            var forecast = [];
            for(var i =0; i<curForecast.hots.length;i++){
                var hot = curForecast.hots[i];
                var item = hot.data;
                var latlng = hot.getLatLng();
                item.LATITUDE = latlng.lat;
                item.LONGITUDE = latlng.lng;
                forecast.push(item);
            }
            data.FORECAST_DETAIL = {};
            // data.FORECAST_DETAIL[editData.actualItem.id] = {'edit':forecast};
            data.FORECAST_DETAIL[editData.actualItem.id] = {};
            data.FORECAST_DETAIL[editData.actualItem.id][key] = forecast;
            data.editRadius = curForecast.radius;
            return data;
        }
    },

    /**
     * 设置buffer
     * @method setBuffer
     * @param start {string} 开始时间：2018-06-09 08:00:00
     * @param end {string} 结束时间：2018-06-10 20:00:00
     * @param radius {number} 半径，单位：公里
     */
    setBuffer:function (start,end,radius) {
        var i_start = Sun.Util.Array.getItemIndexByField(this.data.DETAIL,'HAPPENTIME',end);
        var i_end = Sun.Util.Array.getItemIndexByField(this.data.DETAIL,'HAPPENTIME',start);
        var data = this.data.DETAIL.slice(i_start,i_end+1);
        var line = data.map(function (item) {
            return [item.LONGITUDE,item.LATITUDE];
        });
        line = line.length>1?turf.lineString(line):turf.point(line[0]);
        var buffered = turf.buffer(line, radius, 'kilometers');
        var latlngs = buffered.geometry.coordinates[0].map(function (item) {
            return [item[1],item[0]];
        });
        if(!this.buffer)
            this.buffer = L.polygon(latlngs, {color:'#fff', fill:true, weight: 1,renderer:this.options.underRenderer});
        else
            this.buffer.setLatLngs(latlngs);
        if(!this.actualTyp.hasLayer(this.buffer))
            this.actualTyp.addLayer(this.buffer);
    },

    /**
     * 移除buffer
     * @method removeBuffer
     */
    removeBuffer:function () {
        if(this.buffer && this.actualTyp.hasLayer(this.buffer))
            this.actualTyp.removeLayer(this.buffer);
    },

    _getColor: function (item) {
        return Sun.Util.LegendData.getColor(this.options.levelLegend, item["TYPHOONTYPE"]);
    },

    _getForecastColor: function (station) {
        return Sun.Util.LegendData.getColor(this.options.forecastLegend, station);
    },
});
/**
 * @class LW.TypLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.TypLayer}
 */
LW.typLayer = function (options) {
    return new LW.TypLayer(options);
};

/**
 * CS图层
 * @module Layer.CS
 */
/**
 * CS 站点基础Marker
 *
 * Features :
 *      1. 设置options.minZoom/maxZoom控制marker的最大最小显示等级
 *      2. 可重设style以设置自己特色的样式，忽略layer's options的统一样式;属性名与layer's options一致
 *      3. Tip: style中的name,value属性用于判断是否启用style中关于name,value等相关的样式，
 *              而options中的name,value用于控制显隐
 *
 * Update Note：
 *      + v1.5.0 ：Created
 *      + v1.5.1 : 增加图片可以旋转的支持
 *      + v1.5.5 : 图片旋转在dpr不为1时显示异常的问题修复
 *
 * @class LW.CsBaseMarker
 * @extends L.Class
 */
LW.CsBaseMarker = L.Class.extend({
    options:{
        minZoom:0,
        maxZoom:18
    },

    // icon 的 size 缩放比例，会在缩放时重置该系数
    scale:1,

    initialize: function (latlng,data,options) {
        L.stamp(this);
        L.setOptions(this,options);
        this.style = { };
        this.setData(latlng,data);
    },

    setData:function(latlng,data){
        this.data = data;
        this._latlng = L.latLng(latlng);
        return this;
    },

    getLatLng: function () {
        return this._latlng;
    },

    /**
     * marker显隐 顺序优先级：
     *          1) LOD && data.minZoom>zoom>data.maxZoom
     *          2) options.styles[styleKey].minZoom>zoom>options.styles[styleKey].maxZoom
     *          3) options.minZoom > zoom > options.maxZoom
     * @param zoom {int} 地图等级
     * @param isLOD {boolean} 是否分级
     * @param options {object}
     * @returns {boolean|boolean|*}
     */
    visible: function(zoom,isLOD,options){
        if(isLOD && !isNaN(this.data.minZoom) && !isNaN(this.data.maxZoom))
            return zoom >= this.data.minZoom && zoom <= this.data.maxZoom;
        else if(this._isReOption('minZoom',options) && this._isReOption('maxZoom',options))
            return zoom >= this._getOption('minZoom',options) && zoom <= this._getOption('maxZoom',options);
        else if (options.hasOwnProperty('visible'))// multiLabelLayer
            return options.visible;
        else
            return zoom >= options.minZoom && zoom <= options.maxZoom;
    },

    // _getOption:function(name,options){
    //     return this.style.hasOwnProperty(name) ? this.style[name] : options[name];
    // },
    // 根据样式识别顺序获取样式: marker.style > options.styles[marker.data.styleKey] > options
    _getOption:function(name,options){
        var dataStyle;
        var style = this.style.hasOwnProperty(name) ? this.style :
            (options.styles && (dataStyle = options.styles[this.data.styleKey]), dataStyle &&
            dataStyle.hasOwnProperty(name) ? dataStyle : options);
        return style[name];
    },

    // marker是否有重置options
    _isReOption:function (name,options){
        var dataStyle;
        return this.style.hasOwnProperty(name) ? true:
            ( options.styles && (dataStyle = options.styles[this.data.styleKey]), dataStyle &&
            dataStyle.hasOwnProperty(name)  ?  true : false);
    },


    _drawDot:function (ctx,pos,options) {
        // Tip: 由于取图片为异步，初次载入时可能地图已经被拖动，会渲染无用的图片，故将位置保存
        this.position = pos;
        var self = this;
        if(this._getOption('dot',options)){
            var dotType = this._getOption('dotType',options);
            if(dotType === 'circle' || dotType==='triangle' || dotType==='rect'){
                var a = dotType==='circle'?(this._getOption('radius',options)):(this._getOption('side',options)),
                    fill = this._getOption('fill',options),
                    stroke = this._getOption('stroke',options),
                    strokeWidth = this._getOption('strokeWidth',options);
                var _dot = LW.VectorCache[dotType](a,fill,stroke,strokeWidth,this._getOption('dotRotation',options));
                ctx.drawImage(_dot,pos.x-_dot.width/2,pos.y-_dot.height/2);
            }
            else if(dotType==='image' || dotType==='dyImage'){
                var src = dotType==='dyImage' && options.dyImageUrlFun ?
                    options.dyImageUrlFun(this.data,options):options.imageUrl;
                var imgSize = src.imageSize || this._getOption('imageSize',options);
                var imageAnchor = src.imageAnchor || this._getOption('imageAnchor',options);
                var rotate = src.dotRotation || this._getOption('dotRotation',options);
                src = src.url ? src.url : src;
                this._drawImage(ctx,src,-imageAnchor[0],-imageAnchor[1],imgSize[0], imgSize[1],rotate);
            }
            else if(dotType === 'iconfont'){
                ctx.fillStyle=  this._getOption('fill',options);
                ctx.font= this._getOption('dotIconfont',options);
                var unicode = this._getOption('dotUnicode',options);
                var _unicode = typeof unicode == "function" ? unicode(this.data) : unicode;
                var icon = eval(('("'+_unicode).replace('&#x','\\u').replace(';','')+'")');
                var anchor = this._getOption('imageAnchor',options);
                ctx.textAlign = 'center';
                var stroke = this._getOption('stroke',options);
                if(stroke){
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = this._getOption('strokeWidth',options);
                    ctx.strokeText(icon, pos.x, pos.y+anchor[1]);
                }
                ctx.fillText(icon, pos.x, pos.y+anchor[1]);
            }
        }
    },

    _drawName:function (ctx,pos,options) {
        this.name = this.data[options.nameField];
        if(this._getOption('name',options))
            this._drawText(ctx,pos,options,this.name,'name');
    },

    _drawTime:function (ctx, pos, options,item) {
        if(this._getOption('time',options)){
            var time = this.data[options.timeField] || item[options.timeField];
            var timeText = time?new Date(time.replace(/-/g, '/')).format(options.timeFormat):'';
            this._drawText(ctx,pos,options,timeText,'time');
        }
    },

    _drawLabel: function(ctx,pos,options) {
        if(options.visible){
            var label = this.data[options.field] || '';
            this._drawText(ctx,pos,options,label,'');
        }
    },

    _drawText:function (ctx,pos,options,text,key){
        var offset = this._getOption(key+'_offset',options) || {x:0,y:0};
        if(this._getOption(key+'_font',options))
            ctx.font = this._getOption(key+'_font',options);
        if(this._getOption(key+'_stroke',options)){
            ctx.strokeStyle = this._getOption(key+'_stroke',options);
            if(this._getOption(key+'_lineWidth',options))
                ctx.lineWidth = this._getOption(key+'_lineWidth',options);
            ctx.strokeText(text, pos.x + offset.x, pos.y+offset.y);
        }
        if(this._getOption(key+'_color',options))
            ctx.fillStyle = this._getOption(key+'_color',options);
        ctx.fillText(text, pos.x + offset.x, pos.y+offset.y);
    },

    _drawImage : function (ctx,src, x, y, width, height, rotate) {
        var self = this;
        LW.ResourceCache.getImage(src, function (img) {
            // var x = positions[src].x, y = positions[src].y;
            if(self.hide) return;
            var _x = self.position.x + x, _y = self.position.y + y;
            if (rotate) {//如果有rotate，则旋转
                var x0 = _x + width / 2, y0 = _y + height / 2;
                ctx.translate(x0, y0);
                ctx.rotate(rotate * Math.PI / 180);
                ctx.translate(-x0, -y0);
            }
            ctx.drawImage(img, _x, _y, width, height);
            if (rotate)
                ctx.setTransform(Sun.Common.dpr, 0, 0, Sun.Common.dpr, 0, 0);
        });
    }
});

LW.csBaseMarker = function (latlng,data,options) {
    return new LW.CsBaseMarker(latlng,data,options);
};

// 自动站marker(带value)
LW.CsZdzMarker = LW.CsBaseMarker.extend({
    _setValue : function (options) {
        var value = this.value = this.data[options.valueField];

        if (Sun.Common.isValid(value)) {
            if (options.valueScale !== 1) {
                value = value * options.valueScale;
                value = this.value = Sun.Util.Math.toFixed(value, 3);
            }
        }
        return value;
    },

    _setFill:function (options){
        var legendData = this._getOption('legendData',options);
        if(legendData) {
            var color;
            if (typeof legendData == 'function')
                this.style.fill = legendData(this.data, this.value);
            else if (legendData.length > 0) {
                color = Sun.Util.LegendData.getColorOfRangeLegend(legendData, this.value, options.fill);
                this.style.fill = color;
                if (options.windVaneColorful)
                    this.style.wind_color = value > options.windVaneColorfulValue ? color : options.wind_color;
            }
        }
    },

    _drawDot:function (ctx,pos,options) {
        this._setFill(options);
        LW.CsBaseMarker.prototype._drawDot.call(this,ctx,pos,options);
    },

    _drawValue:function (ctx,pos,options) {
        if(this._getOption('value',options)){
            var value = this.value;
            var label = (parseFloat(value) == 0 &&!options.showZero) ||
                isNaN(parseFloat(value)) ? '' : value;
            if(options.valueFn)
                label = options.valueFn(value,this.data);
            this._drawText(ctx,pos,options,label,'value');
        }
    },

    _drawWind:function (ctx,pos,options) {
        var dir = this.dir = this.data[options.dirField];
        if(this.style.wind_color){// 跟随图例变色
            ctx.strokeStyle = this.style.wind_color;
            ctx.fillStyle = this.style.wind_color;
        }
        if(dir && this.value){
            Sun.Util.Geometry.drawWindByPosition(ctx,this.value,dir,pos,true,options.wind_height,options.wind_width,null,
                options.windVaneStroke,options.windVaneStrokeWidth);
        }
    }
});

LW.csZdzMarker = function (latlng,data,options) {
    return new LW.CsZdzMarker(latlng,data,options);
};

// 多icon marker
LW.CsMultiIconMarker = LW.CsZdzMarker.extend({
    _setWidth:function(options){
        var items = this.data.data,mIconSize = options.mIconSize,scale = this.scale;
        // this.width = items.length*options.mIconSize[0]+(items.length-1)*options.mIconGap;
        this.width = getWidth()+(items.length-1)*options.mIconGap;

        function getWidth(){
            var w=0;
            return mIconSize ? items.length*mIconSize[0]*scale : (items.forEach(function (item){w+=item.size[0]*scale}),w);
        }
    },
    getIcon:function(x,y,options){
        var pos = this.position,items = this.data.data,w = this.width,scale = this.scale;
        // var iw = options.mIconSize[0],ih = options.mIconSize[1],iy = options.mIcon_y||-options.mIconSize[1]/2;
        // var in_y = (y-pos.y)<(iy+ih);
        // if(in_y){
        //     var idx_x = Math.floor((x-pos.x+this.width/2)/(iw+options.mIconGap));
        //     var offset_x = -this.width/2+idx_x*(iw+options.mIconGap)+iw/2;
        //     return {index:idx_x,data:this.data.data[idx_x],offset:{x:offset_x,y:iy}};
        // }
        return getIndexItem();


        function getIndexItem(){
            var idxItem,w1 = x-(pos.x-w/2);
            for(var i=0,w_i=0;i<items.length;i++){
                var item = items[i];
                var size = item.size || options.mIconSize;
                size = [size[0]*scale,size[1]*scale];// 根据scale重置大小
                w_i += size[0]+options.mIconGap;
                if(w_i >= w1){
                    var iy = options.mIcon_y || -size[1]/2;
                    if((y-pos.y)<(iy+size[1]))
                        idxItem = {index : i,offset : {x:-w/2+w_i-size[0]/2,y:iy},data:item}
                    break;
                }
            }
            return idxItem;
        }
    },
    _drawMultiIcon:function (ctx, pos, options, zoom) {
        var items = this.data.data;

        // Tip: 由于取图片为异步，初次载入时可能地图已经被拖动，会渲染无用的图片，故将位置保存
        this.position = pos;
        var w = this.width,self = this,positions = {};
        var x_i = -w/2;
        this.apngIcons = [];
        var scale = this.scale

        for(var i=0;i<items.length;i++) {
            var item = items[i];
            // 绘制图标
            var src = options.mIconUrlFun(item);
            // Tip: 由于取图片为异步，初次可能再载入时地图已经被拖动，会渲染无用的图片，故将位置保存
            // positions[src] = {x: x, y: y};
            // Tip: 图标的大小可以由外部数据单独限定
            var size = item.size || options.mIconSize;
            // var x = -w / 2 + i * (options.mIconSize[0] + options.mIconGap);
            // 根据scale重置大小
            size = [size[0]*scale, size[1]*scale];

            var y = options.mIcon_y || -size[1]/2;
            if(item.isApng)
                this.apngIcons.push({data:{show:true,position:pos,offset:[-x_i,-y],size:size,data:item}})
            else
                this._drawImage(ctx,src, x_i,y,size[0],size[1],item.rotate);
            // 绘制时间
            if (options.time) {
                ctx.font = options.time_font;
                ctx.textAlign = 'center';
                ctx.fillStyle = options.time_color;
                ctx.lineWidth = options.time_lineWidth;
                if (options.time_stroke)
                    ctx.strokeStyle = options.time_stroke;
                this._drawTime(ctx, L.point(pos.x + x_i + size[0] / 2, pos.y), options, item);
            }

            x_i += size[0] + options.mIconGap;
            // 绘制上角标
            if(item.sup){
                for(var j=0;j<item.sup.length;j++){
                    var sup = item.sup[j];
                    if(sup.type == 'text')
                        this._drawText(ctx,{x:pos.x + x_i ,y:pos.y+y},sup.style,sup.value,'');
                    else if(sup.type == 'img'){
                        var sup_src = options.mIconUrlFun(sup);
                        this._drawImage(ctx,sup_src,x_i+sup.offset.x,y+sup.offset.y,sup.size[0],sup.size[1]);
                    }
                }
            }
        }
    }
});
LW.csMultiIconMarker = function (latlng,data,options) {
    return new LW.CsMultiIconMarker(latlng,data,options);
};

// 扇形环marker
LW.CsSectorRingMarker = LW.CsZdzMarker.extend({
    options:{
        ringStroke:'#fff',
        ringWidth:2,
        radius1:40,
        radius2:20
    },
    _drawDot:function (ctx,pos,options) {
        this.position = pos;
        var self = this,lineWidth = options.ringWidth,r1 = options.radius1,r2=options.radius2;
        ctx.strokeStyle = options.ringStroke;
        ctx.lineWidth = lineWidth*2;

        var colors = this.data.colors,color = this.data.color;
        if(colors && colors.length){
            var angel = 360/colors.length;
            for(var i=0,a=0;i<colors.length;i++){
                ctx.fillStyle = colors[i];
                Sun.Geometry.drawSector(ctx,pos.x,pos.y,r1,a,a+=angel);
            }

            if(color)
                ctx.fillStyle = color;
            else
                ctx.globalCompositeOperation= 'destination-out';

            ctx.beginPath();
            ctx.arc(pos.x,pos.y, r2, 0, 2 * Math.PI, false);
            ctx.fill();

            ctx.globalCompositeOperation= 'source-over';
            ctx.lineWidth = lineWidth;
            ctx.arc(pos.x,pos.y, r2, 0, 2 * Math.PI, false);
            ctx.stroke();
        }
    },
});

LW.csSectorRingMarker = function (latlng,data,options) {
    return new LW.CsSectorRingMarker(latlng,data,options);
};


/**
 * CS图层
 * @module Layer.CS
 */

/**
 * CS 站点基础图层
 *
 * Features :
 *      1. 基于r-tree快速查找，需要引用rbush.js
 *      2. 渲染于canvas
 *      3. 可设置属性minZoom/maxZoom控制图层的最大最小显示等级
 *      4. 样式识别顺序: marker.style > options.styles[marker.data.styleKey] > options
 *                     Tip: style中的name,value属性用于判断是否启用style中关于name,value等相关的样式;
 *                          options中的name,value用于控制显隐
 *      5. 层级渲染顺序: options.reformMarkersFn若有对数据顺序的调整 >
 *                     options.sortByDataIndex=true按数据顺序排序 > 空间搜索后默认排序
 *
 *
 * Update Note：
 *      + v1.5.0 : Created
 *      + v1.5.2 : 1. 鼠标移过不同icon的事件增强
 *                 2. 增加dot类型为iconfont的支持
 *      + v1.5.3 : 1. 增加风杆由色谱配色的配置;增加风杆描边的配置,后由在LW中描边写到sun中;
 *      + v1.5.4 : 1. 增加dot类型为apng的支持
 *                 2. 修复分级显示时，被分级筛去的点依然获得事件响应的问题
 *      + v1.5.5 : 1. 拖动自动触发click，将拖动触发的click屏蔽
 *                 2. dotUnicode增加可以配置function的功能
 *                 3. 删除dot的apng配置类型，改为单独的配置属性-apng，并增加apng相关属性配置
 *                 4. 增加unitDraw属性，可以支持marker逐个绘制，并兼容之前为了值总是展示在最高而每个要素逐层绘制的功能
 *                 5. 增加legendData可以配置function的功能
 *                 6. 修复multiLabelLayer展示异常的问题
 *      + v1.5.6 : 1. 增加单图层多种style类别的配置
 *                 2. 增加是否根据数据顺序决定渲染顺序属性sortByDataIndex
 *                 3. 增加options.fill可设置为值无图例对应颜色，或null值的颜色功能
 *                 4. 增加marker.hide用于图片异步绘制时，地图已变动，marker数据已经变动。然后之前的marker依然去绘制的情况
 *                 5. 增加resizeByZoom属性，用于配置icon根据地图等级重置大小，与resizeZooms搭配使用，暂时支持了MultiIcon的重置
 *
 * @class LW.CsBaseLayer
 * @extends LW.CanvasLayer
 * @demo demo/base/cs/csLayer_dyImage.html  {动态图片}
 * @demo demo/base/cs/csLayer_iconfont.html  {iconfont图标}
 * @demo demo/base/cs/csLayer_apng.html  {固定apng}
 * @demo demo/base/cs/csLayer_apng_dy.html  {动态apng}
 * @demo demo/base/cs/csLayer_classify_style.html  {分类样式}
 */
LW.CsBaseLayer = LW.CanvasLayer.extend({
    options:{
        /**
         * 侦听的事件
         * @property events
         * @type {Array}
         * @default ['click','dblclick','contextmenu','mousemove']
         */
        events:['click','dblclick','contextmenu','mousemove'],

        eventCursor:'pointer',
        /**
         * 不冒泡的事件
         * @property nonBubblingEvents
         * @type {Array}
         * @default ['click','dblclick']
         */
        nonBubblingEvents: ['click','dblclick'],
        /**
         * 响应事件的所有目标
         * @property responseAllTargets
         * @type {boolean}
         * @default false
         */
        responseAllTargets:false,
        /**
         * 渲染器
         * @property renderer
         * @type {L.Canvas}
         * @default LW.canvas({pane: 'markerPane'})
         */
        renderer: LW.canvas({pane: 'markerPane'}),
        /**
         * 如果unitDraw配置成true，则每个marker的逐个绘制；
         * 如果配置成false，则各个要素分别绘制，即所有的marker的name一起绘制，所有的value一起绘制，为了保证有的时候有些值要显示在别个marker的上方
         * @property unitDraw
         * @type false
         */
        unitDraw:false,
        /**
         * marker热区的大小，用于marker的鼠标事件判定,不设置会引起鼠标事件无法使用
         * @property hotSize
         * @type {Array}
         * @default [0,0]
         */
        hotSize:[0,0],
        /**
         * marker热区的偏移量
         * @property hotOffset
         * @type {Array}
         * @default {x:0,y:0}
         */
        hotOffset:{x:0,y:0},
        /**
         * Marker 实例
         * @property markerInstance
         * @type {LW.CsBaseMarker}
         * @default LW.csBaseMarker
         */
        markerInstance: LW.csBaseMarker,
        /**
         * 纬度字段名
         * @property latField
         * @type {String}
         * @default 'LAT'
         */
        latField:'LAT',
        /**
         * 经度字段名
         * @property lonField
         * @type {String}
         * @default 'LON'
         */
        lonField:'LON',
        /**
         * 图层展示最小等级
         * @property minZoom
         * @type {int}
         * @default 0
         */
        minZoom:0,
        /**
         * 图层展示最大等级
         * @property maxZoom
         * @type {int}
         * @default 18
         */
        maxZoom:18,
        /**
         * 文本显示的最小等级，即等级大于等于该等级才能显示
         * @property textMinZoom
         * @type {int}
         * @default 7
         */
        textMinZoom:7,
        // --> 站名
        /**
         * 是否展示站名,可选true//false/'overShow'/14(小等级overShow，大等级直接展示的情况)。该选项与其他文本一致
         * @property name
         * @type {Boolean|String|nubmber}
         * @default true
         */
        name:true,
        /**
         * 站名字段
         * @property nameField
         * @type {string}
         * @default 'STATIONNAME'
         */
        nameField:'STATIONNAME',
        /**
         * 站名的颜色
         * @property name_color
         * @type {string}
         * @default '#000'
         */
        name_color:'#000',
        /**
         * 站名的字体
         * @property name_font
         * @type {string}
         * @default '14px Microsoft Yahei'
         */
        name_font:'14px Microsoft Yahei',
        /**
         * 站名描边粗细
         * @property name_lineWidth
         * @type {int}
         * @default 2
         */
        name_lineWidth: 2,
        /**
         * 站名的描边,是否描边/描边的颜色
         * @property name_stroke
         * @type {String|Boolean}
         * @default '#fff'
         */
        name_stroke:'#fff',
        /**
         * 站名的y值，可调整站名y方向上的位置，x方向居中
         * @property name_offset
         * @type {object}
         * @default {x:0,y:20}
         */
        name_offset:{x:0,y:20},

        // --> 中心标识点
        /**
         * 是否展示站点标识点
         * @property dot
         * @type {Boolean}
         * @default true
         */
        dot:true,
        /**
         * 中心点的类型
         *
         * 可选类型 :
         *      1. circle--圆形
         *      2. triangle--三角形
         *      3. image--固定图片，需设置imageUrl
         *      4. dyImage--动态图片，需设置dyImageUrlFun
         *      5. iconfont--iconfont字体图标
         * @property dotType
         * @type {string}
         * @default 'circle'
         */
        dotType:'circle',

        /**
         * dot的填充颜色，dotType为circle或triangle时设置
         * 如果有设置legendData,可设置无图例对应颜色，或null值的颜色
         * @property fill
         * @type {string}
         * @default '#fff'
         */
        fill:'#fff',
        /**
         * dot的描边颜色，dotType为circle或triangle时设置
         * @property stroke
         * @type {string|Boolean}
         * @default false
         */
        stroke:false,
        /**
         * dot的描边的粗细，dotType为circle或triangle时设置
         * @property strokeWidth
         * @type {int}
         * @default 1
         */
        strokeWidth:1,
        /**
         * dot的半径，dotType为circle设置
         * @property radius
         * @type {number}
         * @default 3
         */
        radius:3,

        /**
         * 三角形边长，dotType为triangle时设置
         * @property side
         * @type {int}
         * @default 10
         */
        side:10,

        /**
         * 中心点旋转角度
         * @property dotRotation
         * @type {null|number}
         * @default null
         */
        dotRotation:null,

        /**
         * iconfont字体，dotType为iconfont时设置
         * @property dotIconfont
         * @type {string}
         * @default '20px iconfont'
         */
        dotIconfont:'20px iconfont',

        /**
         * iconfont字体的编码，dotType为iconfont时设置,且为必填项
         * @property dotUnicode
         * @type {string|Function}
         * @default ''
         */
        dotUnicode:'',

        /**
         * 图片地址，dotType为image/apng时设置
         * 如果是dyImageUrlFun，且图片需要叠加再数值下方，则需要将所有的图片配置出来，优先加载。
         * @property imageUrl
         * @type {string|Array}
         * @default ''
         */
        imageUrl:'',
        /**
         * 图片地址方法，dotType为dyImage时设置
         * @property dyImageUrlFun
         * @type {function}
         * @default ''
         */
        dyImageUrlFun:null,
        /**
         * 图片大小，dotType为image或dyImage时设置
         * @property imageSize
         * @type {Array}
         * @default [10,16]
         */
        imageSize:[10,16],
        /**
         * 图片锚点（中心点），一般为图片大小的一半
         * @property imageAnchor
         * @type {Array}
         * @default [5,8]
         */
        imageAnchor:[5,8],

        // -->apng
        /**
         * 是否有apng图片
         * @property apng
         * @type {Boolean}
         * @default false
         */
        apng:false,
        /**
         * apng渲染器,dotType为apng时需设置为LW.canvas()
         * @property renderer
         * @default null
         */
        apngRenderer: null,
        /**
         * 图层用到的所有apng地址.返回单个apng地址或者多个apng地址的数组
         *
         * Tip:
         *      1. 所有配置的apng帧率和帧数必须一致；
         *      2. 事先配置所有要用的apng，是为了事先加载完所有的apng，再在需要绘制的时候不会出现由于apng还未加载而导致的错误
         *
         * @property apngUrl
         * @type {string|Array}
         * @default ''
         */
        apngUrl:'',
        /**
         * Apng地址方法，apngUrl为Array时配置,所有配置的apng帧率和帧数必须一致；
         * @property dyApngUrlFun
         * @type {function}
         * @default ''
         */
        dyApngUrlFun:null,
        /**
         * apng锚点（中心点），一般为图片大小的一半
         * @property apngAnchor
         * @type {Array}
         * @default [5,8]
         */
        apngAnchor:[5,8],


        //--> 时间文本
        /**
         * 是否展示时间文本
         * @property time
         * @type {Boolean}
         * @default true
         */
        time:false,
        /**
         * 时间字段
         * @property timeField
         * @type {string}
         * @default ''
         */
        timeField:'',
        /**
         * 时间文本的颜色
         * @property time_color
         * @type {string}
         * @default '#000'
         */
        time_color:'#000',
        /**
         * 时间文本的字体
         * @property time_font
         * @type {string}
         * @default '12px Microsoft Yahei'
         */
        time_font:'12px Microsoft Yahei',
        /**
         * 时间文本描边粗细
         * @property time_lineWidth
         * @type {int}
         * @default 2
         */
        time_lineWidth: 2,
        /**
         * 时间文本的描边,是否描边/描边的颜色
         * @property time_stroke
         * @type {String|Boolean}
         * @default '#fff'
         */
        time_stroke:'#fff',
        /**
         * 时间文本的y值，可调整站名y方向上的位置，x方向居中
         * @property time_offset
         * @type {number}
         * @default {x:0,y:20}
         */
        time_offset:{x:0,y:20},
        /**
         * 时间文本的格式
         * @property timeFormat
         * @type {String}
         * @default 'MM-dd hh:mm'
         */
        timeFormat: 'MM-dd hh:mm',

        /**
         * 当前展示是否分级
         * @property isLOD
         * @type {Boolean}
         * @default false
         */
        isLOD:false,

        /**
         * 分级模型
         * @property LODModel
         * @type {LW.LODModel|null}
         * @default null
         */
        LODModel:null,

        /**
         * 对markers做渲染前的处理
         *      1. 如对查找出的markers重新排序；对marker根据指定的需求变换样式
         *      2. 按该方法返回的新marker序列绘制
         * @property reformMarkersFn
         * @type {Function|null}
         * @default 'null'
         */
        reformMarkersFn:null,

        /**
         * 是否根据数据顺序决定渲染顺序，即zIndex为数据item的index
         * @property sortByDataIndex
         * @type {boolean}
         * @default false
         *
         */
        sortByDataIndex:false,

        /**
         * 单图层，多种styles
         *      1. 一个key对应一种style
         *      2. 如果该属性不为null，且在数据的item中配置styleKey则使用该key对应的style，否则使用options中的样式
         *      3. 单个style的属性与该options中的属性一致
         *      eg: { key1:{style1} key2:{style2} }
         * @property styles
         */
        styles:null,

        /**
         * 是否根据地图等级重置大小，一般用于重置icon的大小，与resizeZooms搭配使用
         * @property resizeByZoom
         * @type {boolean}
         * @default false
         */
        resizeByZoom:false,

        /**
         * 根据地图等级重置icon size的等级配置，min <= zoom < max
         * @property resizeZooms
         * @type {Array}
         *
         */
        resizeZooms:[
            {min:  0, max: 10, scale: 0.5},
            {min: 10, max: 18, scale: 1}
        ]
    },

    initialize: function (options) {
        L.setOptions(this, options);
        this._initListeners();
    },

    _initListeners:function(){
        var listeners = this._listeners={};
        var events = this.options.events.slice();
        /**
         * Tip: 因为其不需要侦听canvas本身的mouseover/mouseout,而是侦听canvas的mousemove在鼠标在具体的对象上时发出相应事件,
         *      所以只在这里加入这事件的listener
         */
        events.push('mouseover','mouseout')
        for(var i=0;i<events.length;i++){
            var e = events[i];
            listeners[e] = [];
        }
    },

    onAdd: function (map) {
        this._renderer = this._map.getRenderer(this);
        if (this.options.apngRenderer && !this._map.hasLayer(this.options.apngRenderer))
            this._map.addLayer(this.options.apngRenderer);
        var self = this;
        this.options.events.forEach(function (e) {
            // L.DomEvent.on(self._renderer._container,e,self._executeListeners,self);
            // self._map.on(e, self._executeListeners, self);

            // Tip:用map无法停止向map冒泡，用_renderer无法触发兄弟_renderer的事件，
            //     用map._mapPane无法向overlay的polygon发出事件，所以用markerPane
            var pane = self._map.getPane('markerPane');
            L.DomEvent.on(pane,e,self._executeListeners,self);
        });

        if(this.data)
            !this.drawed?this._setData(this.data):this._update();
    },

    onRemove: function (map) {
        var self = this;
        this.options.events.forEach(function (e) {
            // if(self._renderer)
            //     L.DomEvent.off(self._renderer._container,e,self._executeListeners,self);
            // self._map.off(e,self._executeListeners,self);
            L.DomEvent.off(self._map.getPane('markerPane'),e,self._executeListeners,self);
            // L.DomEvent.off(self._map._mapPane,e,self._executeListeners,self);
        });
        if (this.options.apngRenderer && this._map.hasLayer(this.options.apngRenderer))
            this._map.removeLayer(this.options.apngRenderer);
        LW.CanvasLayer.prototype.onRemove.call(this,map);
    },

    addTo: function (map) {
        map.addLayer(this);
        return this;
    },

    /**
     * 重设options，并重绘
     * @method setOptions
     * @param options
     * @param textOptions {Boolean} 是否是文本相关属性
     *                      1. 如果是则检查地图当前等级是否大于textMinZoom或者是分级显示时才会重绘
     *                      2. 如果不是则设置options之后直接触发重绘
     */
    setOptions:function (options,textOptions) {
        L.setOptions(this, options);
        if(this._map && this.data){
            if(!textOptions || (textOptions && this._map.getZoom()>=this.options.textMinZoom) || this.options.isLOD)
                this._update();
        }
    },

    /**
     * 切换是否分级显示
     * @method setLOD
     * @param isLOD {Boolean}
     */
    setLOD:function(isLOD){
        this.options.isLOD = isLOD;
        if(this._map)
            this._update();
    },

    getLayers:function(bounds){
        var boxCoords = this._getBoxCoords(bounds);
        return this._latlngMarkers.search(boxCoords);
    },

    _getBoxCoords:function(bounds){
        return {
            minX: bounds.getWest(),minY: bounds.getSouth(),
            maxX: bounds.getEast(),maxY: bounds.getNorth(),
        };
    },

    clear: function () {
        LW.CanvasLayer.prototype.clear.call(this);
        if(this.options.apngRenderer && this.size){
            if(this.request)
                cancelAnimationFrame(this.request);
            this.options.apngRenderer._ctx.clearRect(0, 0, this.size.x, this.size.y);
        }
    },

    /**
     * 设置数据
     * @method setData
     * @param data
     * @return {LW.CsBaseLayer}
     */
    setData: function (data) {
        this.data = data;
        this.drawed = false;

        // 初始化画布和rbush
        this._markers = new rbush();//当前展示的markers,用于事件判定
        this._latlngMarkers = new rbush();//所有markers
        this._latlngMarkers.dirty=0;
        this._latlngMarkers.total=0;

        if(!this._moving)//Tip：如果在拖动的过程中被重设数据，可设置数据但不渲染，所以此时也不做清空
            this.clear();
        // 设置数据
        if(this._map)
            this._setData(data);
        return this;
    },

    _getLatlng: function (item) {
        var lat = item[this.options.latField],lng = item[this.options.lonField];
        return L.latLng(lat,lng);
    },

    _setData:function (data) {
        if(!data) return;

        if(this.options.LODModel){
            // var d1 = new Date();
            this.options.LODModel.options.valueField = this.options.valueField;
            this.options.LODModel.setData(data);
            // var d2 = new Date();
            // console.log('分级：',(d2.getTime()-d1.getTime())/1000+'s');
        }

        var tmpLatLng = [];
        for(var i=0;i<data.length;i++){
            var marker = this._createMarker(data[i]);
            marker.zIndex = i;
            tmpLatLng.push(marker);
        }
        this._latlngMarkers.load(tmpLatLng);
        this._update();
        this.drawed = true;
    },

    _createMarker:function(item){
        var options = this.options;
        var latlng = this._getLatlng(item);
        var m = options.markerInstance(latlng, item);
        return this.addMarker(m,latlng);
    },

    addMarker: function (marker,latlng) {
        var rect = {
            minX: latlng.lng,
            minY: latlng.lat,
            maxX: latlng.lng,
            maxY: latlng.lat,
            data: marker
        };

        this._latlngMarkers.dirty++;
        this._latlngMarkers.total++;
        return rect;
    },

    removeMarker: function (marker,redraw) {
        //If we are removed point
        if(marker["minX"]) marker = marker.data;

        var latlng = marker.getLatLng();
        var isDisplaying = this._map.getBounds().contains(latlng);

        var markerData = {
            minX: latlng.lng,
            minY: latlng.lat,
            maxX: latlng.lng,
            maxY: latlng.lat,
            data: marker
        };

        this._latlngMarkers.remove(markerData, function (a,b) {
            // Tip:一定要加这个才能移除成功
            return a.data._leaflet_id ===b.data._leaflet_id;
        });
        this._latlngMarkers.total--;
        this._latlngMarkers.dirty++;

        if(isDisplaying ===true && redraw ===true)
            this._update();
    },

    _update: function (e) {
        if(e) this._moving = false;
        if(this._map && !this._moving){
            // var d1 = new Date().getTime();
            this.clear();
            var zoom = this._map.getZoom();
            if(this.options.isLOD && this.options.LODModel) {
                // var d1 = new Date();
                this.options.LODModel.getData(zoom);
                // var d2 = new Date();
                // console.log('lod:',zoom,' time:',(d2.getTime()-d1.getTime())/1000+'s');
            }
            if(zoom>=this.options.minZoom && zoom<=this.options.maxZoom)
                this._redraw();
            // var d2 = new Date().getTime();
            // console.log('update',(d2-d1)/1000+'s');
        }
    },

    _redraw: function () {
        var map = this._map,moving = this._moving;
        var zoom = map.getZoom();
        if (!this._latlngMarkers) return;

        var tmp = [];
        //If we are 10% individual inserts\removals, reconstruct lookup for efficiency
        // if (this._latlngMarkers.dirty/this._latlngMarkers.total >= .1) {
            this._latlngMarkers.all().forEach(function(e) {
                e.data.data.hide = true;// marker.hide用于图片异步绘制时，地图已变动，marker数据已经变动。然后之前的marker依然去绘制的情况
                tmp.push(e);
            });
            this._latlngMarkers.clear();
            this._latlngMarkers.load(tmp);
            this._latlngMarkers.dirty=0;
            tmp = [];
        // }

        var mapBounds = this._map.getBounds();

        //Only re-draw what we are showing on the map.
        var mapBoxCoords = this._getBoxCoords(mapBounds);

        var markers = this._visibleMarkers = this._latlngMarkers.search(mapBoxCoords);
        // Tip: 对markers做渲染前的处理，如对查找出的markers重新排序；对marker根据指定的需求变换样式
        if(this.options.reformMarkersFn)
            markers = this.options.reformMarkersFn(markers);
        else if(this.options.sortByDataIndex)
            markers.sort(function (m1,m2){
                return m1.zIndex-m2.zIndex;
            })

        var options = this.options;
        markers.forEach(function (e) {
            var marker = e.data;
            marker.hide = false;
            var pointPos = marker.position = map.latLngToContainerPoint(marker.getLatLng());
            // var hotSize = marker.style.hotSize || options.hotSize;
            // var hotOffset = marker.style.hotOffset || options.hotOffset;
            var hotSize = marker._getOption('hotSize',options);
            var hotOffset = marker._getOption('hotOffset',options);
            if(options.resizeByZoom && marker._setWidth){// 根据等级重置scale和width
                marker.scale = getScale(options.resizeZooms);
                marker._setWidth(options);
            }
            var width = Math.max(hotSize[0],marker.width||0);//有的marker的长度会随着数据而变化
            var adj_x = width/2;
            var adj_y = hotSize[1]/2;
            var newCoords = {
                minX: (pointPos.x + hotOffset.x - adj_x),
                minY: (pointPos.y + hotOffset.y - adj_y),
                maxX: (pointPos.x + hotOffset.x + adj_x),
                maxY: (pointPos.y + hotOffset.y + adj_y),
                data: marker
            };
            tmp.push(newCoords);
        });
        // this._drawMarker(markers);
        this[this.options.unitDraw?'_drawMarkerOneByOne':'_drawMarker'](markers);

        this._markers.clear();
        this._markers.load(tmp);

        function getScale(resizeZooms){
            for(let i=0;i<resizeZooms.length;i++){
                var range = resizeZooms[i];
                if(zoom>=range.min && zoom<range.max){
                    return range.scale;
                }
            }
            return 1;
        }
    },

    eachLayer: function (method, context) {
        if(this._latlngMarkers){
            this._latlngMarkers.all().forEach(function(e) {
                method.call(context, e.data);
            });
        }
        return this;
    },

    /**
     * 重绘当前界面的marker点
     * @method drawMarker
     */
    drawMarker : function(){
        this.clear();
        var markers = this.options.reformMarkersFn ? this.options.reformMarkersFn(this._visibleMarkers) : this._visibleMarkers;
        this[this.options.unitDraw?'_drawMarkerOneByOne':'_drawMarker'](markers);
    },

    _drawMarkerOneByOne:function (markers){
        var map = this._map, zoom = map.getZoom();
        var ctx = this._renderer._ctx,options=this.options;
        if(markers.length>0){
            this._drawApng(markers,ctx,options,zoom);
            var self = this;
            self._drawName(markers,ctx,options,zoom);
            this._loadImages(function (){
                for(var i=0;i<markers.length;i++){
                    self._drawOneMaker(markers[i], ctx, options, zoom);
                }
            })
        }
    },

    _drawOneMaker:function (m, ctx, options, zoom){
        this._drawDot([m],ctx,options,zoom);
    },

    _drawMarker:function(markers){
        if(markers.length>0) {
            var map = this._map, zoom = map.getZoom();
            var ctx = this._renderer._ctx,options=this.options;
            //Tip：layer层遍历绘制，而不是marker直接绘制，是为了单种要素的层次，例如：希望站值总是在所有站名之上
            this._drawApng(markers,ctx,options,zoom);
            this._drawDot(markers,ctx,options,zoom);
            this._drawName(markers,ctx,options,zoom);
        }
    },

    _loadImages:function (fn){
        if(this.options.dotType == 'image' || this.options.dotType == 'dyImage'){
            var urls = this.options.imageUrl;
            urls = typeof urls == 'string' ? [urls] : urls;
            var promises = urls.map(function (url) {
                return LW.ResourceCache.getImage(url);
            });
            Promise.all(promises).then(function (result) {
                fn();
            });
        }
        else
            fn();

    },

    _drawApng:function (markers,ctx,options,zoom){
        if (options.apng) {
            var self = this,size = this.size;
            var apngCtx = this.options.apngRenderer._ctx;
            // if(self.request)
            //     cancelAnimationFrame(self.request);
            clearAPng();
            var apngUrls = options.apngUrl;
            if (typeof apngUrls == 'string') {
                LW.ResourceCache.getAPng(apngUrls).then(function (apng) {
                    drawAPng(apng);
                })
            } else {
                var promises = apngUrls.map(function (url) {
                    return LW.ResourceCache.getAPng(url);
                });
                Promise.all(promises).then(function (result) {
                    // Tip: 用第0个图的的帧率和帧数
                    drawAPng(result[0], function (data) {
                        return LW.ResourceCache.imageCache[options.dyApngUrlFun(data)];
                    })
                });
            }
        }

        function drawAPng(apng,dyFn) {
            var nextRenderTime = 0,
                fNum = 0,
                played = true;

            var tick = function (now) {
                while (played && nextRenderTime <= now) renderFrame(now);
                if (played) self.request = requestAnimationFrame(tick);
            };

            var renderFrame = function (now) {
                clearAPng();
                var f = fNum++ % apng.frames.length;
                var frame = apng.frames[f];
                markers.forEach(function (e) {
                    var marker = e.data;
                    if (marker.show || marker.visible(zoom, options.isLOD, options)) {
                        var _apng = dyFn ? dyFn(marker.data) : apng;
                        if(_apng){
                            var _frame = _apng.frames[f];
                            var p = marker.position, offset = marker.offset || options.apngAnchor;
                            var size = marker.size || options.apngSize || [_frame.img.width,_frame.img.height];
                            apngCtx.drawImage(_frame.img, p.x-offset[0], p.y-offset[1],size[0],size[1]);
                        }
                    }
                })

                // 下一帧的绘制时间
                if (nextRenderTime === 0) nextRenderTime = now;
                while (now > nextRenderTime + apng.playTime) nextRenderTime += apng.playTime;
                nextRenderTime += frame.delay; // delay为帧间隔时间
            }

            if(self.request)
                cancelAnimationFrame(self.request);
            self.request = requestAnimationFrame(tick);
        }

        function clearAPng(){
            apngCtx.clearRect(0, 0, size.x, size.y);
        }
    },

    _drawDot:function(markers,ctx,options,zoom) {
        if (options.dot) {
            markers.forEach(function (e) {
                var marker = e.data;
                if (marker.visible(zoom, options.isLOD, options))
                    marker._drawDot(ctx, marker.position, options);
            });
        }
    },

    _drawName:function(markers,ctx,options,zoom){
        if(this._textVisible(options,zoom,options.name))
            this._drawText(markers,ctx,options,'name','_drawName',zoom);
    },

    _drawText: function(markers,ctx,options,key,funKey,zoom){
        ctx.textAlign = options[key+'_textAlign'] || 'center';
        ctx.font = options[key+'_font'];
        ctx.fillStyle = options[key+'_color'];
        ctx.lineWidth=options[key+'_lineWidth'];
        if(options[key+'_stroke'])
            ctx.strokeStyle = options[key+'_stroke'];
        var sMarkers = [],self = this;
        markers.forEach(function (e) {
            var marker = e.data;
            if(marker.visible(zoom,options.isLOD,options)){// 判断marker是否被分级过滤
                // if(marker.style[key])
                if(marker._isReOption(key,options))//提取单独设置style的marker后面绘制,因为里面会设计样式重置，影响到没有style的marker，没有单独设置style的marker按layer的样式直接绘制
                    sMarkers.push(marker);
                /**
                 * 1. options[key]可以配置成等级数，此时当前等级要大于该值才显示
                 * 2. options.visible在csMultiLabelLayer在具体的label会配置
                 */
                else if(options[key] == true || zoom > options[key] || options.visible)
                    marker[funKey](ctx,marker.position,options);
            }
        });
        sMarkers.forEach(function (m) {
            m[funKey](ctx,m.position,options);
        })
    },

    _textVisible:function (options,zoom,typeVisible) {
        return options.isLOD ? typeVisible : (zoom>=options.textMinZoom && typeVisible);
    },

    on:function(type,fn,context){
        var listener = this._listeners[type];
        if(listener)
            listener.push(fn);
        return LW.CanvasLayer.prototype.on.call(this,type,fn,context);
    },

    _executeListeners: function (event) {

        if(!this._markers || !this._map)
            return;
        var options=this.options
        var minZoom = options.minZoom,maxZoom = options.maxZoom,zoom = this._map.getZoom();
        if(zoom<minZoom || zoom>maxZoom)
            return;
        // event = event.originalEvent;
        var self = this;
        var x = event.offsetX;
        var y = event.offsetY;

        var ret = this._markers.search({ minX: x, minY: y, maxX: x, maxY: y });
        if(options.isLOD){//去除被分级筛去的站点
            ret = ret.filter(function (m){
                return m.data.visible(zoom,options.isLOD,options)
            })
        }
        if (ret && ret.length > 0) {
            self._map._container.overId = self._leaflet_id;
            self._map._container.style.cursor=self.options.eventCursor;
            var eType = event.type,trigger=true;
            if(eType == 'mousemove'){
                // Tip: 当鼠标移过marker时，转发mouseover事件
                eType = 'mouseover';
                var overTargetID = ret[0].data._leaflet_id;
                if(self.options.mIconEvent&&self.getIndexIcon){//Tip: 如果是icon则overTarget具体到icon
                    var icon = self.getIndexIcon(event, ret[0].data);
                    if(icon)
                        overTargetID = overTargetID+'_'+icon.index;
                }
                trigger = this._overTargetID != overTargetID;
                if(trigger) fireOut();
                this._overTargetID = overTargetID;
                this._overTarget = ret[0].data;
            }
            else if(eType == 'click' && this._map._draggableMoved(this))//拖动自动触发click，将拖动触发的click屏蔽掉
                    return;
            var listener = this._listeners[eType];
            if(listener && trigger)
                excute(listener);

            if(this.options.nonBubblingEvents.indexOf(event.type)!==-1)
                event.stopPropagation();
            if(event.type === 'contextmenu')
                event.preventDefault();
        }
        else {
            if(self._map._container.overId == self._leaflet_id)
                self._map._container.style.cursor="";
            fireOut();
        }

        function excute(listener) {
            listener.forEach(function (fn) {
                if(self.options.mIconEvent&&self.getIndexIcon){
                    // Tip: 多icon的marker事件分为单icon点击和整体点击
                    var icon = self.getIndexIcon(event, ret[0].data, fn);
                    fn.call(self,event,ret[0].data,icon);
                }
                else
                    fn.call(self,event, self.options.responseAllTargets?ret:ret[0].data);
            });
        }

        function fireOut(){
            if(self._overTargetID){
                self.fire('mouseout',self._overTarget);
                self._overTargetID = null;
                self._overTarget = null;
            }
        }
    }
});
/**
 * @class LW.CsBaseLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsBaseLayer}
 */
LW.csBaseLayer = function (options) {
    return new LW.CsBaseLayer(options);
};
/**
 * CS 文本图层（市县名图层）
 *
 * Update Note：
 *      + v1.5.0 ：Created
 *      + v1.5.6 ：增加即支持LOCATION字段，也可以支持LON,LAT字段的功能
 *
 * @class LW.CsLabelLayer
 * @extends LW.CsBaseLayer
 * @demo demo/base/cs/csLayer_cityname.html  {镇名图层}
 */
LW.CsLabelLayer = LW.CsBaseLayer.extend({
    options:{
        nameField: 'NAME',
        locationField: 'LOCATION',
        dot:false,
        name_offset:{x:0,y:0}
    },

    _getLatlng: function (item) {
        if(item[this.options.locationField]){
            var latlng = item[this.options.locationField][0];
            return L.latLng(latlng[1],latlng[0]);
        }
        else
            return LW.CsBaseLayer.prototype._getLatlng.call(this,item);
    }
});

/**
 * @class LW.CsLabelLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsLabelLayer}
 */
LW.csLabelLayer = function (options) {
    return new LW.CsLabelLayer(options);
};
/**
 * CS 自动站图层
 *
 * Update Note：
 *      + v1.5.0 ：Created
 *      + v1.5.3 ：增加showZero属性
 *      + v1.5.4 ：增加可外部配置值处理方法的功能，对应的属性为valueFn
 *
 * @class LW.CsZdzLayer
 * @extends LW.CsBaseLayer
 * @demo demo/base/cs/csLayer.html  {自动站}
 * @demo demo/base/cs/csLayer_wind.html  {风}
 * @demo demo/base/cs/csLayer_visible.html  {能见度}
 * @demo demo/base/cs/csLayer_unitDraw.html  {逐个marker绘制}
 */
LW.CsZdzLayer = LW.CsBaseLayer.extend({
    options:{
        /**
         * 是否可交互，用于能见度图层点击出现能见度圈
         * @property interactive
         * @type {Boolean}
         * @default true
         */
        interactive:true,
        /**
         * Marker 实例
         * @property markerInstance
         * @type {LW.CsBaseMarker}
         * @default LW.csZdzMarker
         */
        markerInstance: LW.csZdzMarker,
        /**
         * 纬度字段名
         * @property latField
         * @type {String}
         * @default 'STATIONLAT'
         */
        latField:'STATIONLAT',
        /**
         * 经度字段名
         * @property lonField
         * @type {String}
         * @default 'STATIONLON'
         */
        lonField:'STATIONLON',
        /**
         * 图例，主要用于dot为绘制时，为不同图例范围的值显示不同的填色
         * @property legendData
         * @type {Array|null|Function}
         * @default null
         */
        legendData:null,

        // --> 站值
        /**
         * 是否展示站值
         * @property value
         * @type {Boolean}
         * @default true
         */
        value:true,
        /**
         * 站值字段
         * @property valueField
         * @type {string}
         * @default ''
         */
        valueField:'',
        /**
         * 站值缩放比, 终值 = 值 * valueScale
         * @property valueScale
         * @type {number}
         * @default 1
         */
        valueScale:1,
        /**
         * 显示值的方法，即对数据传过来的值不直接展示，而是加工后展示，可以用该方法实现
         * @property valueFn
         * @type {function}
         * @default null
         */
        valueFn:null,
        /**
         * 无效值
         * @property invalidValue
         * @type {number}
         * @default 9999
         */
        invalidValue:9999,

        /**
         * 站值的颜色
         * @property value_color
         * @type {string}
         * @default '#333'
         */
        value_color:'#333',
        /**
         * 站值的字体
         * @property value_font
         * @type {string}
         * @default '12px Microsoft Yahei'
         */
        value_font:'12px Microsoft Yahei',

        /**
         * 站值的y值，可调整站名y方向上的位置，x方向居中
         * @property value_offset
         * @type {object}
         * @default {x:0,y:-10}
         */
        value_offset:{x:0,y:-10},
        /**
         * 值是否描边
         * @property value_stroke
         * @type {Boolean}
         * @default '#fff'
         */
        value_stroke:'#fff',
        /**
         * 站值描边粗细
         * @property value_lineWidth
         * @type {int}
         * @default 2
         */
        value_lineWidth: 2,
        //--> 风杆
        /**
         * 是否绘制风
         * @property wind
         * @type {Boolean}
         * @default false
         */
        wind:false,
        /**
         * 风杆显示最小等级
         * @property windVaneMinZoom
         * @type {number}
         * @default 7
         */
        windVaneMinZoom:7,
        /**
         * 风向字段名
         * @property dirField
         * @type {string}
         * @default ''
         */
        dirField:'',
        /**
         * 风杆的颜色
         * @property wind_color
         * @type {string}
         * @default '#111'
         */
        wind_color:'#111',
        /**
         * 风杆是否描边
         * @property windVaneStroke
         * @type {Boolean|String}
         * @default 'rgba(255,255,255,0.8)'
         */
        windVaneStroke:'rgba(255,255,255,0.8)',
        /**
         * 风杆描边宽度
         * @property windVaneStrokeWidth
         * @type {Int}
         * @default 3
         */
        windVaneStrokeWidth:3,
        /**
         * 风杆颜色也由色谱决定，需要搭配windVaneColorfulValue决定效果
         * @property windVaneColorful
         * @type {Boolean}
         * @default false
         */
        windVaneColorful:false,
        /**
         * 风杆颜色也由色谱去填色的阈值，大于此值则填数值对应色谱的颜色
         * @property windVaneColorfulValue
         * @type {number}
         * @default 10.8
         */
        windVaneColorfulValue:10.8,
        /**
         * 风杆宽度
         * @property wind_width
         * @type {number}
         * @default 8
         */
        wind_width:8,
        /**
         * 风杆长度
         * @property wind_height
         * @type {number}
         * @default 25
         */
        wind_height:25,
        /**
         * 风杆绘制宽度
         * @property wind_lineWidth
         * @type {number}
         * @default 1
         */
        wind_lineWidth:1,

        // isExMarker:false,//是否是极值marker
        /**
         * 是否展示0值
         * @property showZero
         * @type {Boolean}
         * @default false
         */
        showZero:false
    },

    _createMarker:function(item){
        var options = this.options;
        var latlng = this._getLatlng(item);
        var m = options.markerInstance(latlng, item);
        m._setValue(options);
        return this.addMarker(m,latlng);
    },

    _drawOneMaker:function (m, ctx, options, zoom){
        this._drawWind([m], ctx, options, zoom);
        this._drawDot([m], ctx, options, zoom);
        this._drawTime([m], ctx, options, zoom);
        this._drawValue([m], ctx, options, zoom);
    },

    _drawMarker:function(markers){
        if(markers && markers.length>0){
            var map = this._map,zoom = map.getZoom();
            var ctx = this._renderer._ctx,options=this.options;
            this._drawApng(markers, ctx, options, zoom);
            this._drawWind(markers,ctx,options,zoom);
            this._drawDot(markers,ctx,options,zoom);
            this._drawName(markers,ctx,options,zoom);
            this._drawTime(markers,ctx,options,zoom);
            this._drawValue(markers,ctx,options,zoom);
        }
    },

    _drawWind:function(markers,ctx,options,zoom){
        if(options.wind){
            if(zoom>=options.windVaneMinZoom){
                // if(options.windVaneStroke){
                //     // ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                //     ctx.lineWidth = options.windVaneStrokeWidth;
                //     markers.forEach(function (e) {
                //         var marker = e.data;
                //         if(marker.visible(zoom,options.isLOD,options))
                //             marker._drawWind(ctx,marker.position,options,options.windVaneStroke);
                //     });
                // }
                ctx.strokeStyle = options.wind_color;
                ctx.lineWidth = options.wind_lineWidth;
                markers.forEach(function (e) {
                    var marker = e.data;
                    if(marker.visible(zoom,options.isLOD,options))
                        marker._drawWind(ctx,marker.position,options);
                });
            }
        }
    },

    _drawValue:function(markers,ctx,options,zoom){
        if(this._textVisible(options,zoom,options.value))
            this._drawText(markers,ctx,options,'value','_drawValue',zoom);
    },

    _drawTime:function(markers,ctx,options,zoom){
        if(this._textVisible(options,zoom,options.time))
            this._drawText(markers,ctx,options,'time','_drawTime',zoom);
    }
});

/**
 * @class LW.CsZdzLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsZdzLayer}
 */
LW.csZdzLayer = function (options) {
    return new LW.CsZdzLayer(options);
};
/**
 * CS 自动站-风图层
 */
LW.csZdzWindLayer = function (options) {
    options = options || {};
    options.wind = true;
    return new LW.CsZdzLayer(options);
};
/**
 * CS 自动站-能见度图层
 *
 * Update Note：
 *      + v1.5.0 ：Created
 *
 * @class LW.CsZdzVisibleLayer
 * @extends LW.CsZdzLayer
 * @demo demo/base/cs/csLayer_visible.html  {能见度}
 */
LW.CsZdzVisibleLayer = LW.CsZdzLayer.extend({
    options:{
        valueScale:0.001
    },

    // 能见度范围圈
    visibleRangeCircle: null,

    initialize: function (options) {
        LW.CsZdzLayer.prototype.initialize.call(this, options);
        if (!this.visibleRangeCircle && this.options.interactive)
            this.visibleRangeCircle = L.circle([0, 0], 0, {
                color: '#fe7a04',
                fillColor: '#fee904',
                fillOpacity: 0.2,
                weight: 1
            });
    },

    onAdd: function (map) {
        LW.CsZdzLayer.prototype.onAdd.call(this, map);
        this.on('click', this._showRange);
        if (this.visibleRangeCircle && map)
            map.addLayer(this.visibleRangeCircle);
    },

    onRemove: function (map) {
        LW.CsZdzLayer.prototype.onRemove.call(this, map);
        this.off('click', this._showRange);
        if (this.visibleRangeCircle && map)
            map.removeLayer(this.visibleRangeCircle);
    },

    setData: function (data) {
        LW.CsZdzLayer.prototype.setData.call(this,data);
        if (this.visibleRangeCircle)
            this.visibleRangeCircle.setRadius(0);
    },

    _showRange: function (e,marker,content) {
        if(this.visibleRangeCircle){
            var value = marker.value*1000;
            this.visibleRangeCircle.setLatLng(marker.getLatLng());
            this.visibleRangeCircle.setRadius(value);
        }
    }
});
/**
 * @class LW.CsZdzVisibleLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsZdzVisibleLayer}
 */
LW.csZdzVisibleLayer = function (options) {
    return new LW.CsZdzVisibleLayer(options);
};

/**
 * CS 自动站-综合填图图层(多文本展现图层)
 *
 * Update Note：
 *      + v1.5.0 ：Created
 *      + v1.5.3 ：增加也可配置图片的功能
 *
 * @class LW.CsMultiLabelLayer
 * @extends LW.CsZdzLayer
 * @demo demo/base/cs/cs_multiLabel.html  {多文本/综合填图}
 */
LW.CsMultiLabelLayer = LW.CsZdzLayer.extend({
    options:{
        /**
         * 文本的配置
         * @property labelOptions
         * @type {Array}
         * @default []
         *
         * eg: [
                //Tip:key不能用'value'
                {key:'rain',visible:true,field:'',_offset:L.point(0,0),_color:'',_stroke:'',_font:'',_lineWidth:2},
                {key:'temp',visible:true,field:'',_offset:L.point(0,0),_color:'',_stroke:'',_font:'',_lineWidth:2},
                {key:'wp', visible:true,field:'airTemp',
                    dot:true,dotType:'dyImage',imageSize:[20,20],imageAnchor:[-40+10,-15+10],dyImageUrlFun:function (item) {
                        return '../../../images/Disaster/bt_'+item.wp+'.png';
                    }}
            ]
         */
        labelOptions: []
    },

    _drawValue:function(markers,ctx,options,zoom){
        if(this._textVisible(options,zoom,true)){
            for(var i=0;i<this.options.labelOptions.length;i++){
                var item = this.options.labelOptions[i];
                if(item.dotType == 'image' || item.dotType == 'dyImage'){
                    markers.forEach(function (e) {
                        var marker = e.data;
                        if(marker.visible(zoom,options.isLOD,options) && item.visible)
                            marker._drawDot(ctx, marker.position,item);
                    });
                }
                else
                    this._drawText(markers,ctx,item,'','_drawLabel',zoom);
            }
        }
    },

    /**
     * 设置文本显隐
     * @method setLabelVisible
     * @param key {string} 文本的key
     * @param visible {boolean}
     */
    setLabelVisible:function(key,visible){
        var item = Sun.Util.Array.getItemByField(this.options.labelOptions,'key',key);
        if(item.visible != visible){
            item.visible = visible;
            this.setOptions({},true);
        }
    }
});
/**
 * @class LW.CsMultiLabelLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsMultiLabelLayer}
 */
LW.csMultiLabelLayer = function (options) {
    return new LW.CsMultiLabelLayer(options);
};

/**
 * CS 多Icon的图层
 *
 * Features :
 *      1. setData 的数据结构 [{id:'0',name:'xxx',lat:'27.5',lon:'117.3',data:[{}]},...]
 *      2. 如果每个icon的size不一样，可以设置options.mIconSize为null,设置数据的icon数据中包含size，如[{id:'0',lat:'27.5',lon:'117.3',data:[{size:[20,20]}]},...]
 *      3. 鼠标事件支持整个marker响应或单个icon响应
 *
 * Update Note：
 *      + v1.5.0 : Created
 *      + v1.5.6 : 1. 增加每个icon可以设置不一样的size的功能
 *                 2. 增加上角标的绘制功能
 *
 * @class LW.CsMultiIconLayer
 * @extends LW.CsBaseLayer
 * @demo demo/base/cs/cs_multiIcon.html  {多ICON}
 * @demo demo/base/cs/cs_multiIcon_fancy.html  {花式多ICON}
 */
LW.CsMultiIconLayer = LW.CsZdzLayer.extend({
    options:{
        /**
         * Marker 实例
         * @property markerInstance
         * @type {LW.CsBaseMarker}
         * @default LW.csMultiIconMarker
         */
        markerInstance:LW.csMultiIconMarker,
        /**
         * mIcon y方向位置
         * @property mIcon_y
         * @type {int}
         * @default -30
         */
        mIcon_y:-30,
        /**
         * 单个icon的size
         * @property mIconSize
         * @type {Array|null}
         * @default [20,20]
         */
        mIconSize:[20,20],
        /**
         * icon之间的间隔
         * @property mIconGap
         * @type {number}
         * @default 0
         */
        mIconGap:0,
        /**
         * 获取icon图片地址的function
         * @property mIconUrlFun
         * @type {function}
         * @default null
         */
        mIconUrlFun:null,
        /**
         * icon显示的等级
         * @property mIconZoom
         * @type {int}
         * @default 0
         */
        mIconZoom:0,
        /**
         * icon是否支持鼠标事件，若是点击可返回指定的icon
         * @property mIconEvent
         * @type {Boolean}
         * @default true
         */
        mIconEvent:true
    },

    _createMarker:function(item){
        var options = this.options;
        var latlng = this._getLatlng(item);
        var m = options.markerInstance(latlng, item);
        m._setValue(options);
        m._setWidth(options);
        return this.addMarker(m,latlng);
    },

    _drawMarker:function(markers){
        if(markers.length>0) {
            var map = this._map, zoom = map.getZoom();
            var ctx = this._renderer._ctx,options=this.options;
            //Tip：layer层遍历绘制，而不是marker直接绘制，是为了单种要素的层次，例如：希望站值总是在所有站名之上
            this._drawDot(markers,ctx,options,zoom);
            this._drawName(markers,ctx,options,zoom);
            this._drawMultiIcon(markers,ctx,options,zoom);
            this._drawValue(markers,ctx,options,zoom);

            var apngIcons = [];
            markers.forEach(function (m){
                if(m.data.apngIcons)
                    apngIcons.push(m.data.apngIcons);
            });
            apngIcons = apngIcons.flat();

            this._drawApng(apngIcons, ctx, options, zoom);
        }
    },

    _drawMultiIcon:function(markers,ctx,options,zoom){
        if(zoom>=options.mIconZoom){
            markers.forEach(function (e) {
                var marker = e.data;
                marker._drawMultiIcon(ctx, marker.position,options,zoom);
            });
        }
    },

    getIndexIcon:function (e,marker,fn) {
        return marker.getIcon(e.offsetX,e.offsetY,this.options);
    }
});
/**
 * @class LW.CsMultiIconLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsMultiIconLayer}
 */
LW.csMultiIconLayer = function (options) {
    return new LW.CsMultiIconLayer(options);
};
/**
 * CS 扇形环图层。主要用于AQI图层展示
 *
 * Features :
 *      1. data中的item需要有colors字段，存储每个扇形的颜色值，eg:['#0C8914','#0C8914','#FFF000','#0C8914','#0C8914','#0C8914','#0C8914','#0C8914']
 *      2. 绘制扇形需要sun@1.0.23的支持
 *
 * Update Note：
 *      + v1.5.3 ：Created
 *
 * @class LW.CsSectorRingLayer
 * @extends LW.CsZdzLayer
 * @demo demo/base/cs/cs_sectorRing.html  {扇形环}
 */
LW.CsSectorRingLayer = LW.CsZdzLayer.extend({
    options:{
        ringStroke:'#fff',
        ringWidth:2,
        radius1:40,
        radius2:20,
        markerInstance: LW.csSectorRingMarker,

        value_font:'24px Microsoft Yahei',
        value_offset:{x:0,y:10},
        name_offset:{x:0,y:60},
    }
});
/**
 * @class LW.CsSectorRingLayer
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.CsSectorRingLayer}
 */
LW.csSectorRingLayer = function (options) {
    return new LW.CsSectorRingLayer(options);
};



(function () {
    if(typeof PIXI == 'undefined') return;
    // ParticleRenderer extends
    var ParticleContainer = PIXI.particles.ParticleContainer;
    var ParticleRenderer = PIXI.particles.ParticleRenderer;
    var utils = PIXI.utils;

    ParticleContainer.prototype.addChild = function(child)
    {
        var argumentsLength = arguments.length;

        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1)
        {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
            for (var i = 0; i < argumentsLength; i++)
            {
                this.addChild(arguments[i]);
            }
        }
        else
        {
            this.children.push(child);

            // ensure bounds will be recalculated
            this._boundsID++;

            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            // child.emit('added', this);
        }

        return child;
    };

    ParticleContainer.prototype.setProperties = function(properties)
    {
        this._properties = [false, true];
        if (properties)
        {
            this._properties[0] = 'vertices' in properties || 'scale' in properties
                ? !!properties.vertices || !!properties.scale : this._properties[0];
            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
        }
    };

    ParticleRenderer.prototype.onContextChange = function()
    {
        const gl = this.renderer.gl;

        this.CONTEXT_UID = this.renderer.CONTEXT_UID;

        // setup default shader
        this.shader = new PIXI.Shader(gl,
            [
                'attribute vec2 aVertexPosition;',
                'attribute vec2 aTextureCoord;',

                'attribute vec2 aPositionCoord;',
                'uniform float scale;',

                'uniform mat3 projectionMatrix;',

                'varying vec2 vTextureCoord;',

                'void main(void){',

                '   vec2 v = scale * aVertexPosition + aPositionCoord;',

                '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);',

                '   vTextureCoord = aTextureCoord;',
                '}',
            ].join('\n'),
            [
                'varying vec2 vTextureCoord;',

                'uniform sampler2D uSampler;',

                'void main(void){',
                '  vec4 color = texture2D(uSampler, vTextureCoord);',
                '  gl_FragColor = color;',
                '}',
            ].join('\n')
        );

        this.properties = [
            // verticesData
            {
                attribute: this.shader.attributes.aVertexPosition,
                size: 2,
                uploadFunction: this.uploadVertices.bind(this),
                offset: 0,
            },
            // positionData
            {
                attribute: this.shader.attributes.aPositionCoord,
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0,
            },
            // uvsData
            {
                attribute: this.shader.attributes.aTextureCoord,
                size: 2,
                uploadFunction: this.uploadUvs.bind(this),
                offset: 0,
            },
        ];
    };

    ParticleRenderer.prototype.render = function(container)
    {
        const children = container.children;
        const texture = container.texture;
        const maxSize = container._maxSize;
        const batchSize = container._batchSize;
        const renderer = this.renderer;
        let totalChildren = children.length;

        if (totalChildren === 0)
        {
            return;
        }
        // else if (totalChildren > maxSize)
        // {
        //     totalChildren = maxSize;
        // }

        let buffers = container._glBuffers[renderer.CONTEXT_UID];

        if (!buffers)
        {
            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);
        }

        this.texture = texture;
        this.anchor = container.anchor;
        const baseTexture = texture.baseTexture;

        // if the uvs have not updated then no point rendering just yet!
        this.renderer.setBlendMode(utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));

        const gl = renderer.gl;

        const m = container.worldTransform.copy(this.tempMatrix);

        m.prepend(renderer._activeRenderTarget.projectionMatrix);

        this.shader.uniforms.projectionMatrix = m.toArray(true);

        // make sure the texture is bound..
        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);

        this.shader.uniforms.scale = container.localScale;

        let updateStatic = false;

        // now lets upload and render the buffers..
        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)
        {
            let amount = (totalChildren - i);

            if (amount > batchSize)
            {
                amount = batchSize;
            }

            if (j >= buffers.length)
            {
                if (!container.autoResize)
                {
                    break;
                }
                buffers.push(this._generateOneMoreBuffer(container));
            }

            const buffer = buffers[j];

            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);

            const bid = container._bufferUpdateIDs[i] || 0;

            updateStatic = updateStatic || (buffer._updateID < bid);
            // we only upload the static content when we have to!
            if (updateStatic)
            {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }

            // bind the buffer
            renderer.bindVao(buffer.vao);
            buffer.vao.draw(gl.TRIANGLES, amount * 6);
        }
    };

    ParticleRenderer.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset)
    {
        let w0 = 0;
        let w1 = 0;
        let h0 = 0;
        let h1 = 0;

        const anchor = this.anchor;
        const texture = this.texture;
        const trim = texture.trim;
        const orig = texture.orig;

        for (let i = 0; i < amount; ++i)
        {
            if (trim)
            {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - (anchor.x * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (anchor.y * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w0 = (orig.width) * (1 - anchor.x);
                w1 = (orig.width) * -anchor.x;

                h0 = orig.height * (1 - anchor.y);
                h1 = orig.height * -anchor.y;
            }

            array[offset] = w1;
            array[offset + 1] = h1;

            array[offset + stride] = w0;
            array[offset + stride + 1] = h1;

            array[offset + (stride * 2)] = w0;
            array[offset + (stride * 2) + 1] = h0;

            array[offset + (stride * 3)] = w1;
            array[offset + (stride * 3) + 1] = h0;

            offset += stride * 4;
        }
    };

    ParticleRenderer.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset)
    {
        for (let i = 0; i < amount; i++)
        {
            const spritePosition = children[startIndex + i];

            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;

            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;

            array[offset + (stride * 2)] = spritePosition.x;
            array[offset + (stride * 2) + 1] = spritePosition.y;

            array[offset + (stride * 3)] = spritePosition.x;
            array[offset + (stride * 3) + 1] = spritePosition.y;

            offset += stride * 4;
        }
    };

    ParticleRenderer.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset)
    {
        const textureUvs = this.texture._uvs;

        for (let i = 0; i < amount; ++i)
        {
            if (textureUvs)
            {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;

                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;

                array[offset + (stride * 2)] = textureUvs.x2;
                array[offset + (stride * 2) + 1] = textureUvs.y2;

                array[offset + (stride * 3)] = textureUvs.x3;
                array[offset + (stride * 3) + 1] = textureUvs.y3;

                offset += stride * 4;
            }
            else
            {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;

                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;

                array[offset + (stride * 2)] = 0;
                array[offset + (stride * 2) + 1] = 0;

                array[offset + (stride * 3)] = 0;
                array[offset + (stride * 3) + 1] = 0;

                offset += stride * 4;
            }
        }
    };

    // PixiOverlay
    var round = L.Point.prototype._round;
    var no_round = function () {return this;};

    function setInteractionManager(interactionManager, destroyInteractionManager, autoPreventDefault) {
        if (destroyInteractionManager) {
            interactionManager.destroy();
        } else if (!autoPreventDefault) {
            interactionManager.autoPreventDefault = false;
        }
    }

    var pixiOverlayClass = {

        options: {
            pane:'markerPane',
            // @option padding: Number = 0.1
            // How much to extend the clip area around the map view (relative to its size)
            // e.g. 0.1 would be 10% of map view in each direction
            padding: 0.1,
            // @option forceCanvas: Boolean = false
            // Force use of a 2d-canvas
            forceCanvas: false,
            // @option doubleBuffering: Boolean = false
            // Help to prevent flicker when refreshing display on some devices (e.g. iOS devices)
            // It is ignored if rendering is done with 2d-canvas
            doubleBuffering: false,
            // @option resolution: Number = 1
            // Resolution of the renderer canvas
            resolution: L.Browser.retina ? 2 : 1,
            // @option projectionZoom(map: map): Number
            // return the layer projection zoom level
            projectionZoom: function (map) {return (map.getMaxZoom() + map.getMinZoom()) / 2;},
            // @option destroyInteractionManager:  Boolean = false
            // Destroy PIXI Interaction Manager
            destroyInteractionManager: false,
            // @option
            // Customize PIXI Interaction Manager autoPreventDefault property
            // This option is ignored if destroyInteractionManager is set
            autoPreventDefault: true,
            // @option resolution: Boolean = false
            // Enables drawing buffer preservation
            preserveDrawingBuffer: false,
            // @option resolution: Boolean = true
            // Clear the canvas before the new render pass
            clearBeforeRender: true,
            // @option shouldRedrawOnMove(e: moveEvent): Boolean
            // filter move events that should trigger a layer redraw
            shouldRedrawOnMove: function () {return false;},
        },

        initialize: function (drawCallback, pixiContainer, options) {
            L.setOptions(this, options);
            L.stamp(this);
            this._drawCallback = drawCallback;
            this._pixiContainer = pixiContainer;
            this._rendererOptions = {
                transparent: true,
                resolution: this.options.resolution,
                antialias: true,
                forceCanvas: this.options.forceCanvas,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer,
                clearBeforeRender: this.options.clearBeforeRender
            };
            this._doubleBuffering = PIXI.utils.isWebGLSupported() && !this.options.forceCanvas &&
                this.options.doubleBuffering;
        },

        _setMap: function () {},

        _setContainerStyle: function () {},

        _addContainer: function () {
            this.getPane().appendChild(this._container);
        },

        _setEvents: function () {},

        onAdd: function (targetMap) {
            this._setMap(targetMap);
            if (!this._container) {
                var container = this._container = L.DomUtil.create('div', 'leaflet-pixi-overlay');
                container.style.position = 'absolute';
                this._renderer = PIXI.autoDetectRenderer(this._rendererOptions);
                setInteractionManager(
                    this._renderer.plugins.interaction,
                    this.options.destroyInteractionManager,
                    this.options.autoPreventDefault
                );
                container.appendChild(this._renderer.view);
                if (this._zoomAnimated) {
                    L.DomUtil.addClass(container, 'leaflet-zoom-animated');
                    this._setContainerStyle();
                }
                if (this._doubleBuffering) {
                    this._auxRenderer = PIXI.autoDetectRenderer(this._rendererOptions);
                    setInteractionManager(
                        this._auxRenderer.plugins.interaction,
                        this.options.destroyInteractionManager,
                        this.options.autoPreventDefault
                    );
                    container.appendChild(this._auxRenderer.view);
                    this._renderer.view.style.position = 'absolute';
                    this._auxRenderer.view.style.position = 'absolute';
                }
            }
            this._addContainer();
            this._setEvents();

            var map = this._map;
            this._initialZoom = this.options.projectionZoom(map);
            this._wgsOrigin = L.latLng([0, 0]);
            this._wgsInitialShift = map.project(this._wgsOrigin, this._initialZoom);
            this._mapInitialZoom = map.getZoom();
            var _layer = this;

            this.utils = {
                latLngToLayerPoint: function (latLng, zoom) {
                    zoom = (zoom === undefined) ? _layer._initialZoom : zoom;
                    var projectedPoint = map.project(L.latLng(latLng), zoom);
                    return projectedPoint;
                },
                layerPointToLatLng: function (point, zoom) {
                    zoom = (zoom === undefined) ? _layer._initialZoom : zoom;
                    var projectedPoint = L.point(point);
                    return map.unproject(projectedPoint, zoom);
                },
                getScale: function (zoom) {
                    if (zoom === undefined) return map.getZoomScale(map.getZoom(), _layer._initialZoom);
                    else return map.getZoomScale(zoom, _layer._initialZoom);
                },
                getRenderer: function () {
                    return _layer._renderer;
                },
                getContainer: function () {
                    return _layer._pixiContainer;
                },
                getMap: function () {
                    return _layer._map;
                }
            };
            this._update({type: 'add'});
        },

        onRemove: function () {
            L.DomUtil.remove(this._container);
        },

        getEvents: function () {
            var events = {
                zoom: this._onZoom,
                move: this._onMove,
                moveend: this._update
            };
            if (this._zoomAnimated) {
                events.zoomanim = this._onAnimZoom;
            }
            return events;
        },

        _onZoom: function () {
            this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },

        _onAnimZoom: function (e) {
            this._updateTransform(e.center, e.zoom);
        },

        _onMove: function(e) {
            if (this.options.shouldRedrawOnMove(e)) {
                this._update(e);
            }
        },

        _updateTransform: function (center, zoom) {
            var scale = this._map.getZoomScale(zoom, this._zoom),
                viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
                currentCenterPoint = this._map.project(this._center, zoom),

                topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint)
                    .subtract(this._map._getNewPixelOrigin(center, zoom));

            if (L.Browser.any3d) {
                L.DomUtil.setTransform(this._container, topLeftOffset, scale);
            } else {
                L.DomUtil.setPosition(this._container, topLeftOffset);
            }
        },

        _redraw: function(offset, e) {
            if(this._pixiContainer){
                this._disableLeafletRounding();
                var scale = this._map.getZoomScale(this._zoom, this._initialZoom),
                    shift = this._map.latLngToLayerPoint(this._wgsOrigin)
                        ._subtract(this._wgsInitialShift.multiplyBy(scale))._subtract(offset);
                this._pixiContainer.scale.set(scale);
                this._pixiContainer.position.set(shift.x, shift.y);
                this._drawCallback(this.utils, e);
                this._enableLeafletRounding();
            }
        },

        _update: function (e) {
            // is this really useful?
            if (this._map._animatingZoom && this._bounds) {return;}

            // Update pixel bounds of renderer container
            var p = this.options.padding,
                mapSize = this._map.getSize(),
                min = this._map.containerPointToLayerPoint(mapSize.multiplyBy(-p)).round();

            this._bounds = new L.Bounds(min, min.add(mapSize.multiplyBy(1 + p * 2)).round());
            this._center = this._map.getCenter();
            this._zoom = this._map.getZoom();

            if (this._doubleBuffering) {
                var currentRenderer = this._renderer;
                this._renderer = this._auxRenderer;
                this._auxRenderer = currentRenderer;
            }

            var view = this._renderer.view;
            var b = this._bounds,
                container = this._container,
                size = b.getSize();

            if (!this._renderer.size || this._renderer.size.x !== size.x || this._renderer.size.y !== size.y) {
                if (this._renderer.gl) {
                    this._renderer.resolution = this.options.resolution;
                    if (this._renderer.rootRenderTarget) {
                        this._renderer.rootRenderTarget.resolution = this.options.resolution;
                    }
                }
                this._renderer.resize(size.x, size.y);
                view.style.width = size.x + 'px';
                view.style.height = size.y + 'px';
                if (this._renderer.gl) {
                    var gl = this._renderer.gl;
                    if (gl.drawingBufferWidth !== this._renderer.width) {
                        var resolution = this.options.resolution * gl.drawingBufferWidth / this._renderer.width;
                        this._renderer.resolution = resolution;
                        if (this._renderer.rootRenderTarget) {
                            this._renderer.rootRenderTarget.resolution = resolution;
                        }
                        this._renderer.resize(size.x, size.y);
                    }
                }
                this._renderer.size = size;
            }

            if (this._doubleBuffering) {
                var self = this;
                requestAnimationFrame(function() {
                    self._redraw(b.min, e);
                    self._renderer.gl.finish();
                    view.style.visibility = 'visible';
                    self._auxRenderer.view.style.visibility = 'hidden';
                    L.DomUtil.setPosition(container, b.min);
                });
            } else {
                this._redraw(b.min, e);
                L.DomUtil.setPosition(container, b.min);
            }
        },

        _disableLeafletRounding: function () {
            L.Point.prototype._round = no_round;
        },

        _enableLeafletRounding: function () {
            L.Point.prototype._round = round;
        },

        redraw: function (data) {
            if (this._map && this._drawCallback) {
                this._disableLeafletRounding();
                this._drawCallback(this.utils, data);
                this._enableLeafletRounding();
            }
            return this;
        }

    };
    var PixiOverlay = L.Layer.extend(pixiOverlayClass);

    /**
     * CS 百万点图层
     *
     * Features :
     *      1. 只能叠加marker图片，没有站名、站值等属性
     *      2. 基于pixi@4.9.8.js
     *      3. 事件交互基于rbush,若需要开启交互需要设置options.interactive为true
     *         (1) rbush空间数据生成需要一定时间，开启后设置数据会卡顿一定时间用于该数据生成
     *         (2) 由于性能问题限定了交互的等级范围，在options.interactiveZooms范围内可交互。
     *      4. 如需要截图需要吧options.preserveDrawingBuffer设置成true
     *
     * Update Note：
     *      + v1.5.4 : Created
     *
     * @class LW.CsPixiLayer
     * @extends LW.Layer
     * @demo demo/base/cs/csPixiLayer.html  {百万闪电}
     * @constructor
     * @param options {object} 外部属性，可重设Properties
     * @returns {LW.CsBaseLayer}
     */

    LW.CsPixiLayer = PixiOverlay.extend({
        options: {
            /**
             * 是否可进行鼠标交互
             * @property interactive
             * @type {Boolean}
             * @default false
             */
            interactive:false,
            /**
             * 可鼠标交互等级
             * @property interactiveZooms
             * @type {Array}
             * @default [10,18]
             */
            interactiveZooms:[10,18],
            /**
             * marker热区的大小，用于marker的鼠标事件判定,不设置会引起鼠标事件无法使用
             * @property hotSize
             * @type {Array}
             * @default [0,0]
             */
            hotSize:[0,0],
            /**
             * marker热区的偏移量
             * @property hotOffset
             * @type {Array}
             * @default {x:0,y:0}
             */
            hotOffset:{x:0,y:0},
            /**
             * 侦听的事件
             * @property events
             * @type {Array}
             * @default ['click','dblclick','contextmenu','mousemove']
             */
            events:['click','dblclick','contextmenu','mousemove'],
            /**
             * 不冒泡的事件
             * @property nonBubblingEvents
             * @type {Array}
             * @default ['click','dblclick']
             */
            nonBubblingEvents: ['click','dblclick'],
            /**
             * marker图片纹理 eg: [{key:'negative',url:'images/2d-.png'},{key:'positive',url:'images/2d+.png'},...]
             * @property textures
             * @type {Array}
             * @default []
             */
            textures:[],//{key,url}
            /**
             * marker纹理中心点
             * @property anchor
             * @type {Object}
             * @default {x: 0.5, y: 0.5}
             */
            anchor:{x: 0.5, y: 0.5},
            /**
             * 纬度字段
             * @property latField
             * @type {String}
             * @default 'LATITUDE'
             */
            latField:'LATITUDE',
            /**
             * 经度字段
             * @property lonField
             * @type {String}
             * @default 'LONGITUDE'
             */
            lonField:'LONGITUDE',
            /**
             * 开始缩小的等级，小于该等级图层整体缩小
             * @property scaleZoom
             * @type {int}
             * @default 10
             */
            scaleZoom:10,
            /**
             * 获取纹理key的方法,该key需在textures中已经配置的key
             * @property getTextureKey
             * @type {Function}
             */
            getTextureKey:function (item){ return ;}
        },

        initialize: function (options) {
            L.setOptions(this,options);
            L.stamp(this);

            this._rendererOptions = {
                transparent: true,
                resolution: this.options.resolution,
                antialias: true,
                forceCanvas: this.options.forceCanvas,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer,
                clearBeforeRender: this.options.clearBeforeRender
            };
            this._doubleBuffering = PIXI.utils.isWebGLSupported() && !this.options.forceCanvas &&
                this.options.doubleBuffering;

            var textures = this.options.textures;
            var loader = new PIXI.loaders.Loader();
            for (var i = 0; i < textures.length; i++) {
                var tex = textures[i];
                loader.add(tex.key, tex.url);
            }
            var self = this;
            loader.load(function (loader, resources) {
                self.resources = resources;
                self.setPixiContainer(resources);
                var drawCallback = self._drawCallback = self.getDrawCallBack();
                self.redraw({type: 'setData'});
                // PixiOverlay.prototype.initialize.call(self, drawCallback, self._pixiContainer)
            });
            this._initListeners();
        },

        setPixiContainer:function (resources){
            var pixiContainer = this._pixiContainer = new PIXI.Container();
            var textures=this.options.textures,anchor = this.options.anchor;
            var innerContainer = this.innerContainer = {}
            for(var i=0;i<textures.length;i++){
                var key = textures[i].key;
                var c = innerContainer[key] = getParticleContainer(resources[key].texture);
                pixiContainer.addChild(c);
            }

            function getParticleContainer(tex){
                var innerContainer = new PIXI.particles.ParticleContainer(1500,{vertices:true},16384,true);
                innerContainer.texture = tex;
                innerContainer.baseTexture = tex.baseTexture;
                innerContainer.anchor = anchor;
                return innerContainer;
            }
        },

        _initListeners:function(){
            var listeners = this._listeners={};
            var events = this.options.events.slice();
            /**
             * Tip: 因为其不需要侦听canvas本身的mouseover/mouseout,而是侦听canvas的mousemove在鼠标在具体的对象上时发出相应事件,
             *      所以只在这里加入这事件的listener
             */
            events.push('mouseover','mouseout')
            for(var i=0;i<events.length;i++){
                var e = events[i];
                listeners[e] = [];
            }
        },

        /**
         * 侦听事件
         * @method on
         * @param type
         * @param fn
         * @param context
         * @returns {*}
         */
        on:function(type,fn,context){
            var listener = this._listeners[type];
            if(listener)
                listener.push(fn);
            return L.Layer.prototype.on.call(this,type,fn,context);
        },

        onAdd: function (targetMap) {
            PixiOverlay.prototype.onAdd.call(this,targetMap);
            if(!this.ticker){//缩放比例控制
                var self = this;
                var ticker = this.ticker = new PIXI.ticker.Ticker();
                ticker.add(function(delta) {
                    self.redraw({type: 'redraw', delta: delta});
                });
                targetMap.on('zoomstart', function() {
                    ticker.start();
                });
                targetMap.on('zoomend', function() {
                    ticker.stop();
                });
                targetMap.on('zoomanim', this.redraw, this);
            }
            if(this.options.interactive){
                var self = this;
                this.options.events.forEach(function (e) {
                    // Tip:用map无法停止向map冒泡，用_renderer无法触发兄弟_renderer的事件，
                    //     用map._mapPane无法向overlay的polygon发出事件，所以用markerPane
                    var pane = targetMap.getPane('markerPane');
                    L.DomEvent.on(pane,e,self._executeListeners,self);
                });
            }
        },

        /**
         * 设置数据
         * @method setData
         * @param data {Array}
         */
        setData:function (data){
            this.data = data;
            this.clear();
            this.drawed = false;
            this.redraw({type: 'setData'});
            //rbush
            if(this.options.interactive) {
                // var d1 = new Date();
                var self = this;
                setTimeout(function () {
                    self._setRBush(data);
                    // var d2 = new Date();
                    // console.log('rbush:', (d2 - d1) / 1000 + 's')
                }, 100)
            }
        },

        clear:function (){
            var self = this;
            this.eachContainer(function (c){
                c.removeChildren();
            },this);
            this.redraw({type: 'clear'});
        },

        _setRBush: function (data){
            this._markers = new rbush();//当前展示的markers,用于事件判定
            var allMarkers = this._allMarkers = new rbush();//所有markers
            allMarkers.dirty=0;
            allMarkers.total=0;
            var options = this.options;

            var tmpLatLng = [];
            for(var i=0;i<data.length;i++){
                var item = data[i];
                var lat = item[options.latField],lng = item[options.lonField];
                item.latlng = [lat,lng];
                var marker = getMarker(item,lat,lng)
                tmpLatLng.push(marker);
            }
            allMarkers.load(tmpLatLng);

            function getMarker(item,lat,lng) {
                var rect = {
                    minX: lng,
                    minY: lat,
                    maxX: lng,
                    maxY: lat,
                    data: item,
                };

                allMarkers.dirty++;
                allMarkers.total++;
                return rect;
            }
        },

        _executeListeners: function (event) {

            if(!this._markers || !this._map)
                return;
            var self = this;
            var x = event.clientX;
            var y = event.clientY;

            var ret = this._markers.search({ minX: x, minY: y, maxX: x, maxY: y });

            if (ret && ret.length > 0) {
                self._map._container.overId = self._leaflet_id;
                self._map._container.style.cursor='pointer';
                var eType = event.type,trigger=true;
                if(eType == 'mousemove'){
                    // Tip: 当鼠标移过marker时，转发mouseover事件
                    eType = 'mouseover';
                    var overTargetID = ret[0].data._leaflet_id;

                    trigger = this._overTargetID != overTargetID;
                    if(trigger) fireOut();
                    this._overTargetID = overTargetID;
                    this._overTarget = ret[0].data;
                }
                var listener = this._listeners[eType];
                if(listener && trigger)
                    excute(listener);

                if(this.options.nonBubblingEvents.indexOf(event.type)!==-1)
                    event.stopPropagation();
                if(event.type === 'contextmenu')
                    event.preventDefault();
            }
            else {
                if(self._map._container.overId == self._leaflet_id)
                    self._map._container.style.cursor="";
                fireOut();
            }

            function excute(listener) {
                listener.forEach(function (fn) {
                    fn.call(self,event, self.options.responseAllTargets?ret:ret[0].data);
                });
            }

            function fireOut(){
                if(self._overTargetID){
                    self.fire('mouseout',self._overTarget);
                    self._overTargetID = null;
                    self._overTarget = null;
                }
            }
        },

        _update:function (e){
            PixiOverlay.prototype._update.call(this,e);

            if(this.options.interactive){
                var map = this._map,self = this,options = this.options;
                // rbush
                boundRBush(utils);
            }

            function boundRBush(utils){
                if (!self._allMarkers) return;
                self._markers.clear();
                var zooms= options.interactiveZooms,zoom = map.getZoom();
                if(zoom<zooms[0] || zoom>zooms[1])
                    return;
                var tmp = [];
                var mapBounds = map.getBounds();
                var mapBoxCoords = getBoxCoords(mapBounds);
                var markers = self._allMarkers.search(mapBoxCoords);
                markers.forEach(function (e) {
                    var marker = e.data;
                    var pointPos = map.latLngToContainerPoint(marker.latlng);
                    var hotSize = options.hotSize;
                    var hotOffset = options.hotOffset;
                    var adj_x = hotSize[0]/2;
                    var adj_y = hotSize[1]/2;
                    var newCoords = {
                        minX: (pointPos.x + hotOffset.x - adj_x),
                        minY: (pointPos.y + hotOffset.y - adj_y),
                        maxX: (pointPos.x + hotOffset.x + adj_x),
                        maxY: (pointPos.y + hotOffset.y + adj_y),
                        data: marker
                    };
                    tmp.push(newCoords);
                });

                self._markers.load(tmp);

                function getBoxCoords(bounds){
                    return {
                        minX: bounds.getWest(),minY: bounds.getSouth(),
                        maxX: bounds.getEast(),maxY: bounds.getNorth(),
                    };
                }
            }
        },

        eachContainer:function (fn,context){
            for(var key in this.innerContainer){
                fn.call(context,this.innerContainer[key]);
            }
        },

        getDrawCallBack:function () {

            var initialScale;
            var self = this,containers = this.innerContainer;
            var options = self.options,zoomChangeTs= null;

            function setContainerPos(containers,origin,initialScale){
                self.eachContainer(function (c){
                    c.x = origin.x;
                    c.y = origin.y;
                    c.localScale = initialScale;
                })
            }

            return function (utils, event) {
                var scaleZoom = options.scaleZoom;
                var zoom = utils.getMap().getZoom();
                var container = utils.getContainer();
                var renderer = utils.getRenderer();
                var project = utils.latLngToLayerPoint;
                var getScale = utils.getScale;
                var invScale = 1 / getScale(scaleZoom-2);

                if(!this.data) return;
                if(event.type === 'add' && this.drawed) return;

                if (event.type === 'setData' || (event.type === 'add' && !this.drawed)) {
                    var origin = project([0, 0]);
                    initialScale = invScale / 4;
                    setContainerPos(self.innerContainer, origin, initialScale);

                    var data = self.data;
                    if(data){
                        this.drawed = true;
                        for (var i = 0; i < data.length; i++) {
                            var item = data[i];
                            var coords = project([item[options.latField], item[options.lonField]]);
                            var container = containers[options.getTextureKey(item)];
                            if(container){
                                container.addChild({
                                    x: coords.x - origin.x,
                                    y: coords.y - origin.y
                                });
                            }
                        }

                        // 初始缩放设置
                        this.redraw({type: 'zoomanim',zoom:zoom});
                        this.redraw({type: 'redraw',delta:(zoom-scaleZoom)*0.97});
                        this.redraw({type: 'redraw',delta:6});
                        setTimeout(function (){
                            // 初始有的时候不绘制
                            self._map.setZoom(zoom);
                        },300)
                        // if(zoom<scaleZoom){
                        //     var targetScale =  1 / getScale(zoom);
                        //     self.eachContainer(function (c){
                        //         c.currentScale = c.localScale;
                        //         c.targetScale = targetScale;
                        //         var delta = zoom-scaleZoom;
                        //         var lambda = delta/(scaleZoom - 1);
                        //         c.localScale = c.currentScale + lambda * (c.targetScale - c.currentScale);
                        //         delta+=1;
                        //         c.currentScale = c.localScale;
                        //         c.targetScale = targetScale;
                        //         var lambda = delta/(scaleZoom - 1);
                        //         c.localScale = c.currentScale + lambda * (c.targetScale - c.currentScale);
                        //     })
                        // }
                        // else
                        //     self.eachContainer(function (c) {
                        //         c.localScale = 1;
                        //     });
                    }
                }

                if (event.type === 'zoomanim') {
                    var targetZoom = event.zoom;
                    // if (targetZoom >= scaleZoom || zoom >= scaleZoom) {
                        zoomChangeTs = 0;
                        var targetScale = targetZoom >= scaleZoom ? 1 / getScale(event.zoom) : initialScale;
                        self.eachContainer(function (c){
                            c.currentScale = c.localScale;
                            c.targetScale = targetScale;
                        })
                    // }
                    return;
                }

                if (event.type === 'redraw') {
                    var delta = event.delta;
                    if (zoomChangeTs !== null) {
                        var duration = scaleZoom - 1;
                        zoomChangeTs += delta;
                        var lambda = zoomChangeTs / duration;
                        if (lambda > 1) {
                            lambda = 1;
                            zoomChangeTs = null;
                        }
                        // lambda = easing(lambda);
                        self.eachContainer(function (c){
                            c.localScale = c.currentScale + lambda * (c.targetScale - c.currentScale);
                        })
                    } else {
                        return;
                    }
                }
                renderer.render(container);
            }
        }
    });
})();


LW.BlinkCavans=LW.NoTranslateCanvas.extend({

    _updateBlink:function (layer) {
        var data = layer._points,
            ctx = this._ctx,
            r = layer._radius;
        s=1,that=this;

        this._drawnLayers[layer._leaflet_id] = layer;
        this.clear();
        data.forEach(function (size) {
            var gradient = ctx.createRadialGradient(size.x, size.y, 0, size.x, size.y, r * 2);
            gradient.addColorStop(0.2, "rgba(255,255,255,0)");
            var color=size.color||layer.options.color;
            gradient.addColorStop(0.6, color);
            ctx.fillStyle = gradient;
            ctx.lineWidth = 1;
            ctx.strokeStyle = size.color||layer.options.color;
            ctx.beginPath();
            ctx.arc(size.x, size.y / s, r, 0, Math.PI * 2, false);
            ctx.stroke();
            ctx.fill();
            ctx.closePath();
        })
    },
    clear:function () {
        if(this._ctx)
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
    }
});
/**
 * 闪烁图层
 * Features :
 *      1. 内发光闪烁图层
 *
 * Update Note：
 *      + v1.5.1-alpha ：Created
 *
 * @class LW.BlinkLayer
 * @extends L.Path
 */
LW.BlinkLayer=L.Path.extend({
    options:{
        renderer:new LW.BlinkCavans(),
        interactive:false,
        /**
         * 纬度字段名
         * @property latField
         * @type {string}
         * @default 'STATIONLAT'
         */
        latField: "STATIONLAT",

        /**
         * 经度字段名
         * @property lonField
         * @type {string}
         * @default 'STATIONLON'
         */
        lonField: "STATIONLON",
        colorField:"color",
        radius:30,
    },
    _containsPoint:function () {
        return false;
    },
    initialize:function (options) {
        L.setOptions(this,options);
        this._radius=5;
    },
    setData:function (data) {
        this.data=data;
        this._reset();
    },
    _project:function () {
        var that=this;
        this._points=[];
        if(this.data==null||this.data.length==0){
            this._pxBounds = new L.Bounds([L.point(0,0)]);
            return;
        }

        this.data.forEach(function (item) {
            var p=that._map.latLngToContainerPoint(L.latLng(item[that.options["latField"]],item[that.options["lonField"]]));
            var i={x:p.x,y:p.y,color:item[that.options["colorField"]]};
            that._points.push(i);
        });
        this._pxBounds = new L.Bounds(this._points);
    },
    getEvents: function () {
        return {
            //zoomend: L.Util.falseFn,
            moveend: this._reset,// 原先这个事件是用this._update方法作为回调，但浏览器由小变大会有bug,renderer的size认不到
            viewreset: this._reset
        };
    },
    _update: function () {
        var that=this;
        if (this._map) {
            this._updatePath();
        }
        if(this.interval)
            clearInterval(this.interval);

        this.interval=setInterval(function () {
            that._radius += 2;
            that._updatePath();
            if (that._radius > that.options.radius)
                that._radius = 5;
        }, 100)

    },
    _updatePath:function () {
        if(this._renderer)
            this._renderer._updateBlink(this);
    },
    onRemove: function () {
        if (this._map.hasLayer(this._renderer))
            this._map.removeLayer(this._renderer);
    },
    clearLayers:function () {
        if(this._renderer)
            this._renderer.clear();
        this.data=[];
        this._reset();
    }
});



LW.Editable = L.Evented.extend({

    statics: {
        FORWARD: 1,
        BACKWARD: -1
    },

    options: {

        // You can pass them when creating a map using the `editOptions` key.
        // 🍂option zIndex: int = 1000
        // The default zIndex of the editing tools.
        zIndex: 1000,

        // 🍂option polygonClass: class = L.Polygon
        // Class to be used when creating a new Polygon.
        polygonClass: L.Polygon,

        // 🍂option polylineClass: class = L.Polyline
        // Class to be used when creating a new Polyline.
        polylineClass: L.Polyline,

        // 🍂option markerClass: class = L.Marker
        // Class to be used when creating a new Marker.
        markerClass: L.Marker,

        // 🍂option rectangleClass: class = L.Rectangle
        // Class to be used when creating a new Rectangle.
        rectangleClass: L.Rectangle,

        // 🍂option circleClass: class = L.Circle
        // Class to be used when creating a new Circle.
        circleClass: L.Circle,

        // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'
        // CSS class to be added to the map container while drawing.
        drawingCSSClass: 'leaflet-editable-drawing',

        // 🍂option drawingCursor: const = 'crosshair'
        // Cursor mode set to the map while drawing.
        drawingCursor: 'crosshair',

        // 🍂option editLayer: Layer = new L.LayerGroup()
        // Layer used to store edit tools (vertex, line guide…).
        editLayer: undefined,

        // 🍂option featuresLayer: Layer = new L.LayerGroup()
        // Default layer used to store drawn features (Marker, Polyline…).
        featuresLayer: undefined,

        // 🍂option polylineEditorClass: class = PolylineEditor
        // Class to be used as Polyline editor.
        polylineEditorClass: undefined,

        // 🍂option polygonEditorClass: class = PolygonEditor
        // Class to be used as Polygon editor.
        polygonEditorClass: undefined,

        // 🍂option markerEditorClass: class = MarkerEditor
        // Class to be used as Marker editor.
        markerEditorClass: undefined,

        // 🍂option rectangleEditorClass: class = RectangleEditor
        // Class to be used as Rectangle editor.
        rectangleEditorClass: undefined,

        // 🍂option circleEditorClass: class = CircleEditor
        // Class to be used as Circle editor.
        circleEditorClass: undefined,

        // 🍂option lineGuideOptions: hash = {}
        // Options to be passed to the line guides.
        lineGuideOptions: {},

        // 🍂option skipMiddleMarkers: boolean = false
        // Set this to true if you don't want middle markers.
        skipMiddleMarkers: true,

        // 是否有顶点
        vertex:true,

        // 是否点击顶点删除该点
        vertexClickDelete:false,
    },

    initialize: function (map, options) {
        L.setOptions(this, options);
        this._lastZIndex = this.options.zIndex;
        this.map = map;
        this.editLayer = this.createEditLayer();
        this.featuresLayer = this.createFeaturesLayer();
        this.forwardLineGuide = this.createLineGuide();
        this.backwardLineGuide = this.createLineGuide();
        this.vertexTip = LW.labelMarker([0,0],{iconOptions: {className: 'lw-editable-tooltip',
                edge:false,iconAnchor: new L.Point(-12,-30)}});
        this.vertexTip.setData('单击可删除此点，拖拽可调整位置');
            // L.tooltip({className:'lw-editable-tooltip'}).addTo(map);
    },

    fireAndForward: function (type, e) {
        e = e || {};
        e.editTools = this;
        this.fire(type, e);
        this.map.fire(type, e);
    },

    createLineGuide: function () {
        var options = L.extend({
            dashArray: '5,10',
            weight: 1,
            interactive: false,
            color: '#666'
        }, this.options.lineGuideOptions);
        return L.polyline([], options);
    },

    createVertexIcon: function (options) {
        return L.Browser.touch ? new LW.Editable.TouchVertexIcon(options) : new LW.Editable.VertexIcon(options);
    },

    createEditLayer: function () {
        return this.options.editLayer || new L.LayerGroup().addTo(this.map);
    },

    createFeaturesLayer: function () {
        return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);
    },

    moveForwardLineGuide: function (latlng) {
        if (this.forwardLineGuide._latlngs.length) {
            this.forwardLineGuide._latlngs[1] = latlng;
            this.forwardLineGuide._bounds.extend(latlng);
            this.forwardLineGuide.redraw();
        }
    },

    moveBackwardLineGuide: function (latlng) {
        if (this.backwardLineGuide._latlngs.length) {
            this.backwardLineGuide._latlngs[1] = latlng;
            this.backwardLineGuide._bounds.extend(latlng);
            this.backwardLineGuide.redraw();
        }
    },

    anchorForwardLineGuide: function (latlng) {
        this.forwardLineGuide._latlngs[0] = latlng;
        this.forwardLineGuide._bounds.extend(latlng);
        this.forwardLineGuide.redraw();
    },

    anchorBackwardLineGuide: function (latlng) {
        this.backwardLineGuide._latlngs[0] = latlng;
        this.backwardLineGuide._bounds.extend(latlng);
        this.backwardLineGuide.redraw();
    },

    attachForwardLineGuide: function () {
        this.editLayer.addLayer(this.forwardLineGuide);
    },

    attachBackwardLineGuide: function () {
        this.editLayer.addLayer(this.backwardLineGuide);
    },

    detachForwardLineGuide: function () {
        this.forwardLineGuide.setLatLngs([]);
        this.editLayer.removeLayer(this.forwardLineGuide);
    },

    detachBackwardLineGuide: function () {
        this.backwardLineGuide.setLatLngs([]);
        this.editLayer.removeLayer(this.backwardLineGuide);
    },

    blockEvents: function () {
        // Hack: force map not to listen to other layers events while drawing.
        if (!this._oldTargets) {
            this._oldTargets = this.map._targets;
            this.map._targets = {};
        }
    },

    unblockEvents: function () {
        if (this._oldTargets) {
            // Reset, but keep targets created while drawing.
            this.map._targets = L.extend(this.map._targets, this._oldTargets);
            delete this._oldTargets;
        }
    },

    registerForDrawing: function (editor) {
        if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);
        this.blockEvents();
        editor.reset();  // Make sure editor tools still receive events.
        this._drawingEditor = editor;
        this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);
        this.map.on('mousedown', this.onMousedown, this);
        this.map.on('mouseup', this.onMouseup, this);
        this.map.on('contextmenu', this.commitDrawing, this);
        L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);
        this.defaultMapCursor = this.map._container.style.cursor;
        this.map._container.style.cursor = this.options.drawingCursor;
    },

    unregisterForDrawing: function (editor) {
        this.unblockEvents();
        L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);
        this.map._container.style.cursor = this.defaultMapCursor;
        editor = editor || this._drawingEditor;
        if (!editor) return;
        this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);
        this.map.off('mousedown', this.onMousedown, this);
        this.map.off('mouseup', this.onMouseup, this);
        this.map.off('contextmenu', this.commitDrawing, this);
        if (editor !== this._drawingEditor) return;
        delete this._drawingEditor;
        if (editor._drawing) editor.cancelDrawing();
    },

    onMousedown: function (e) {
        this._mouseDown = e;
        this._drawingEditor.onDrawingMouseDown(e);
    },

    onMouseup: function (e) {
        if (this._mouseDown) {
            var editor = this._drawingEditor,
                mouseDown = this._mouseDown;
            this._mouseDown = null;
            editor.onDrawingMouseUp(e);
            if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.
            var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);
            var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);
            if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);
        }
    },

    // 🍂section Public methods
    // You will generally access them by the `map.editTools`
    // instance:
    //
    // `map.editTools.startPolyline();`

    // 🍂method drawing(): boolean
    // Return true if any drawing action is ongoing.
    drawing: function () {
        return this._drawingEditor && this._drawingEditor.drawing();
    },

    // 🍂method stopDrawing()
    // When you need to stop any ongoing drawing, without needing to know which editor is active.
    stopDrawing: function () {
        this.unregisterForDrawing();
    },

    // 🍂method commitDrawing()
    // When you need to commit any ongoing drawing, without needing to know which editor is active.
    commitDrawing: function (e) {
        if (!this._drawingEditor) return;
        this._drawingEditor.commitDrawing(e);
    },

    connectCreatedToMap: function (layer) {
        return this.featuresLayer.addLayer(layer);
    },

    clearFeatures : function (){
        this.featuresLayer.clearLayers();
    },

    /**
     * 增加图层，图层必须带有setData方法才可被添加成功
     * @param _class
     * @param options
     * @param data
     */
    addFeature:function (_class,options,data){
        if(_class.prototype.setData){
            var layer = new _class([],options);
            this.featuresLayer.addLayer(layer);
            layer.setData(data);
            this.refreshVertexMarkers(layer,data.latlngs);
            return layer;
        }
    },
    /**
     * 修改图层数据，图层必须带有setData方法才可被修改成功
     * @param layer 图层
     * @param data 数据 {latlngs,...}
     */
    modifyLayer:function (layer,data){
        if(layer.setData){
            layer.setData(data);
            this.refreshVertexMarkers(layer,data.latlngs);
        }
    },

    // 刷新顶点
    refreshVertexMarkers:function (layer,latlngs){
        layer.enableEdit(this.map)
            // .refreshVertexMarkers(layer instanceof L.Polygon ? latlngs[0] : latlngs);
    },


    // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline
    // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.
    // If `options` is given, it will be passed to the Polyline class constructor.
    startPolyline: function (latlng, options) {
        var line = this.createPolyline([], options);
        line.enableEdit(this.map).newShape(latlng);
        return line;
    },

    startProfileline: function (latlng,options) {
        var line = this.createProfileline([],options);
        // this.connectCreatedToMap(line);
        line.enableEdit(this.map).newShape(latlng);
        return line;
    },

    startSymbolLine: function (latlng,options){
        var line = this.createSymbolLine([], options);
        line.enableEdit(this.map).newShape(latlng);
        return line;
    },

    startMeasure: function (latlng,options) {
        var line = this.createMeasureline([],options);
        line.enableEdit(this.map).newShape(latlng);
        return line;
    },

    // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon
    // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.
    // If `options` is given, it will be passed to the Polygon class constructor.
    startPolygon: function (latlng, options) {
        var polygon = this.createPolygon([], options);
        polygon.enableEdit(this.map).newShape(latlng);
        return polygon;
    },

    // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker
    // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.
    // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).
    // If `options` is given, it will be passed to the Marker class constructor.
    startMarker: function (latlng, options) {
        latlng = latlng || this.map.getCenter().clone();
        var marker = this.createMarker(latlng, options);
        marker.enableEdit(this.map).startDrawing();
        return marker;
    },

    // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle
    // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.
    // If `options` is given, it will be passed to the Rectangle class constructor.
    startRectangle: function (latlng, options) {
        var corner = latlng || L.latLng([0, 0]);
        var bounds = new L.LatLngBounds(corner, corner);
        var rectangle = this.createRectangle(bounds, options);
        rectangle.enableEdit(this.map).startDrawing();
        return rectangle;
    },

    // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle
    // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.
    // If `options` is given, it will be passed to the Circle class constructor.
    startCircle: function (latlng, options) {
        latlng = latlng || this.map.getCenter().clone();
        var circle = this.createCircle(latlng, options);
        circle.enableEdit(this.map).startDrawing();
        return circle;
    },

    startHole: function (editor, latlng) {
        editor.newHole(latlng);
    },

    createLayer: function (klass, latlngs, options) {
        options = L.Util.extend({editOptions: {editTools: this}}, options);
        var layer = new klass(latlngs, options);
        // 🍂namespace Editable
        // 🍂event editable:created: LayerEvent
        // Fired when a new feature (Marker, Polyline…) is created.
        this.fireAndForward('editable:created', {layer: layer});
        return layer;
    },

    createPolyline: function (latlngs, options) {
        var _class = options && options.polylineClass || this.options.polylineClass;
        return this.createLayer(_class, latlngs, options);
    },
    createProfileline: function (latlngs, options) {
        options = L.Util.extend({profileLine:true,color:'#222'}, options);
        return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);
    },
    createSymbolLine: function (latlngs, options) {
        return this.createLayer(LW.SymbolLine, latlngs, options);
    },
    createMeasureline: function (latlngs,options) {
        return this.createLayer(LW.MeasureLine, latlngs, options);
    },

    createPolygon: function (latlngs, options) {
        var _class = options && options.polygonClass || this.options.polygonClass;
        return this.createLayer(_class, latlngs, options);
    },

    createMarker: function (latlng, options) {
        return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);
    },

    createRectangle: function (bounds, options) {
        return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);
    },

    createCircle: function (latlng, options) {
        return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);
    }

});

L.extend(LW.Editable, {

    makeCancellable: function (e) {
        e.cancel = function () {
            e._cancelled = true;
        };
    }

});

// 🍂namespace Map; 🍂class Map
// Leaflet.Editable add options and events to the `L.Map` object.
// See `Editable` events for the list of events fired on the Map.
// 🍂example
//
// ```js
// var map = L.map('map', {
//  editable: true,
//  editOptions: {
//    …
// }
// });
// ```
// 🍂section Editable Map Options
L.Map.mergeOptions({

    // 🍂namespace Map
    // 🍂section Map Options
    // 🍂option editToolsClass: class = LW.Editable
    // Class to be used as vertex, for path editing.
    editToolsClass: LW.Editable,

    // 🍂option editable: boolean = false
    // Whether to create a LW.Editable instance at map init.
    editable: false,

    // 🍂option editOptions: hash = {}
    // Options to pass to LW.Editable when instanciating.
    editOptions: {}

});

L.Map.addInitHook(function () {

    this.whenReady(function () {
        if (this.options.editable) {
            this.editTools = new this.options.editToolsClass(this, this.options.editOptions);
        }
    });

});

LW.Editable.VertexIcon = L.DivIcon.extend({
    options: {
        iconSize: new L.Point(12, 12),
        iconAnchor: new L.Point(6, 6)
    }

});

LW.Editable.TouchVertexIcon = LW.Editable.VertexIcon.extend({

    options: {
        iconSize: new L.Point(12, 12)
    }

});


// 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.
LW.Editable.VertexMarker = L.Marker.extend({

    options: {
        draggable: true,
        className: 'leaflet-div-icon leaflet-vertex-icon'
    },


    // 🍂section Public methods
    // The marker used to handle path vertex. You will usually interact with a `VertexMarker`
    // instance when listening for events like `editable:vertex:ctrlclick`.

    initialize: function (latlng, latlngs, editor, options) {
        // We don't use this._latlng, because on drag Leaflet replace it while
        // we want to keep reference.
        this.latlng = L.latLng(latlng);
        this.latlngs = latlngs;
        this.editor = editor;
        L.Marker.prototype.initialize.call(this, latlng, options);
        this.options.icon = this.editor.tools.createVertexIcon(this.options);
        this.latlng.__vertex = this;
        this.editor.editLayer.addLayer(this);
        this.setZIndexOffset(editor.tools._lastZIndex + 1);
    },

    onAdd: function (map) {
        L.Marker.prototype.onAdd.call(this, map);
        this.on('drag', this.onDrag);
        this.on('dragstart', this.onDragStart);
        this.on('dragend', this.onDragEnd);
        this.on('mouseup', this.onMouseup);
        this.on('click', this.onClick);
        // this.on('contextmenu', this.onContextMenu);
        this.on('mousedown touchstart', this.onMouseDown);
        if(this.editor.tools.options.vertexClickDelete) {
            this.on('mouseover', this.onMouseOver);
            this.on('mouseout', this.onMouseOut);
        }
        this.addMiddleMarkers();
    },

    onRemove: function (map) {
        if (this.middleMarker) this.middleMarker.delete();
        delete this.latlng.__vertex;
        this.off('drag', this.onDrag);
        this.off('dragstart', this.onDragStart);
        this.off('dragend', this.onDragEnd);
        this.off('mouseup', this.onMouseup);
        this.off('click', this.onClick);
        // this.off('contextmenu', this.onContextMenu);
        this.off('mousedown touchstart', this.onMouseDown);
        if(this.editor.tools.options.vertexClickDelete){
            this.off('mouseover', this.onMouseOver);
            this.off('mouseout', this.onMouseOut);
            this.editor.tools.map.removeLayer(this.editor.tools.vertexTip);
        }
        L.Marker.prototype.onRemove.call(this, map);
    },

    onDrag: function (e) {
        e.vertex = this;
        this.editor.onVertexMarkerDrag(e);
        var iconPos = L.DomUtil.getPosition(this._icon),
            latlng = this._map.layerPointToLatLng(iconPos);
        this.latlng.update(latlng);
        this._latlng = this.latlng;  // Push back to Leaflet our reference.
        this.editor.refresh();
        if (this.middleMarker) this.middleMarker.updateLatLng();
        var next = this.getNext();
        if (next && next.middleMarker) next.middleMarker.updateLatLng();
    },

    onDragStart: function (e) {
        e.vertex = this;
        this.editor.onVertexMarkerDragStart(e);
        this.editor.tools.map.removeLayer(this.editor.tools.vertexTip);
        this.editor.tools.editing = true;
    },

    onDragEnd: function (e) {
        e.vertex = this;
        this.editor.onVertexMarkerDragEnd(e);
        this.editor.tools.editing = false;
    },

    onClick: function (e) {
        e.vertex = this;
        this.editor.onVertexMarkerClick(e);
    },

    onMouseup: function (e) {
        L.DomEvent.stop(e);
        e.vertex = this;
        this.editor.map.fire('mouseup', e);
    },

    onContextMenu: function (e) {
        e.vertex = this;
        this.editor.onVertexMarkerContextMenu(e);
    },

    onMouseDown: function (e) {
        e.vertex = this;
        this.editor.onVertexMarkerMouseDown(e);
    },

    onMouseOver: function (e){
        var tools = this.editor.tools,vertexTip = this.editor.tools.vertexTip;
        if(!tools.editing){
            vertexTip.setLatLng(e.latlng);
            if(!tools.map.hasLayer(vertexTip))
                tools.map.addLayer(vertexTip);
        }
    },
    onMouseOut: function (e){
        this.editor.tools.map.removeLayer(this.editor.tools.vertexTip);
    },

    // 🍂method delete()
    // Delete a vertex and the related LatLng.
    delete: function () {
        var next = this.getNext();  // Compute before changing latlng
        this.latlngs.splice(this.getIndex(), 1);
        this.editor.editLayer.removeLayer(this);
        this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});
        if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);
        if (next) next.resetMiddleMarker();
        this.editor.refresh();
    },

    // 🍂method getIndex(): int
    // Get the index of the current vertex among others of the same LatLngs group.
    getIndex: function () {
        return this.latlngs.indexOf(this.latlng);
    },

    // 🍂method getLastIndex(): int
    // Get last vertex index of the LatLngs group of the current vertex.
    getLastIndex: function () {
        return this.latlngs.length - 1;
    },

    // 🍂method getPrevious(): VertexMarker
    // Get the previous VertexMarker in the same LatLngs group.
    getPrevious: function () {
        if (this.latlngs.length < 2) return;
        var index = this.getIndex(),
            previousIndex = index - 1;
        if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();
        var previous = this.latlngs[previousIndex];
        if (previous) return previous.__vertex;
    },

    // 🍂method getNext(): VertexMarker
    // Get the next VertexMarker in the same LatLngs group.
    getNext: function () {
        if (this.latlngs.length < 2) return;
        var index = this.getIndex(),
            nextIndex = index + 1;
        if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;
        var next = this.latlngs[nextIndex];
        if (next) return next.__vertex;
    },

    addMiddleMarker: function (previous) {
        if (!this.editor.hasMiddleMarkers()) return;
        previous = previous || this.getPrevious();
        if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);
    },

    addMiddleMarkers: function () {
        if (!this.editor.hasMiddleMarkers()) return;
        var previous = this.getPrevious();
        if (previous) this.addMiddleMarker(previous);
        var next = this.getNext();
        if (next) next.resetMiddleMarker();
    },

    resetMiddleMarker: function () {
        if (this.middleMarker) this.middleMarker.delete();
        this.addMiddleMarker();
    },

    // 🍂method split()
    // Split the vertex LatLngs group at its index, if possible.
    split: function () {
        if (!this.editor.splitShape) return;  // Only for PolylineEditor
        this.editor.splitShape(this.latlngs, this.getIndex());
    },

    // 🍂method continue()
    // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.
    continue: function () {
        if (!this.editor.continueBackward) return;  // Only for PolylineEditor
        var index = this.getIndex();
        if (index === 0) this.editor.continueBackward(this.latlngs);
        else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);
    }

});

LW.Editable.mergeOptions({

    // 🍂namespace Editable
    // 🍂option vertexMarkerClass: class = VertexMarker
    // Class to be used as vertex, for path editing.
    vertexMarkerClass: LW.Editable.VertexMarker,

    vertexMarkerOptions:{
        draggable: true,
        className: 'lw-vertex-icon leaflet-vertex-icon',
        iconSize: L.point(6,6)
    }
});

LW.Editable.MiddleMarker = L.Marker.extend({

    options: {
        opacity: 0.5,
        className: 'leaflet-div-icon leaflet-middle-icon',
        draggable: true
    },

    initialize: function (left, right, latlngs, editor, options) {
        this.left = left;
        this.right = right;
        this.editor = editor;
        this.latlngs = latlngs;
        L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);
        this._opacity = this.options.opacity;
        this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});
        this.editor.editLayer.addLayer(this);
        this.setVisibility();
    },

    setVisibility: function () {
        var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),
            rightPoint = this._map.latLngToContainerPoint(this.right.latlng),
            size = L.point(this.options.icon.options.iconSize);
        if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();
        else this.show();
    },

    show: function () {
        this.setOpacity(this._opacity);
    },

    hide: function () {
        this.setOpacity(0);
    },

    updateLatLng: function () {
        this.setLatLng(this.computeLatLng());
        this.setVisibility();
    },

    computeLatLng: function () {
        var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),
            rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),
            y = (leftPoint.y + rightPoint.y) / 2,
            x = (leftPoint.x + rightPoint.x) / 2;
        return this.editor.map.containerPointToLatLng([x, y]);
    },

    onAdd: function (map) {
        L.Marker.prototype.onAdd.call(this, map);
        L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);
        map.on('zoomend', this.setVisibility, this);
    },

    onRemove: function (map) {
        delete this.right.middleMarker;
        L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);
        map.off('zoomend', this.setVisibility, this);
        L.Marker.prototype.onRemove.call(this, map);
    },

    onMouseDown: function (e) {
        var iconPos = L.DomUtil.getPosition(this._icon),
            latlng = this.editor.map.layerPointToLatLng(iconPos);
        e = {
            originalEvent: e,
            latlng: latlng
        };
        if (this.options.opacity === 0) return;
        LW.Editable.makeCancellable(e);
        this.editor.onMiddleMarkerMouseDown(e);
        if (e._cancelled) return;
        this.latlngs.splice(this.index(), 0, e.latlng);
        this.editor.refresh();
        var icon = this._icon;
        var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);
        /* Hack to workaround browser not firing touchend when element is no more on DOM */
        var parent = marker._icon.parentNode;
        parent.removeChild(marker._icon);
        marker._icon = icon;
        parent.appendChild(marker._icon);
        marker._initIcon();
        marker._initInteraction();
        marker.setOpacity(1);
        /* End hack */
        // Transfer ongoing dragging to real marker
        L.Draggable._dragging = false;
        marker.dragging._draggable._onDown(e.originalEvent);
        this.delete();
    },

    delete: function () {
        this.editor.editLayer.removeLayer(this);
    },

    index: function () {
        return this.latlngs.indexOf(this.right.latlng);
    }

});

LW.Editable.mergeOptions({

    // 🍂namespace Editable
    // 🍂option middleMarkerClass: class = VertexMarker
    // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.
    middleMarkerClass: LW.Editable.MiddleMarker

});

// 🍂namespace Editable; 🍂class BaseEditor; 🍂aka LW.Editable.BaseEditor
// When editing a feature (Marker, Polyline…), an editor is attached to it. This
// editor basically knows how to handle the edition.
LW.Editable.BaseEditor = L.Handler.extend({

    initialize: function (map, feature, options) {
        L.setOptions(this, options);
        this.map = map;
        this.feature = feature;
        this.feature.editor = this;
        this.editLayer = new L.LayerGroup();
        this.tools = this.options.editTools || map.editTools;
    },

    // 🍂method enable(): this
    // Set up the drawing tools for the feature to be editable.
    addHooks: function () {
        if (this.isConnected()) this.onFeatureAdd();
        else this.feature.once('add', this.onFeatureAdd, this);
        this.onEnable();
        this.feature.on(this._getEvents(), this);
        return;
    },

    // 🍂method disable(): this
    // Remove the drawing tools for the feature.
    removeHooks: function () {
        this.feature.off(this._getEvents(), this);
        if (this.feature.dragging) this.feature.dragging.disable();
        this.editLayer.clearLayers();
        this.tools.editLayer.removeLayer(this.editLayer);
        this.onDisable();
        if (this._drawing) this.cancelDrawing();
        return;
    },

    // 🍂method drawing(): boolean
    // Return true if any drawing action is ongoing with this editor.
    drawing: function () {
        return !!this._drawing;
    },

    reset: function () {
    },

    onFeatureAdd: function () {
        this.tools.editLayer.addLayer(this.editLayer);
        if (this.feature.dragging) this.feature.dragging.enable();
    },

    hasMiddleMarkers: function () {
        return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;
    },

    fireAndForward: function (type, e) {
        e = e || {};
        e.layer = this.feature;
        this.feature.fire(type, e);
        this.tools.fireAndForward(type, e);
    },

    onEnable: function () {
        // 🍂namespace Editable
        // 🍂event editable:enable: Event
        // Fired when an existing feature is ready to be edited.
        this.fireAndForward('editable:enable');
    },

    onDisable: function () {
        // 🍂namespace Editable
        // 🍂event editable:disable: Event
        // Fired when an existing feature is not ready anymore to be edited.
        this.fireAndForward('editable:disable');
    },

    onEditing: function () {
        // 🍂namespace Editable
        // 🍂event editable:editing: Event
        // Fired as soon as any change is made to the feature geometry.
        this.fireAndForward('editable:editing');
    },

    onStartDrawing: function () {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:start: Event
        // Fired when a feature is to be drawn.
        this.fireAndForward('editable:drawing:start');
    },

    onEndDrawing: function () {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:end: Event
        // Fired when a feature is not drawn anymore.
        this.fireAndForward('editable:drawing:end');
    },

    onCancelDrawing: function () {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:cancel: Event
        // Fired when user cancel drawing while a feature is being drawn.
        this.fireAndForward('editable:drawing:cancel');
    },

    onCommitDrawing: function (e) {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:commit: Event
        // Fired when user finish drawing a feature.
        this.fireAndForward('editable:drawing:commit', e);
    },

    onDrawingMouseDown: function (e) {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:mousedown: Event
        // Fired when user `mousedown` while drawing.
        this.fireAndForward('editable:drawing:mousedown', e);
    },

    onDrawingMouseUp: function (e) {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:mouseup: Event
        // Fired when user `mouseup` while drawing.
        this.fireAndForward('editable:drawing:mouseup', e);
    },

    startDrawing: function () {
        if (!this._drawing) this._drawing = LW.Editable.FORWARD;
        this.tools.registerForDrawing(this);
        this.onStartDrawing();
    },

    commitDrawing: function (e) {
        this.onCommitDrawing(e);
        this.endDrawing();
    },

    cancelDrawing: function () {
        // If called during a vertex drag, the vertex will be removed before
        // the mouseup fires on it. This is a workaround. Maybe better fix is
        // To have L.Draggable reset it's status on disable (Leaflet side).
        L.Draggable._dragging = false;
        this.onCancelDrawing();
        this.endDrawing();
    },

    endDrawing: function () {
        this._drawing = false;
        this.tools.unregisterForDrawing(this);
        this.onEndDrawing();
    },

    onDrawingClick: function (e) {
        if (!this.drawing()) return;
        LW.Editable.makeCancellable(e);
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:click: CancelableEvent
        // Fired when user `click` while drawing, before any internal action is being processed.
        this.fireAndForward('editable:drawing:click', e);
        if (e._cancelled) return;
        if (!this.isConnected()) this.connect(e);
        this.processDrawingClick(e);
    },

    isConnected: function () {
        return this.map.hasLayer(this.feature);
    },

    connect: function (e) {
        this.tools.connectCreatedToMap(this.feature);
        this.tools.editLayer.addLayer(this.editLayer);
    },

    onMove: function (e) {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:move: Event
        // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.
        this.fireAndForward('editable:drawing:move', e);
    },

    onDrawingMouseMove: function (e) {
        this.onMove(e);
    },

    _getEvents: function () {
        return {
            dragstart: this.onDragStart,
            drag: this.onDrag,
            dragend: this.onDragEnd,
            remove: this.disable
        };
    },

    onDragStart: function (e) {
        this.onEditing();
        // 🍂namespace Editable
        // 🍂event editable:dragstart: Event
        // Fired before a path feature is dragged.
        this.fireAndForward('editable:dragstart', e);
    },

    onDrag: function (e) {
        this.onMove(e);
        // 🍂namespace Editable
        // 🍂event editable:drag: Event
        // Fired when a path feature is being dragged.
        this.fireAndForward('editable:drag', e);
    },

    onDragEnd: function (e) {
        // 🍂namespace Editable
        // 🍂event editable:dragend: Event
        // Fired after a path feature has been dragged.
        this.fireAndForward('editable:dragend', e);
    }

});

// 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka LW.Editable.MarkerEditor
// 🍂inherits BaseEditor
// Editor for Marker.
LW.Editable.MarkerEditor = LW.Editable.BaseEditor.extend({

    onDrawingMouseMove: function (e) {
        LW.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
        if (this._drawing) this.feature.setLatLng(e.latlng);
    },

    processDrawingClick: function (e) {
        // 🍂namespace Editable
        // 🍂section Drawing events
        // 🍂event editable:drawing:clicked: Event
        // Fired when user `click` while drawing, after all internal actions.
        this.fireAndForward('editable:drawing:clicked', e);
        this.commitDrawing(e);
    },

    connect: function (e) {
        // On touch, the latlng has not been updated because there is
        // no mousemove.
        if (e) this.feature._latlng = e.latlng;
        LW.Editable.BaseEditor.prototype.connect.call(this, e);
    }

});

// 🍂namespace Editable; 🍂class PathEditor; 🍂aka LW.Editable.PathEditor
// 🍂inherits BaseEditor
// Base class for all path editors.
LW.Editable.PathEditor = LW.Editable.BaseEditor.extend({

    CLOSED: false,
    MIN_VERTEX: 2,

    addHooks: function () {
        LW.Editable.BaseEditor.prototype.addHooks.call(this);
        if (this.feature) this.initVertexMarkers();
        return this;
    },

    initVertexMarkers: function (latlngs) {
        if (!this.enabled()) return;
        latlngs = latlngs || this.getLatLngs();
        if (L.Polyline._flat(latlngs)) this.addVertexMarkers(latlngs);
        else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);
    },

    getLatLngs: function () {
        return this.feature.getLatLngs();
    },

    // 🍂method reset()
    // Rebuild edit elements (Vertex, MiddleMarker, etc.).
    reset: function () {
        this.editLayer.clearLayers();
        this.initVertexMarkers();
    },

    addVertexMarker: function (latlng, latlngs) {
        return new this.tools.options.vertexMarkerClass(latlng, latlngs, this,this.tools.options.vertexMarkerOptions);
        // {draggable: true,className: 'lw-vertex-icon leaflet-vertex-icon',iconSize:L.point(6,6)});
    },

    addVertexMarkers: function (latlngs) {
        for (var i = 0; i < latlngs.length; i++) {
            this.addVertexMarker(latlngs[i], latlngs);
        }
    },

    refreshVertexMarkers: function (latlngs) {
        latlngs = latlngs || this.getDefaultLatLngs();
        for (var i = 0; i < latlngs.length; i++) {
            if(latlngs[i].__vertex)
                latlngs[i].__vertex.update();
            else
                this.addVertexMarker(latlngs[i], latlngs);
        }
    },

    addMiddleMarker: function (left, right, latlngs) {
        return new this.tools.options.middleMarkerClass(left, right, latlngs, this);
    },

    onVertexMarkerClick: function (e) {
        LW.Editable.makeCancellable(e);
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:click: CancelableVertexEvent
        // Fired when a `click` is issued on a vertex, before any internal action is being processed.
        this.fireAndForward('editable:vertex:click', e);
        if (e._cancelled) return;
        if (this.tools.drawing() && this.tools._drawingEditor !== this) return;
        var index = e.vertex.getIndex(), commit;
        if (e.originalEvent.ctrlKey) {
            this.onVertexMarkerCtrlClick(e);
        } else if (e.originalEvent.altKey) {
            this.onVertexMarkerAltClick(e);
        } else if (e.originalEvent.shiftKey) {
            this.onVertexMarkerShiftClick(e);
        } else if (e.originalEvent.metaKey) {
            this.onVertexMarkerMetaKeyClick(e);
        } else if (index === e.vertex.getLastIndex() && this._drawing === LW.Editable.FORWARD) {
            if (index >= this.MIN_VERTEX - 1) commit = true;
        } else if (index === 0 && this._drawing === LW.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {
            commit = true;
        } else if (index === 0 && this._drawing === LW.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {
            commit = true;  // Allow to close on first point also for polygons
        } else if(this.tools.options.vertexClickDelete){
            // 点击删除该顶点
            this.onVertexRawMarkerClick(e);
        }
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:clicked: VertexEvent
        // Fired when a `click` is issued on a vertex, after all internal actions.
        this.fireAndForward('editable:vertex:clicked', e);
        if (commit) this.commitDrawing(e);
    },

    onVertexRawMarkerClick: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:rawclick: CancelableVertexEvent
        // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.
        this.fireAndForward('editable:vertex:rawclick', e);
        if (e._cancelled) return;
        if (!this.vertexCanBeDeleted(e.vertex)) return;
        e.vertex.delete();
    },

    vertexCanBeDeleted: function (vertex) {
        return vertex.latlngs.length > this.MIN_VERTEX;
    },

    onVertexDeleted: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:deleted: VertexEvent
        // Fired after a vertex has been deleted by user.
        this.fireAndForward('editable:vertex:deleted', e);
    },

    onVertexMarkerCtrlClick: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:ctrlclick: VertexEvent
        // Fired when a `click` with `ctrlKey` is issued on a vertex.
        this.fireAndForward('editable:vertex:ctrlclick', e);
    },

    onVertexMarkerShiftClick: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:shiftclick: VertexEvent
        // Fired when a `click` with `shiftKey` is issued on a vertex.
        this.fireAndForward('editable:vertex:shiftclick', e);
    },

    onVertexMarkerMetaKeyClick: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:metakeyclick: VertexEvent
        // Fired when a `click` with `metaKey` is issued on a vertex.
        this.fireAndForward('editable:vertex:metakeyclick', e);
    },

    onVertexMarkerAltClick: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:altclick: VertexEvent
        // Fired when a `click` with `altKey` is issued on a vertex.
        this.fireAndForward('editable:vertex:altclick', e);
    },

    onVertexMarkerContextMenu: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:contextmenu: VertexEvent
        // Fired when a `contextmenu` is issued on a vertex.
        this.fireAndForward('editable:vertex:contextmenu', e);
        this.commitDrawing(e);
    },

    onVertexMarkerMouseDown: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:mousedown: VertexEvent
        // Fired when user `mousedown` a vertex.
        this.fireAndForward('editable:vertex:mousedown', e);
    },

    onMiddleMarkerMouseDown: function (e) {
        // 🍂namespace Editable
        // 🍂section MiddleMarker events
        // 🍂event editable:middlemarker:mousedown: VertexEvent
        // Fired when user `mousedown` a middle marker.
        this.fireAndForward('editable:middlemarker:mousedown', e);
    },

    onVertexMarkerDrag: function (e) {
        this.onMove(e);
        if (this.feature._bounds) this.extendBounds(e);
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:drag: VertexEvent
        // Fired when a vertex is dragged by user.
        this.fireAndForward('editable:vertex:drag', e);
    },

    onVertexMarkerDragStart: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:dragstart: VertexEvent
        // Fired before a vertex is dragged by user.
        this.fireAndForward('editable:vertex:dragstart', e);
    },

    onVertexMarkerDragEnd: function (e) {
        // 🍂namespace Editable
        // 🍂section Vertex events
        // 🍂event editable:vertex:dragend: VertexEvent
        // Fired after a vertex is dragged by user.
        this.fireAndForward('editable:vertex:dragend', e);
    },

    setDrawnLatLngs: function (latlngs) {
        this._drawnLatLngs = latlngs || this.getDefaultLatLngs();
    },

    startDrawing: function () {
        if (!this._drawnLatLngs) this.setDrawnLatLngs();
        LW.Editable.BaseEditor.prototype.startDrawing.call(this);
    },

    startDrawingForward: function () {
        this.tools.editing = true;
        this.startDrawing();
    },

    endDrawing: function () {
        this.tools.detachForwardLineGuide();
        this.tools.detachBackwardLineGuide();
        if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);
        LW.Editable.BaseEditor.prototype.endDrawing.call(this);
        delete this._drawnLatLngs;
        this.tools.editing = false;
    },

    addLatLng: function (latlng) {
        if (this._drawing === LW.Editable.FORWARD) this._drawnLatLngs.push(latlng);
        else this._drawnLatLngs.unshift(latlng);
        this.feature._bounds.extend(latlng);
        if(this.tools.options.vertex)
            this.addVertexMarker(latlng, this._drawnLatLngs);
        this.refresh();
    },

    newPointForward: function (latlng) {
        this.addLatLng(latlng);
        this.tools.attachForwardLineGuide();
        this.tools.anchorForwardLineGuide(latlng);
    },

    newPointBackward: function (latlng) {
        this.addLatLng(latlng);
        this.tools.anchorBackwardLineGuide(latlng);
    },

    // 🍂namespace PathEditor
    // 🍂method push()
    // Programmatically add a point while drawing.
    push: function (latlng) {
        if (!latlng) return console.error('LW.Editable.PathEditor.push expect a vaild latlng as parameter');
        if (this._drawing === LW.Editable.FORWARD) this.newPointForward(latlng);
        else this.newPointBackward(latlng);
    },

    removeLatLng: function (latlng) {
        latlng.__vertex.delete();
        this.refresh();
    },

    // 🍂method pop(): L.LatLng or null
    // Programmatically remove last point (if any) while drawing.
    pop: function () {
        if (this._drawnLatLngs.length <= 1) return;
        var latlng;
        if (this._drawing === LW.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];
        else latlng = this._drawnLatLngs[0];
        this.removeLatLng(latlng);
        if (this._drawing === LW.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);
        else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);
        return latlng;
    },

    processDrawingClick: function (e) {
        if (e.vertex && e.vertex.editor === this) return;
        if (this._drawing === LW.Editable.FORWARD) this.newPointForward(e.latlng);
        else this.newPointBackward(e.latlng);
        this.fireAndForward('editable:drawing:clicked', e);
    },

    onDrawingMouseMove: function (e) {
        LW.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);
        if (this._drawing) {
            this.tools.moveForwardLineGuide(e.latlng);
            this.tools.moveBackwardLineGuide(e.latlng);
        }
    },

    refresh: function () {
        this.feature.redraw();
        this.onEditing();
    },

    // 🍂namespace PathEditor
    // 🍂method newShape(latlng?: L.LatLng)
    // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;
    // if optional `latlng` is given, start a path at this point.
    newShape: function (latlng) {
        var shape = this.addNewEmptyShape();
        if (!shape) return;
        this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline
        this.startDrawingForward();
        // 🍂namespace Editable
        // 🍂section Shape events
        // 🍂event editable:shape:new: ShapeEvent
        // Fired when a new shape is created in a multi (Polygon or Polyline).
        this.fireAndForward('editable:shape:new', {shape: shape});
        if (latlng) this.newPointForward(latlng);
    },

    deleteShape: function (shape, latlngs) {
        var e = {shape: shape};
        LW.Editable.makeCancellable(e);
        // 🍂namespace Editable
        // 🍂section Shape events
        // 🍂event editable:shape:delete: CancelableShapeEvent
        // Fired before a new shape is deleted in a multi (Polygon or Polyline).
        this.fireAndForward('editable:shape:delete', e);
        if (e._cancelled) return;
        shape = this._deleteShape(shape, latlngs);
        if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.
        this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.
        this.refresh();
        this.reset();
        // 🍂namespace Editable
        // 🍂section Shape events
        // 🍂event editable:shape:deleted: ShapeEvent
        // Fired after a new shape is deleted in a multi (Polygon or Polyline).
        this.fireAndForward('editable:shape:deleted', {shape: shape});
        return shape;
    },

    _deleteShape: function (shape, latlngs) {
        latlngs = latlngs || this.getLatLngs();
        if (!latlngs.length) return;
        var self = this,
            inplaceDelete = function (latlngs, shape) {
                // Called when deleting a flat latlngs
                shape = latlngs.splice(0, Number.MAX_VALUE);
                return shape;
            },
            spliceDelete = function (latlngs, shape) {
                // Called when removing a latlngs inside an array
                latlngs.splice(latlngs.indexOf(shape), 1);
                if (!latlngs.length) self._deleteShape(latlngs);
                return shape;
            };
        if (latlngs === shape) return inplaceDelete(latlngs, shape);
        for (var i = 0; i < latlngs.length; i++) {
            if (latlngs[i] === shape) return spliceDelete(latlngs, shape);
            else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);
        }
    },

    // 🍂namespace PathEditor
    // 🍂method deleteShapeAt(latlng: L.LatLng): Array
    // Remove a path shape at the given `latlng`.
    deleteShapeAt: function (latlng) {
        var shape = this.feature.shapeAt(latlng);
        if (shape) return this.deleteShape(shape);
    },

    // 🍂method appendShape(shape: Array)
    // Append a new shape to the Polygon or Polyline.
    appendShape: function (shape) {
        this.insertShape(shape);
    },

    // 🍂method prependShape(shape: Array)
    // Prepend a new shape to the Polygon or Polyline.
    prependShape: function (shape) {
        this.insertShape(shape, 0);
    },

    // 🍂method insertShape(shape: Array, index: int)
    // Insert a new shape to the Polygon or Polyline at given index (default is to append).
    insertShape: function (shape, index) {
        this.ensureMulti();
        shape = this.formatShape(shape);
        if (typeof index === 'undefined') index = this.feature._latlngs.length;
        this.feature._latlngs.splice(index, 0, shape);
        this.feature.redraw();
        if (this._enabled) this.reset();
    },

    extendBounds: function (e) {
        this.feature._bounds.extend(e.vertex.latlng);
    },

    onDragStart: function (e) {
        this.editLayer.clearLayers();
        LW.Editable.BaseEditor.prototype.onDragStart.call(this, e);
    },

    onDragEnd: function (e) {
        this.initVertexMarkers();
        LW.Editable.BaseEditor.prototype.onDragEnd.call(this, e);
    }

});

// 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka LW.Editable.PolylineEditor
// 🍂inherits PathEditor
LW.Editable.PolylineEditor = LW.Editable.PathEditor.extend({

    startDrawingBackward: function () {
        this._drawing = LW.Editable.BACKWARD;
        this.startDrawing();
    },

    // 🍂method continueBackward(latlngs?: Array)
    // Set up drawing tools to continue the line backward.
    continueBackward: function (latlngs) {
        if (this.drawing()) return;
        latlngs = latlngs || this.getDefaultLatLngs();
        this.setDrawnLatLngs(latlngs);
        if (latlngs.length > 0) {
            this.tools.attachBackwardLineGuide();
            this.tools.anchorBackwardLineGuide(latlngs[0]);
        }
        this.startDrawingBackward();
    },

    // 🍂method continueForward(latlngs?: Array)
    // Set up drawing tools to continue the line forward.
    continueForward: function (latlngs) {
        if (this.drawing()) return;
        latlngs = latlngs || this.getDefaultLatLngs();
        this.setDrawnLatLngs(latlngs);
        if (latlngs.length > 0) {
            this.tools.attachForwardLineGuide();
            this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);
        }
        this.startDrawingForward();
    },

    getDefaultLatLngs: function (latlngs) {
        latlngs = latlngs || this.feature._latlngs;
        if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;
        else return this.getDefaultLatLngs(latlngs[0]);
    },

    ensureMulti: function () {
        if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs)) {
            this.feature._latlngs = [this.feature._latlngs];
        }
    },

    addNewEmptyShape: function () {
        if (this.feature._latlngs.length) {
            var shape = [];
            this.appendShape(shape);
            return shape;
        } else {
            return this.feature._latlngs;
        }
    },

    formatShape: function (shape) {
        if (L.Polyline._flat(shape)) return shape;
        else if (shape[0]) return this.formatShape(shape[0]);
    },

    // 🍂method splitShape(latlngs?: Array, index: int)
    // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.
    splitShape: function (shape, index) {
        if (!index || index >= shape.length - 1) return;
        this.ensureMulti();
        var shapeIndex = this.feature._latlngs.indexOf(shape);
        if (shapeIndex === -1) return;
        var first = shape.slice(0, index + 1),
            second = shape.slice(index);
        // We deal with reference, we don't want twice the same latlng around.
        second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);
        this.feature._latlngs.splice(shapeIndex, 1, first, second);
        this.refresh();
        this.reset();
    }

});

LW.Editable.ProfileLineEditor = LW.Editable.PolylineEditor.extend({
    addLatLng: function (latlng) {
        LW.Editable.PolylineEditor.prototype.addLatLng.call(this, latlng);
        if (this._drawnLatLngs.length > 1)
            this.commitDrawing();
    }
});

// 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka LW.Editable.PolygonEditor
// 🍂inherits PathEditor
LW.Editable.PolygonEditor = LW.Editable.PathEditor.extend({

    CLOSED: true,
    MIN_VERTEX: 3,

    newPointForward: function (latlng) {
        LW.Editable.PathEditor.prototype.newPointForward.call(this, latlng);
        if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);
        if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();
    },

    addNewEmptyHole: function (latlng) {
        this.ensureNotFlat();
        var latlngs = this.feature.shapeAt(latlng);
        if (!latlngs) return;
        var holes = [];
        latlngs.push(holes);
        return holes;
    },

    // 🍂method newHole(latlng?: L.LatLng, index: int)
    // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.
    newHole: function (latlng) {
        var holes = this.addNewEmptyHole(latlng);
        if (!holes) return;
        this.setDrawnLatLngs(holes);
        this.startDrawingForward();
        if (latlng) this.newPointForward(latlng);
    },

    addNewEmptyShape: function () {
        if (this.feature._latlngs.length && this.feature._latlngs[0].length) {
            var shape = [];
            this.appendShape(shape);
            return shape;
        } else {
            return this.feature._latlngs;
        }
    },

    ensureMulti: function () {
        if (this.feature._latlngs.length && L.Polyline._flat(this.feature._latlngs[0])) {
            this.feature._latlngs = [this.feature._latlngs];
        }
    },

    ensureNotFlat: function () {
        if (!this.feature._latlngs.length || L.Polyline._flat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];
    },

    vertexCanBeDeleted: function (vertex) {
        var parent = this.feature.parentShape(vertex.latlngs),
            idx = L.Util.indexOf(parent, vertex.latlngs);
        if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.
        return LW.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);
    },

    getDefaultLatLngs: function () {
        if (!this.feature._latlngs.length) this.feature._latlngs.push([]);
        return this.feature._latlngs[0];
    },

    formatShape: function (shape) {
        // [[1, 2], [3, 4]] => must be nested
        // [] => must be nested
        // [[]] => is already nested
        if (L.Polyline._flat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];
        else return shape;
    }

});

// 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka LW.Editable.RectangleEditor
// 🍂inherits PathEditor
LW.Editable.RectangleEditor = LW.Editable.PathEditor.extend({

    CLOSED: true,
    MIN_VERTEX: 4,

    options: {
        skipMiddleMarkers: true
    },

    extendBounds: function (e) {
        var index = e.vertex.getIndex(),
            next = e.vertex.getNext(),
            previous = e.vertex.getPrevious(),
            oppositeIndex = (index + 2) % 4,
            opposite = e.vertex.latlngs[oppositeIndex],
            bounds = new L.LatLngBounds(e.latlng, opposite);
        // Update latlngs by hand to preserve order.
        previous.latlng.update([e.latlng.lat, opposite.lng]);
        next.latlng.update([opposite.lat, e.latlng.lng]);
        this.updateBounds(bounds);
        this.refreshVertexMarkers();
    },

    onDrawingMouseDown: function (e) {
        LW.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
        this.connect();
        var latlngs = this.getDefaultLatLngs();
        // L.Polygon._convertLatLngs removes last latlng if it equals first point,
        // which is the case here as all latlngs are [0, 0]
        if (latlngs.length === 3) latlngs.push(e.latlng);
        var bounds = new L.LatLngBounds(e.latlng, e.latlng);
        this.updateBounds(bounds);
        this.updateLatLngs(bounds);
        this.refresh();
        this.reset();
        // Stop dragging map.
        // L.Draggable has two workflows:
        // - mousedown => mousemove => mouseup
        // - touchstart => touchmove => touchend
        // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only
        // can deal with mousedown, but then when in a touch device, we are dealing with
        // simulated events (actually simulated by L.Map.Tap), which are no more taken
        // into account by L.Draggable.
        // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103
        e.originalEvent._simulated = false;
        this.map.dragging._draggable._onUp(e.originalEvent);
        // Now transfer ongoing drag action to the bottom right corner.
        // Should we refine which corne will handle the drag according to
        // drag direction?
        latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);
    },

    onDrawingMouseUp: function (e) {
        this.commitDrawing(e);
        e.originalEvent._simulated = false;
        LW.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);
    },

    onDrawingMouseMove: function (e) {
        e.originalEvent._simulated = false;
        LW.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);
    },


    getDefaultLatLngs: function (latlngs) {
        return latlngs || this.feature._latlngs[0];
    },

    updateBounds: function (bounds) {
        this.feature._bounds = bounds;
    },

    updateLatLngs: function (bounds) {
        var latlngs = this.getDefaultLatLngs(),
            newLatlngs = this.feature._boundsToLatLngs(bounds);
        // Keep references.
        for (var i = 0; i < latlngs.length; i++) {
            latlngs[i].update(newLatlngs[i]);
        }
        ;
    }

});

// 🍂namespace Editable; 🍂class CircleEditor; 🍂aka LW.Editable.CircleEditor
// 🍂inherits PathEditor
LW.Editable.CircleEditor = LW.Editable.PathEditor.extend({

    MIN_VERTEX: 2,

    options: {
        skipMiddleMarkers: true
    },

    initialize: function (map, feature, options) {
        LW.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);
        this._resizeLatLng = this.computeResizeLatLng();
    },

    computeResizeLatLng: function () {
        // While circle is not added to the map, _radius is not set.
        var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),
            point = this.map.project(this.feature._latlng);
        return this.map.unproject([point.x + delta, point.y - delta]);
    },

    updateResizeLatLng: function () {
        this._resizeLatLng.update(this.computeResizeLatLng());
        this._resizeLatLng.__vertex.update();
    },

    getLatLngs: function () {
        return [this.feature._latlng, this._resizeLatLng];
    },

    getDefaultLatLngs: function () {
        return this.getLatLngs();
    },

    onVertexMarkerDrag: function (e) {
        if (e.vertex.getIndex() === 1) this.resize(e);
        else this.updateResizeLatLng(e);
        LW.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);
    },

    resize: function (e) {
        var radius = this.feature._latlng.distanceTo(e.latlng)
        this.feature.setRadius(radius);
    },

    onDrawingMouseDown: function (e) {
        LW.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);
        this._resizeLatLng.update(e.latlng);
        this.feature._latlng.update(e.latlng);
        this.connect();
        // Stop dragging map.
        e.originalEvent._simulated = false;
        this.map.dragging._draggable._onUp(e.originalEvent);
        // Now transfer ongoing drag action to the radius handler.
        this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);
    },

    onDrawingMouseUp: function (e) {
        this.commitDrawing(e);
        e.originalEvent._simulated = false;
        LW.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);
    },

    onDrawingMouseMove: function (e) {
        e.originalEvent._simulated = false;
        LW.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);
    },

    onDrag: function (e) {
        LW.Editable.PathEditor.prototype.onDrag.call(this, e);
        this.feature.dragging.updateLatLng(this._resizeLatLng);
    }

});

// 🍂namespace Editable; 🍂class EditableMixin
// `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`
// and `L.Marker`. It adds some methods to them.
// *When editing is enabled, the editor is accessible on the instance with the
// `editor` property.*
var EditableMixin = {

    createEditor: function (map) {
        map = map || this._map;
        var tools = (this.options.editOptions || {}).editTools || map.editTools;
        if (!tools) throw Error('Unable to detect Editable instance.')
        var Klass = this.options.editorClass || this.getEditorClass(tools);
        return new Klass(map, this, this.options.editOptions);
    },

    // 🍂method enableEdit(map?: L.Map): this.editor
    // Enable editing, by creating an editor if not existing, and then calling `enable` on it.
    enableEdit: function (map) {
        if (!this.editor) this.createEditor(map);
        this.editor.enable();
        return this.editor;
    },

    // 🍂method editEnabled(): boolean
    // Return true if current instance has an editor attached, and this editor is enabled.
    editEnabled: function () {
        return this.editor && this.editor.enabled();
    },

    // 🍂method disableEdit()
    // Disable editing, also remove the editor property reference.
    disableEdit: function () {
        if (this.editor) {
            this.editor.disable();
            delete this.editor;
        }
    },

    // 🍂method toggleEdit()
    // Enable or disable editing, according to current status.
    toggleEdit: function () {
        if (this.editEnabled()) this.disableEdit();
        else this.enableEdit();
    },

    _onEditableAdd: function () {
        if (this.editor) this.enableEdit();
    }

};

var PolylineMixin = {
    geoType:LW.GeoType.polyline,

    getEditorClass: function (tools) {
        var editClass = this.options.profileLine ? LW.Editable.ProfileLineEditor : LW.Editable.PolylineEditor;
        return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : editClass;
    },

    shapeAt: function (latlng, latlngs) {
        // We can have those cases:
        // - latlngs are just a flat array of latlngs, use this
        // - latlngs is an array of arrays of latlngs, loop over
        var shape = null;
        latlngs = latlngs || this._latlngs;
        if (!latlngs.length) return shape;
        else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
        else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];
        return shape;
    },

    isInLatLngs: function (l, latlngs) {
        if (!latlngs) return false;
        var i, k, len, part = [], p,
            w = this._clickTolerance();
        this._projectLatlngs(latlngs, part, this._pxBounds);
        part = part[0];
        p = this._map.latLngToLayerPoint(l);

        if (!this._pxBounds.contains(p)) {
            return false;
        }
        for (i = 1, len = part.length, k = 0; i < len; k = i++) {

            if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {
                return true;
            }
        }
        return false;
    }

};

var PolygonMixin = {
    geoType:LW.GeoType.polygon,

    getEditorClass: function (tools) {
        return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : LW.Editable.PolygonEditor;
    },

    shapeAt: function (latlng, latlngs) {
        // We can have those cases:
        // - latlngs are just a flat array of latlngs, use this
        // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first
        // - latlngs is an array of arrays of arrays, this is a multi, loop over
        var shape = null;
        latlngs = latlngs || this._latlngs;
        if (!latlngs.length) return shape;
        else if (L.Polyline._flat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;
        else if (L.Polyline._flat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;
        else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];
        return shape;
    },

    isInLatLngs: function (l, latlngs) {
        var inside = false, l1, l2, j, k, len2;

        for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {
            l1 = latlngs[j];
            l2 = latlngs[k];

            if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&
                (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {
                inside = !inside;
            }
        }

        return inside;
    },

    parentShape: function (shape, latlngs) {
        latlngs = latlngs || this._latlngs;
        if (!latlngs) return;
        var idx = L.Util.indexOf(latlngs, shape);
        if (idx !== -1) return latlngs;
        for (var i = 0; i < latlngs.length; i++) {
            idx = L.Util.indexOf(latlngs[i], shape);
            if (idx !== -1) return latlngs[i];
        }
    }

};

var MarkerMixin = {
    geoType:LW.GeoType.marker,

    getEditorClass: function (tools) {
        return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : LW.Editable.MarkerEditor;
    }

};

var RectangleMixin = {
    geoType:LW.GeoType.rect,

    getEditorClass: function (tools) {
        return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : LW.Editable.RectangleEditor;
    }

};

var CircleMixin = {
    geoType:LW.GeoType.circle,

    getEditorClass: function (tools) {
        return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : LW.Editable.CircleEditor;
    }

};

var keepEditable = function () {
    // Make sure you can remove/readd an editable layer.
    this.on('add', this._onEditableAdd);
};


if (L.Polyline) {
    L.Polyline.include(EditableMixin);
    L.Polyline.include(PolylineMixin);
    L.Polyline.addInitHook(keepEditable);
}
if (L.Polygon) {
    L.Polygon.include(EditableMixin);
    L.Polygon.include(PolygonMixin);
}
if (L.Marker) {
    L.Marker.include(EditableMixin);
    L.Marker.include(MarkerMixin);
    L.Marker.addInitHook(keepEditable);
}
if (L.Rectangle) {
    L.Rectangle.include(EditableMixin);
    L.Rectangle.include(RectangleMixin);
}
if (L.Circle) {
    L.Circle.include(EditableMixin);
    L.Circle.include(CircleMixin);
}
L.LatLng.prototype.update = function (latlng) {
    latlng = L.latLng(latlng);
    this.lat = latlng.lat;
    this.lng = latlng.lng;
};

/**
 * 地图相关
 *
 * Features :
 *      1. 含地图联动
 *      2. 含地图控制器、测距、标注等显示与control位的工具
 *
 * @module Map
 */
/**
 * @module Map
 */
/**
 * 地图切换工具
 *
 * Features :
 *      1. 会直接显示于放大缩小控制按钮之下
 *
 * @class L.Control.MapSwitchTool
 * @extends L.Control.Zoom
 */
L.Control.MapSwitchTool = L.Control.Zoom.extend({
    options: {
        /**
         * 瓦片图层
         * @property baseTile
         * @type {L.TileLayer}
         * @default null
         */
        baseTile: null,
        /**
         * 默认瓦片图地址
         * @property baseTileUrl
         * @type {string}
         * @default ''
         */
        baseTileUrl: '',
        /**
         * 切换瓦片图地址
         * @property alternateTileUrl
         * @type {string}
         * @default ''
         */
        alternateTileUrl: ''
    },

    _isBaseTileUrl: true,

    onAdd: function (map) {
        var container = map.zoomControl ? map.zoomControl._container : L.DomUtil.create('div', 'leaflet-bar');
        this._createButton('', '切换地图', 'icon-globe', container, this._switchMap);
        return container;
    },

    _switchMap: function () {
        if (this.options.baseTile instanceof L.TileLayer)
            this.options.baseTile.setUrl(this._isBaseTileUrl ? this.options.alternateTileUrl : this.options.baseTileUrl);
        this._isBaseTileUrl = !this._isBaseTileUrl;
    }
});

L.control.mapSwitchTool = function (options) {
    return new L.Control.MapSwitchTool(options);
};


/**
 * 工具栏
 *
 * Features :
 *      1. 显示于放大缩小控制按钮的下一行
 *      2. 含测距、标记、删除标记等功能
 *
 * @class L.Control.Tool
 * @extends L.Control
 * @demo demo/edit/mapTool.html  {地图工具}
 */
L.Control.Tool = L.Control.extend({
    options: {
        position: 'topleft'
    },

    onAdd: function (map) {
        var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),
            measure = this._createIcon('icon-magic', container, '测距,点击最后一点结束测距'),
            mark = this._createIcon('icon-map-marker icon-large', container, '标记'),
            trash = this._createIcon('icon-trash icon-large', container, '删除'),
            ban = this._createIcon('icon-ban-circle', container, '取消');

        var offDelete = function () {
            trash.style.color = '#000';
            map.eachLayer(function (layer) {
                if (layer.offClickDelete)
                    layer.offClickDelete();
            })
        };
        L.DomEvent.on(measure, 'click', function () {
            offDelete();
            map.editTools.startMeasure();
        });
        L.DomEvent.on(mark, 'click', function () {
            offDelete();
            map.editTools.startMarker();
        });
        L.DomEvent.on(trash, 'click', function () {
            this.style.color = '#c83025';
            ban.style.color = '#000';
            map.eachLayer(function (layer) {
                if (layer.onClickDelete)
                    layer.onClickDelete();
            });
        });
        L.DomEvent.on(ban, 'click', function () {
            offDelete();
        });
        return container;
    },

    _createIcon: function (className, container, title) {
        var link = L.DomUtil.create('a', className, container);
        link.href = '#';
        link.title = title;
        return link;
    }
});

/**
 * @class L.Control.Tool
 * @constructor
 * @param options {object} 外部属性，可重设Properties
 * @returns {L.Control.Tool}
 */
L.control.tool = function (options) {
    return new L.Control.Tool(options);
};


/**
 * 可测距的Editable
 */

// LW.EditableWithMeasure = LW.Editable.extend({
//     options: {
//         measureLineClass: LW.MeasureLine
//     },
//
//     startMeasure: function (latlng,options) {
//         var line = this.createMeasureline([],options);
//         this.connectCreatedToMap(line);
//         line.enableEdit().newShape(latlng);
//         return line;
//     },
//
//     createMeasureline: function (latlngs,options) {
//         options = L.Util.extend({editOptions: {editTools: this}}, options);
//         var line = new this.options.measureLineClass(latlngs, options);
//         this.fireAndForward('editable:created', {layer: line});
//         return line;
//     }
// });
//
// LW.Editable.LabelPolylineEditor = LW.Editable.PolylineEditor.extend({
//     addVertexMarker: function (latlng, latlngs) {
//         return new this.tools.options.vertexMarkerClass(latlng, latlngs, this,
//             {draggable: false,className: 'lw-vertex-icon leaflet-vertex-icon',iconSize:L.point(6,6)});
//     }
// });
//
// L.Map.mergeOptions({
//     editToolsClass: LW.EditableWithMeasure
// });

/**
 * @module Layer.Edit
 */

/**
 * 套索工具
 *
 * Features :
 *      1. 支持Marker图层的圈选
 *      2. 支持边界图层的圈选
 *
 * @class LW.LassoTool
 * @extends L.Evented
 * @demo demo/edit/lassoTool_marker.html  {marker点圈选}
 * @demo demo/edit/lassoTool_cslayer.html  {cs Marker点圈选}
 * @demo demo/edit/lassoTool_polygon.html  {区界圈选}
 */
LW.LassoTool = L.Evented.extend({
    options: {
        weight: 1,
        gridChosenType:'value',//value/index
        pane: 'boundaryPane'
    },

    initialize: function (map, chosenLayer, options) {
        L.setOptions(this, options);
        this._map = map;
        this._chosenLayer = chosenLayer;
        this._lassoLayer = L.polygon([], this.options);
    },

    /**
     * 设置被圈选图层
     * @method setChosenLayer
     * @param chosenLayer {L.Layer} 被圈选图层
     */
    setChosenLayer: function (chosenLayer) {
        this._chosenLayer = chosenLayer;
    },

    /**
     * 圈选开始
     * @method lassoStart
     */
    lassoStart: function () {
        this._map.dragging.disable();
        if (!this._map.hasLayer(this._lassoLayer))
            this._map.addLayer(this._lassoLayer);
        this._map.on("mousedown", this._onDown, this);
        this._map.on("mouseup", this._onUp, this);
    },

    /**
     * 圈选结束
     * @method lassoEnd
     */
    lassoEnd: function () {
        this._map.dragging.enable();
        this._map.removeLayer(this._lassoLayer);
        this._map.off("mousedown", this._onDown, this);
        this._map.off("mouseup", this._onUp, this);
        this._lassoLayer.setLatLngs([]);
    },

    /**
     * 获取起止经纬度
     * @method getLatLngs
     * @returns {*}
     */
    getLatLngs: function () {
        return this._lassoLayer.getLatLngs();
    },

    _onDown: function (e) {
        this._drawing = true;
        this._trackData = [];
        this._map.on("mousemove", this._onMove, this);
    },

    _onMove: function (e) {
        if (this._drawing) {
            this._trackData.push(e.latlng);
            this._lassoLayer.setLatLngs(this._trackData);
            // Tip: 由于在div中做套索的操作就会触发click事件，csLayer在圈选结束就被侦听到click。所以将pointerEvents设置为'none',圈选结束恢复
            this._map._mapPane.style.pointerEvents = 'none';
        }
    },

    _onUp: function (e) {
        this._map._mapPane.style.pointerEvents = '';
        this._map.off("mousemove", this._onMove, this);
        this._drawing = false;
        this._lassoComplete();
    },

    _lassoComplete: function () {
        if (this._chosenLayer) {

            var chosen = [], i, j, k;

            // 图层集
            if(this._lassoLayer._latlngs[0].length>2){
                if (this._chosenLayer instanceof L.LayerGroup || (LW.CsBaseLayer && this._chosenLayer instanceof LW.CsBaseLayer)) {
                    var bounds = this._lassoLayer.getBounds();
                    if (bounds.isValid()) {
                        var layers = this._chosenLayer.getLayers(bounds);
                        if (layers) {
                            for (i = 0; i < layers.length; i++) {
                                var layer = layers[i];
                                layer = this._chosenLayer instanceof L.LayerGroup ? layer : layer.data;

                                // base layer
                                if (layer.getLatLng) {
                                    if (Sun.Util.Geometry.latlngInPolygon(layer.getLatLng(), this._trackData))
                                        chosen.push(layer);
                                }

                                // geoJson
                                else if (layer instanceof L.Polygon) {
                                    var latlngsArr = layer.getLatLngs();
                                    var beChosen = false;
                                    for (k = 0; k < latlngsArr.length; k++) {
                                        var latlngs = latlngsArr[k];
                                        latlngs = latlngs[0] instanceof L.LatLng ? latlngs : latlngs[0];
                                        if (layer._pxBounds.intersects(this._lassoLayer._pxBounds)) {
                                            for (j = 0; j < latlngs.length; j++) {
                                                if (Sun.Util.Geometry.latlngInPolygon(latlngs[j], this._trackData)) {
                                                    chosen.push(layer);
                                                    beChosen = true;
                                                    break;
                                                }
                                            }
                                            if (!beChosen) {
                                                for (j = 0; j < this._trackData.length; j++) {
                                                    if (Sun.Util.Geometry.latlngInPolygon(this._trackData[j], latlngs)) {
                                                        chosen.push(layer);
                                                        beChosen = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        if (beChosen) break;
                                    }
                                }
                            }
                        }
                    }
                }
                // 网格图层
                else if (this._chosenLayer instanceof LW.GridModel) {
                    chosen = Sun.Util.Geometry.getGridsInPolygon(this._chosenLayer.data, this._chosenLayer.grid,
                        this._trackData, this.options.gridChosenType);
                }

                if (chosen.length > 0)
                    this.fire('chosenComplete', {data: chosen});
            }
        }
        else
            this.fire('chosenComplete');
    }
});

/**
 * @class LW.LassoTool
 * @constructor
 * @param map {L.Map} 地图
 * @param chosenLayer {L.Layer} 被圈选图层
 * @param options {object} 外部属性，可重设Properties
 *                         注：此属性与L.Polygon属性一致
 * @returns {LW.LassoTool}
 */
LW.lassoTool = function (map, chosenLayer, options) {
    return new LW.LassoTool(map, chosenLayer, options);
};

/**
 * @module Layer.Plot.Profile
 */

/**
 * 剖面
 *
 * Features :
 *      1. 剖面基础图层
 *      2. 基于本图层扩展了数值预报剖面图层及雷达剖面图层
 *
 * @class LW.Profile
 * @extends L.Class
 */

LW.Profile = L.Class.extend({
    options: {
        /**
         * 剖面的css class
         * @property className
         * @type {string}
         * @default 'lw-profile'
         */
        className: 'lw-profile',

        /**
         * 剖面长度（单位：px）
         * @property width
         * @type {number}
         * @default 700
         */
        width: 700,

        /**
         * 剖面宽度（单位：px）
         * @property height
         * @type {number}
         * @default 500
         */
        height: 500,

        /**
         * 剖面外边距，可以调整剖面与外容器上下左右的距离
         * @property margins
         * @type {object}
         * @default {top: 30,right: 50,bottom: 30,left: 60}
         */
        margins: {
            top: 30,
            right: 40,
            bottom: 30,
            left: 50
        },

        /**
         * 是否显示坐标轴
         */
        axis:true,

        /**
         * x轴单位
         * @property xUnit
         * @type {string}
         * @default ''
         */
        xUnit: '',

        /**
         * x轴单位位置
         * @property xUnitP
         * @type {string}
         * @default {x: 50,y: 20}
         */
        xUnitP: {
            x: 50,
            y: 20
        },

        /**
         * y轴单位
         * @property yUnit
         * @type {string}
         * @default '(hPa)'
         */
        yUnit: '(hPa)',

        /**
         * y轴2的单位
         * @property yUnit2
         * @type {string}
         * @default '(km)'
         */
        yUnit2: '(km)'
        //cssUrl: 'Script/HW.BusinessGisLib/layer/plot/profile/profile.css'
    },

    initialize: function (panelContainer, map , options) {
        this._map = map;
        L.setOptions(this, options);
        // 展示初始化
        var pContainer = document.getElementById(panelContainer);
        this.container = L.DomUtil.create("div", this.options.className);
        pContainer.appendChild(this.container);
        this._initialShow();
    },

    _initialShow: function () {
        // 引用样式表
        //CommonUtil.createCssLink(this.options.cssUrl);

        // svg
        var opts = this.options;
        this.cont = d3.select(this.container);
        // this.cont.attr("width", opts.width);
        // this.cont.attr("height", opts.height);
        var svg = this.svg = this.cont.append("svg");
        svg.attr("width", opts.svgWidth || opts.width)
            .attr("height", opts.height)
            .append("g")
            .attr("transform", "translate(" + opts.margins.left + "," + opts.margins.top + ")");

        var g = this.g = d3.select(this.container).select("svg").select("g");
        // axis
        if(opts.axis){
            this._xaxisgraphicnode = g.append("g");
            this._yaxisgraphicnode = g.append("g");
            this._y2axisgraphicnode = g.append("g");
        }
    },

    _getxScale: function () {
        var _x = d3.scale.linear()
            .domain(this.data.xaxis)
            .range([0, this._width()]);

        return d3.svg.axis()
            .scale(_x)
            .orient("bottom")
    },

    _getyScale: function () {
        var _y = d3.scale.ordinal()
            .domain(this.data.yaxis)
            .rangePoints([0, this._height()]);

        return d3.svg.axis()
            .scale(_y)
            .orient("left")
    },

    _setXYTick: function () {
        this._xTick = (this._width() - 2) / (this.data.xaxis.length - 1);
        this._yTick = (this._height() - 1) / (this.data.yaxis.length - 1);
    },

    /**
     * 设置数据并绘制
     * @method setData
     * @param data {Array}
     */
    setData: function (data) {
        this.data = data;

        // x y tick
        this._setXYTick();

        if(this.options.axis)
            this._updateAxis();
    },

    _width: function () {
        var opts = this.options;
        return opts.width - opts.margins.left - opts.margins.right;
    },

    _height: function () {
        var opts = this.options;
        return opts.height - opts.margins.top - opts.margins.bottom;
    },

    _clearSvgNode: function (node) {
        node.selectAll("g").remove();
        node.selectAll("path").remove();
        node.selectAll("circle").remove();
        node.selectAll("text").remove();
        node.selectAll("line").remove();
    },

    _updateAxis: function () {
        this._clearSvgNode(this._xaxisgraphicnode);
        this._appendXaxis(this._xaxisgraphicnode);
        this._clearSvgNode(this._yaxisgraphicnode);
        this._appendYaxis(this._yaxisgraphicnode);
        this._clearSvgNode(this._y2axisgraphicnode);
        this._appendYaxis2(this._y2axisgraphicnode);
    },

    _appendXaxis: function (x) {
        x.attr("class", "x axis")
            .attr("transform", "translate(0," + this._height() + ")")
            .call(this._getxScale())
            .append("text")
            .attr("x", this._width() + this.options.xUnitP.x)
            .attr("y", this.options.xUnitP.y)
            .style("text-anchor", "end")
            .text(this.options.xUnit);
    },

    _appendYaxis: function (y) {
        y.attr("class", "y axis")
            .call(this._getyScale())
            .append("text")
            .attr("x", 0)
            .attr("y", -15)
            .style("text-anchor", "end")
            .text(this.options.yUnit);
    },

    _appendYaxis2: function (y) {
        return L.Util.falseFn;
    }
});

/**
 * 剖面相关
 * @module Layer.Plot.Profile
 */

/**
 * 剖面编辑
 *
 * Features :
 *      1. 在地图上点选两点，用于空间剖面
 *      2. 可拖动起始点，改变剖面位置
 *      3. map 的 editable 属性必须设置为true
 *
 * @class LW.Profile.Editable
 * @extends L.Evented
 */

LW.Profile.Editable = L.Evented.extend({
    options: {},

    initialize: function (map, options) {
        this.map = map;
        map.options.editToolsClass = LW.EditableWithMeasure;

        var self = this;
        map.on('editable:drawing:end', function (e) {
            if(e.layer.options.profileLine)
                self._endProfile(e.layer.getLatLngs())
        });
        map.on('editable:vertex:dragend', function (e) {
            if(e.layer.options.profileLine)
                self._endProfile(e.layer.getLatLngs())
        });
    },

    /**
     * 空间剖面方法--开始剖面
     * @method startProfile
     */
    startProfile: function (options) {
        this.map.editTools.startProfileline(null,options);
    },

    _endProfile: function (latlngs) {
        this.fire('editable:profile:end', {data: latlngs});
    },

    /**
     * 空间剖面方法--清除剖面辅助线
     * @method startProfile
     */
    clear: function () {
        this.map.editTools.forwardLineGuide.setLatLngs([]);
        this.map.editTools.featuresLayer.clearLayers();
    },

    /**
     * 空间剖面方法--重置剖面
     * @method startProfile
     */
    reset: function () {
        this.clear();
        this.startProfile();
    }
});

/**
 * @module Layer.Plot.Profile
 */

/**
 * 数值预报时间剖面
 *
 * Features :
 *      1. 该剖面为时间剖面，有表意明确的x轴
 *      2. 需引用d3.js
 *
 * Update Note：
 *      + v1.0.0 ：Created
 *      + v1.4.4 ：1. 将数据改为版本3.0 的nc数据，并自主跟踪填色，生成可用的色斑图和等值线数据
 *                 2. 增加各个要素可以控制显隐的功能
 *      + v1.5.1 ：增加hpa网格的数据源的支持，需要将options.yAxisType设为hpa
 *      + v1.5.5 ：增加strokeBoldFn配置判断线条是否加粗的方法
 *
 * @class LW.Profile.Isoline
 * @extends LW.Profile
 * @demo demo/plot/profile/profileIsoline_only.html  {数值预报剖面}
 * @demo demo/plot/profile/profileIsoline.html  {时间剖面}
 * @demo demo/plot/profile/profileIsoline_space.html  {空间剖面}
 */

/**
 * @class LW.Profile.Isoline
 * @constructor
 * @param panelContainer {string} 面板容器 style="position: absolute;"
 * @param map {L.Map} 地图
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.Profile.Isoline}
 */

LW.Profile.Isoline = LW.Profile.extend({
    options: {
        /**
         * 配置不同种类要素的配色方案
         *
         * Elements :
         *      1. grid: 仅支持一个格点值图层，可配置值颜色
         *      2. fill: 仅支持一个填色图层，根据配置的图例生成色斑图
         *      3. stroke: 支持多个等值线图层，需指定每个要素对应的线条颜色，需与数据相对应
         *      4. 要素名称需和数据中相对应，数据要素改变这里的要素也许做相应变化
         *
         * @property elements
         * @type {object}
         * @default {
         *        grid: {uv: {color: '#042499'}},
         *        fill: {key:'rh',legendData: Sun.LegendData.rh},
         *        stroke: {
         *            w: {color: '#333',gap:0.1},
         *            tt: {color: '#BD4F58',gap:4}
         *        }
         *    }
         */
        elements: {
            grid: {uv: {color: '#042499'}},
            fill: {key:'rh',legendData: Sun.LegendData.rh,opacity:1},
            stroke: {
                w: {color: '#333',gap:0.1},
                tt: {color: '#BD4F58',gap:4}
            }
        },
        /**
         * 判断线条是否加粗的方法
         * @property strokeBoldFn
         * @type {function | null}
         * @default null
         */
        strokeBoldFn:null,
        /**
         * 地形颜色，仅在空间剖面中展示使用
         * @property terrainColor
         * @type {string}
         * @default '#666'
         */
        terrainColor:'#666',
        /**
         * x轴类型的间隔数
         * @property xTick
         * @type {int}
         * @default 1
         */
        xTick:1,
        /**
         * x轴类型,可选：hour/minute
         * @property xAxisType
         * @type {string}
         * @default 'hour'
         */
        xAxisType:'hour',
        /**
         * x轴放向
         * @property xAxisOrient
         * @type {string}
         * @default 'bottom'
         */
        xAxisOrient:'bottom',
        /**
         * x轴时间格式
         * @property timeFormat
         * @type {string}
         * @default 'ddhh'
         */
        timeFormat:'ddhh',

        /**
         * y轴类型。
         *      1. hap_km：双y轴，有hpa和km,数据以km的单位网格分布
         *      2. hpa：单y轴，数据以hpa的单位网格分布
         * @property yAxisType
         * @type {string}
         * @default 'hpa_km'
         */
        yAxisType:'hpa_km',

        /**
         * 数据类型
         * @property dataType
         * @type {string}
         * @default 'nc'
         */
        dataType:'nc'
    },

    _initialShow: function () {
        LW.Profile.prototype._initialShow.call(this);

        //isoline svg group
        this._setMask();
        var maskId = 'url(#profile-mask'+this.id+')';
        var elements = this.options.elements, g = this.g;
        this.g_terrain = g.insert("g");
        this.g_isoline = {};
        if(elements.fill)
            this.g_isoline[elements.fill.key] = g.append("g").attr('clip-path',maskId);
        for(var key in elements.stroke){
            this.g_isoline[key]= g.append("g").attr('clip-path',maskId);
        }

        // 指示线 group
        this.g_indicator= {};

        //grid canvas
        if(this.options.elements.grid){
            var canvas = this.canvas = this.cont.append("canvas");
            canvas.attr("width", this._width())
                .attr("height", this._height() + this.options.margins.top)
                .style("position", "absolute")
                .style("top", 0)
                .style("left", this.options.margins.left + 'px');

            this._ctx = canvas[0][0].getContext('2d');
        }

        // contourModel
        this.contourModel = new LW.ContourModel();
    },

    _setMask: function(){
        this.id = L.stamp(this);
        var x = this._width()-1,y = this._height()-1;
        var defs = this.g.append('defs');
        var clipPath = defs.append('clipPath').attr('id','profile-mask'+this.id);
        var d = 'M1 1L1 '+ y +'L' + x + ' ' + y + 'L' + x + ' 1Z';
        clipPath.append('path').attr('d',d);

    },

    _getxScale: function (orient) {
        var pTime = this.data.forecastTime,xTick = this.options.xTick;
        var xAxisType = this.options.xAxisType,timeFormat = this.options.timeFormat;
        pTime = new Date(pTime.slice(0,4),parseInt(pTime.slice(4,6))-1,pTime.slice(6,8),pTime.slice(8,10),pTime.slice(10,12));
        var _x = d3.scale.ordinal()
            .domain(this.data.xaxis.map(function (item,i) {
                if(i%xTick===0){
                    var t = new Date(pTime);
                    t[xAxisType === 'hour' ? 'addHours' : 'addMinutes'](item);
                    return t.format(timeFormat);
                }
                else//Tip:d3没有快捷的处理tick的方案，直接return '' 坐标轴也会错误，出此下策
                    return i+'*';
            }))
            .rangePoints([0, this._width()]);
        return d3.svg.axis()
            .scale(_x)
            .tickFormat(function (d) {
                return d.indexOf('*')!==-1?'':d;
            })
            .orient(orient || "bottom")
    },

    _appendXaxis: function (x) {
        var orient = this.options.xAxisOrient,height = orient === 'bottom' ? this._height() : 0;
        x.attr("class", "axis")
            .attr("transform", "translate(0," + height + ")")
            .call(this._getxScale(orient))
            .append("text")
            .attr("x", this._width() + this.options.xUnitP.x)
            .attr("y", this.options.xUnitP.y)
            .style("text-anchor", "end")
            .text(this.options.xUnit);
    },

    _getyDomain1: function(domain){
        return d3.scale.ordinal()
            .domain(domain || this.data.yaxis)
            .rangePoints([this._height(),0]);
    },
    _getyDomain2: function(){
        var ytick = this._yTick,yaxis = this.data.yaxis;
        var _maxH = this._maxH = yaxis[this.data.yaxis.length-1];
        var tickScale = this.tickScale = 1/(yaxis[1]-yaxis[0]);
        var hpaToRange = this.data.hpa_km[1].map(function (value) {
            return (_maxH - value) * ytick * tickScale;
        });
        return d3.scale.ordinal()
            .domain(this.data.hpa_km[0])
            .range(hpaToRange);
    },

    _getyScale: function () {
        var _y = this.options.yAxisType == 'hpa' ? this._getyDomain1() : this._getyDomain2();

        return d3.svg.axis()
            .scale(_y)
            .orient("left")
    },

    _gety2Scale: function () {
        var _y = this._getyDomain1(this.options.yAxisType == 'hpa' ? [] : null);

        return d3.svg.axis()
            .scale(_y)
            .orient("right")
            .tickSize(-this._width() - 1);
    },

    _appendYaxis: function (y) {
        y.attr("class", "y2 axis")
            .call(this._getyScale())
            .append("text")
            .attr("x", 0)
            .attr("y", -15)
            .style("text-anchor", "end")
            .text(this.options.yUnit);
    },

    _appendYaxis2: function (y) {
        y.attr("class", "y axis")
            .attr("transform", "translate(" + this._width() + ",0)")
            .call(this._gety2Scale())
            .append("text")
            .attr("x", 25)
            .attr("y", -15)
            .style("text-anchor", "end")
            .text(this.options.yUnit2);
    },

    /**
     * 设置数据，生成剖面图
     * @method setData
     * @param data {ArrayBuffer} 版本3.0 nc数据
     * @return {LW.Profile.Isoline}
     */
    setData: function (data) {
        if (!data)
            return this;

        // 解析nc数据
        if(this.options.dataType === 'nc')
            data = Sun.Util.Data.changeGridNcToJson(data);
        // 处理色斑图数据
        var elements = this.options.elements;
        if(elements.fill)
            this.contourModel.setContourDataOfChartGrid(data,elements.fill.key,elements.fill.legendData,true);
        for(var key in elements.stroke){
            var item = elements.stroke[key];
            this.contourModel.setContourDataOfChartGrid(data,key,null,false,item.gap);
        }

        LW.Profile.prototype.setData.call(this, data);

        this.clear();

        // update grid
        this._updateGrid();

        // update isoline
        this._updateIsoline();
    },

    /**
     * 清空指示线
     * @param type
     */
    clearIndicator:function(type){
        if (this.g_indicator[type])
            this.g_indicator[type].selectAll("line").remove();
    },
    /**
     * 展示指示线
     * @method showIndicator
     * @param type {string} 类型 eg:'hpa'/'km'
     * @param value {Number} 数值
     * @param className {String} 指示线的样式名 默认为'indicator-line'在lw.css中定义
     */
    showIndicator: function (type,value,className) {
        if (!this.g_indicator[type])
            this.g_indicator[type] = this.g.append("g");
        var g_indicator = this.g_indicator[type];
        this.clearIndicator(type);
        if (type === 'hpa')
            value = this._getY(value);
        else if(type === 'km' && this.options.yAxisType === 'hpa')
            value = this._getY(value,true);
        y = this._getXY(0, value).y;

        if(!isNaN(y)){
            g_indicator.append('svg:line')
                .attr('class', className || 'indicator-line')
                .attr('x1', 0)
                .attr('y1', y)
                .attr('x2', this._width())
                .attr('y2', y);
        }
    },

    clear: function(){
        for(var key in this.g_isoline){
            this._clearSvgNode(this.g_isoline[key]);
        }
        if(this._ctx)
            this._ctx.clearRect(0, 0, this._width(), this._height() + this.options.margins.top);
    },

    setElementVisible:function(e,visible){
        var target = e === 'uv' ? this.canvas : this.g_isoline[e];
        if(target)
            visible ? target.style('display','block') : target.style('display','none');
    },

    _updateIsoline: function () {
        this._appendTerrain();
        this._appendIsoline(this.g_isoline);
    },

    _appendTerrain:function (){
        var data = this.data;
        if(data.terrain){
            var height = this._height(),self = this;
            var area = d3.svg.area()
                .x(function(d, i){return self._getXY(i,0).x})//曲线中x的值
                .y0(function(d) { return height })
                .y1(function(d){ return self._getXY(0,d).y})
                .interpolate("basis");
            this.g_terrain.append("path")
                .attr("d", area(data.terrain))
                .attr("fill",this.options.terrainColor);
        }
    },

    _appendIsoline: function (g) {
        // fill
        var data = this.data.data;
        var e_fill = this.options.elements.fill;
        if (data && e_fill) {
            var eData = data[e_fill.key];
            if (eData && eData.planeitems)
                this._appendFillPath(g[e_fill.key], eData.planeitems);
        }

        // stroke
        var strokeElements = this.options.elements.stroke;
        if (data && strokeElements) {
            for (var e in strokeElements) {
                eData = data[e];
                var ele = strokeElements[e];
                if (eData && ele)
                    this._appendStrokePath(g[e], eData.lineitems, ele.color,e);
            }
        }
    },

    _appendFillPath: function (g, data) {
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            var path = g.append("path");
            var d = this._projectFillPath(item.pointitems);
            path.attr("fill", item.planecolor)
                .attr("d", d)
                .attr('fill-rule','evenodd')
                .attr("fill-opacity",this.options.elements.fill.opacity||1);
        }
    },

    _projectFillPath: function (pointitems) {
        var rings = '';
        // interpolate
        var svgLine = d3.svg.line(), interpolateType= 'basis-closed';
        svgLine.interpolate(interpolateType);
        for (var i = 0; i < pointitems.length; i++) {
            // get d of path
            var items = pointitems[i];
            var ring = [];
            for (var j = 0; j < items.length; j++) {
                var p = this._getXY(items[j][1], items[j][0]);
                ring[j] = [p.x, p.y];
            }
            var d = svgLine(ring);
            rings += d;
        }
        return rings;
    },

    _appendStrokePath: function (g, data, color, type) {
        var strokeBoldFn = this.options.strokeBoldFn;
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            var path = g.append("path");
            var d = this._projectStrokePath(item);
            path.attr("stroke", color)
                .attr("fill", 'none')
                .attr("d", d);
            this._setLineLabel(g, item.pointitems, Sun.Util.Math.toFixed(item.linevalue, 2), color, (i%5)+1);
            if (item.linevalue < 0)
                path.attr("stroke-dasharray", "3,3");
            else if(strokeBoldFn?strokeBoldFn(item.linevalue,type):item.linevalue == 0)
                path.attr('stroke-width',3);
        }
    },

    _projectStrokePath: function (line) {
        // interpolate
        var svgLine = d3.svg.line();
        var interpolateType = line.linetype == 0 ? 'basis' : 'basis-closed';
        svgLine.interpolate(interpolateType);

        var points = line.pointitems;
        var ring = [];
        for (var i = 0; i < points.length; i++) {
            var p = this._getXY(points[i][1], points[i][0]);
            ring[i] = [p.x, p.y];
        }
        return svgLine(ring);
    },

    _getLpoint: function (point) {
        var xy = this._getXY(point[0], point[1]);
        return L.point(xy.x, xy.y);
    },

    _setLineLabel: function (g, points, value, color, i0) {
        var d = Math.pow(250,2);
        var pFirst = points[0];
        var pLast = points[0];
        var p0 = this._getLpoint(pFirst);
        var labeled = false;
        var flag = false;
        for (var i = 0; i < points.length - 1; i+=i0) {
            var p1 = points[i];
            var p2 = points[i + 1];
            var p = [(p1[1] + p2[1]) / 2, (p1[0] + p2[0]) / 2];
            var xyLast = this._getLpoint(pLast);
            var xyCur = this._getLpoint(p);
            var s = 10;
            if(xyCur.x>s && xyCur.y>s && xyCur.x<this._width()-s && xyCur.y<this._height()-s){
                if (distance(xyLast,xyCur) >= d) {
                    append_t();
                    pLast = p;
                    labeled = true;
                }
                else if (!labeled && distance(p0,xyCur) >= 50)
                    flag = true;
            }
        }
        if (!labeled && flag) {
            i = parseInt(points.length / 2);
            p1 = points[i];
            i = i + 1 >= points.length ? 0 : i + 1;
            p2 = points[i];
            p = [(p1[1] + p2[1]) / 2, (p1[0] + p2[0]) / 2];
            xyCur = this._getLpoint(p);
            append_t();
        }

        function append_t() {
            //Tip:直接在一个text中加stroke描边很糊，所以增加一个文本在地下做描边
            g.append("text").attr("x", xyCur.x - 6).attr("y", xyCur.y + 4).text(value).attr("stroke", '#fff')
                .style('font-size', '12px').style('font-weight', 'bold');
            g.append("text").attr("x", xyCur.x - 6).attr("y", xyCur.y + 4).text(value).attr("fill", color)
                .style('font-size', '12px').style('font-weight', 'bold');
            //.attr("transform","rotate("+rotation+","+xyCur.x+","+xyCur.y+")");
        }
        function distance(p1,p2) {
            return Math.pow(p1.x-p2.x,2)+Math.pow(p1.y-p2.y,2)
        }
    },

    _updateGrid: function () {
        if (!this._ctx) return;
        this._ctx.strokeStyle = this.options.elements.grid.uv.color;
        this._ctx.fillStyle = this.options.elements.grid.uv.color;
        this._ctx.lineWidth = 1;

        // draw
        if (this.data.data.uv) {
            var invalidValue = this.data.invalidValue;
            var data = this.data.data.uv.data;
            var yaxisType = this.options.yAxisType;
            // var yaxis = this._hpaToKm(this.data.yaxis_uv);
            var yaxis = this.data.yaxis_uv;
            var xaxis = this.data.xaxis,xaxis_uv = this.data.xaxis_uv || xaxis;
            var scale = (xaxis.length-1)/(xaxis_uv.length-1);
            for (var i = 0; i < yaxis.length; i++) {
                for (var j = 0; j < xaxis_uv.length; j++) {
                    var index = xaxis_uv.length * i + j;
                    var uvValue = [data[0][index], data[1][index]];
                    if (uvValue[0] != 0 && uvValue[1] != 0 && uvValue[0] != invalidValue && uvValue[1] != invalidValue) {
                        var w = Sun.Util.Weather.wind_getWindByUV(uvValue);
                        // var p = this._getXY1(j*scale,yaxisType == 'hpa' ? i : this._getY(yaxis[i]));
                        var p = yaxisType == 'hpa' ? this._getXY(j*scale,i) : this._getXY1(j*scale,this._getY(yaxis[i]));
                        p.y += this.options.margins.top;
                        Sun.Util.Geometry.drawWindByPosition(this._ctx, w.speed, w.dir, p, true, 25);
                    }
                }
            }
        }
    },
    _getXY1: function (xIndex, yIndex) {
        return {x: this._xTick * xIndex + 1, y: this._height() - this._yTick * yIndex*this.tickScale};
    },

    _getXY: function (xIndex, yIndex) {
        return {x: this._xTick * xIndex + 1, y: this._height() - this._yTick * yIndex};
    },


    /**
     * 根据hpa/km获取对应图表的索引位置
     * @param value {int} hpa数值
     * @param kmToHpa {Boolean} 是否是km转hpa。默认是hpa转km索引位置,若该属性为true，则计算km转hpa索引位置
     *                          Tip:在yAxisType为hpa时，计算hpa自己的索引位置
     * @return {number}
     * @private
     */
    _getY:function (value,kmToHpa) {
        var hpa_km = this.data.hpa_km;
        var idx0 = kmToHpa ? 1 : 0;
        var idx1 = kmToHpa ? 0 : 1;
        var yHpa = this.options.yAxisType == 'hpa';// Tip:如果只有hpa的y轴，则根据hpa算出索引的位置
        for(var i=1;i<hpa_km[idx0].length;i++){
            var i1 = kmToHpa ? i : i-1;// Tip:由于hpa数据为由大到小，km数据为由小到大
            var i2 = kmToHpa ? i-1 : i;
            var hpa1 = hpa_km[idx0][i1], hpa2 = hpa_km[idx0][i2];
            if(value<=hpa1 && value>=hpa2){
                var p = (value-hpa2)/(hpa1-hpa2);
                if(kmToHpa)
                    p = 1-p;
                var height1 = yHpa ? i-1 : hpa_km[idx1][i1], height2 = yHpa ? i : hpa_km[idx1][i2];
                return p*(height1-height2)+height2;
            }
        }
    },

    _hpaToKm: function (hPas) {
        var hpa_km = this.data.hpa_km;
        return km = hPas.map(function (hpa) {
            var idx = hpa_km[0].indexOf(hpa);
            return idx>=0 ? hpa_km[1][idx] : 0;
        });
    }

});


/**
 * 数值预报空间剖面
 *
 * Features :
 *      1. 该剖面为空间剖面，x轴为经纬度，间隔由options设置
 *      2. 需引用d3.js
 *
 * Update Note：
 *      + v1.0.2 ：Created
 *
 * @class LW.Profile.Isoline.Space
 * @extends LW.Profile.Isoline
 * @demo demo/plot/profileIsoline_space.html  {数值预报剖面--空间剖面}
 */

/**
 * @class LW.Profile.Isoline.Space
 * @constructor
 * @param panelContainer {string} 面板容器 style="position: absolute;"
 * @param map {L.Map} 地图
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.Profile.Isoline.Space}
 */
LW.Profile.Isoline.Space = LW.Profile.Isoline.extend({

    options: {
        /**
         * x轴的个数
         * @property xSize
         * @type {int}
         * @default 6
         */
        xSize: 6,
        /**
         * x轴单位
         * @property xUnit
         * @type {string}
         * @default '(km)'
         */
        xUnit: '',

        margins: {
            top: 30,
            right: 40,
            bottom: 40,
            left: 50
        },

        /**
         * 指示图片地址
         * @property iconUrl
         * @type {string}
         * @default 'marker.png'
         */
        iconUrl: 'marker.png'
    },


    /**
     * 设置剖面起始经纬
     * @method setLatlngs
     * @param sLatlng {L.Latlng} 开始经纬
     * @param eLatlng {L.Latlng} 结束经纬
     */
    setLatlngs: function (sLatlng, eLatlng) {
        this.sLatlng = sLatlng;
        this.eLatlng = eLatlng;
    },

    _updateAxis: function () {
        LW.Profile.prototype._updateAxis.call(this);

        this._x2axisgraphicnode = this._x2axisgraphicnode || this.g.append("g");
        this._clearSvgNode(this._x2axisgraphicnode);
        this._appendXaxis2(this._x2axisgraphicnode);
    },

    _appendXaxis2: function (x) {
        x.attr("class", "x axis-none-line")
            .attr("transform", "translate(0," + (this._height() + 15) + ")")
            .call(this._getx2Scale());
    },

    _getxScale: function () {
        if (this.sLatlng && this.eLatlng) {
            var nlng = (this.eLatlng.lng - this.sLatlng.lng) / (this.options.xSize - 1);
            var xAxis = [];
            for (var i = 0; i < this.options.xSize; i++) {
                var lng = Sun.Util.Math.toFixed(this.sLatlng.lng + nlng * i, 2);
                xAxis.push(lng + 'E');
            }
            var _x = d3.scale.ordinal()
                .domain(xAxis)
                .rangePoints([0, this._width()]);

            return d3.svg.axis()
                .scale(_x)
                .orient("bottom")
        }
    },
    _getx2Scale: function () {
        var nlat = (this.eLatlng.lat - this.sLatlng.lat) / (this.options.xSize - 1);
        var xAxis = [];
        for (var i = 0; i < this.options.xSize; i++) {
            var lat = Sun.Util.Math.toFixed(this.sLatlng.lat + nlat * i, 3);
            xAxis.push(lat + 'N');
        }
        var _x = d3.scale.ordinal()
            .domain(xAxis)
            .rangePoints([0, this._width()]);

        return d3.svg.axis()
            .scale(_x)
            .orient("bottom")
    },

    _initialShow: function () {
        LW.Profile.Isoline.prototype._initialShow.call(this);

        // upper svg
        this._upperSvg = this.cont.append("svg");
        this._upperSvg.attr("width", this.options.width - this.options.margins.left)
            .attr("height", this.options.margins.top + this._height())
            .style("position", "absolute")
            .style("top", 0)
            .style("left", this.options.margins.left);

        this._appendFoucs();
    },

    _appendFoucs: function () {
        // focus line
        var focusG = this._focusG = this._upperSvg.append("g");
        this._mousefocus = focusG.append('svg:line')
            .attr('class', 'mouse-focus-line')
            .attr('x2', '0')
            .attr('y2', '0')
            .attr('x1', '0')
            .attr('y1', '0');
        this._focuslabelY = focusG.append("svg:text")
            .style("pointer-events", "none")
            .attr("class", "mouse-focus-label-y")
            .attr("y", 20)
            .attr("x", 10);

        // focus backgroud
        this._upperSvg.append("rect")
            .attr("width", this._width())
            .attr("height", this._height())
            .style("fill", "none")
            .style("stroke", "none")
            .style("pointer-events", "all")
            .on("mousemove.focus", this._mousemoveHandler.bind(this))
            .on("mouseout.focus", this._mouseoutHandler.bind(this));
    },

    // mouse focus handle

    _mousemoveHandler: function (d, i, ctx) {
        if (this.sLatlng && this.eLatlng) {
            var coords = d3.mouse(this.canvas.node());
            var latlng = this._findLatlngForX(coords[0]);
            this._showDiagramIndicator(latlng, coords[0]);


            if (!this._marker) {
                var iconUrl = LW.defaultIconPath() + this.options.iconUrl;
                this._marker = new L.Marker(latlng, {icon: new L.Icon({iconUrl: iconUrl, iconAnchor: L.point(12, 32)})})
                    .addTo(this._map);
            } else {
                this._marker.setLatLng(latlng);
            }
        }
    },
    _mouseoutHandler: function () {
        if (this._marker) {
            this._map.removeLayer(this._marker);
            this._marker = null;
        }
        this._focusG.style("visibility", "hidden");
    },

    _findLatlngForX: function (x) {
        var latlng1 = this.sLatlng;
        var latlng2 = this.eLatlng;
        var scale = x / this._width();
        var lat = latlng1.lat + (latlng2.lat - latlng1.lat) * scale;
        var lng = latlng1.lng + (latlng2.lng - latlng1.lng) * scale;
        return [lat, lng];
    },

    _showDiagramIndicator: function (latlng, xCoordinate) {
        this._focusG.style("visibility", "visible");
        this._mousefocus.attr('x1', xCoordinate)
            .attr('y1', this.options.margins.top)
            .attr('x2', xCoordinate)
            .attr('y2', this.options.margins.top + this._height())
            .classed('hidden', false);

        var text = Sun.Util.Math.toFixed(latlng[1], 2) + 'E/' + Sun.Util.Math.toFixed(latlng[0], 2) + 'N';
        this._focuslabelY.text('指示位置：' + text);
    }
});


/**
 * 风剖面
 *
 * Features :
 *
 * Update Note：
 *      + v1.5.4 ：Created
 *
 * @class LW.Profile.Wind
 * @constructor
 * @extends LW.Profile
 * @demo demo/plot/profile/profileIsoline_wind.html  {激光雷达}
 */

LW.Profile.Wind = LW.Profile.extend({
    options: {
        /**
         * y轴单位
         * @property yUnit
         * @type {string}
         * @default '高度(米)''
         */
        yUnit: '高度(米)',
        margins: {
            top: 30,
            right: 10,
            bottom: 80,
            left: 50
        },
        legendData: Sun.LegendData.wind,
        wind:true,
        // timeFormat:'hh:mm'
    },

    _initialShow: function () {
        LW.Profile.prototype._initialShow.call(this);

        var canvas = this.canvas = this.cont.append("canvas");
        canvas.attr("width", this._width())
            .attr("height", this._height() + this.options.margins.top)
            .style("position", "absolute")
            .style("top", 0)
            .style("left", this.options.margins.left + 'px');

        this._ctx = canvas[0][0].getContext('2d');
    },

    _getxScale: function (orient) {
        var rows = this.data.ROWS,format = this.options.timeFormat;
        var xaxis = rows.map(function (item,i) {
            return format ? new Date(item.HAPPENTIME).format(format):item.HAPPENTIME.slice(11);
        });
        xaxis = [''].concat(xaxis).concat('.');//为了给风杆留下绘制的位置，所以左右各留1格
        var _x = d3.scale.ordinal()
            .domain(xaxis)
            .rangePoints([0, this._width()]);
        return d3.svg.axis()
            .scale(_x)
            .orient("bottom")
    },

    _appendXaxis: function (x) {
        x.attr("class", "axis")
            .attr("transform", "translate(0," + this._height() + ")")
            .call(this._getxScale())
            .style("text-anchor", "end");

        if(!this.options.timeFormat){
            x.selectAll("text")
                .attr("y", -5)
                .attr("x", -9)
                .attr("dy", ".35em")
                .attr("font-size", "12px")
                //旋转x轴label
                .attr("transform", "rotate(-90)")
                .style("text-anchor", "end")
                //日期
                .append("tspan")
                .attr("text-anchor", "middle")
                .attr("y", 5)
                .attr("x", -9)
                .attr("dy", ".35em")
                //旋转x轴label
                .attr("transform", "rotate(-90)")
                .style("text-anchor", "end");
            tspan = x.selectAll('tspan')[0];
            for(var i=1;i<tspan.length-1;i++){
                var ts = tspan[i];
                ts.innerHTML = this.data.ROWS[i-1].HAPPENTIME.slice(2,10);
            }
        }
    },

    _getyDomain1: function(){
        return d3.scale.ordinal()
            .domain([''].concat(this.data.HEIGHT))
            .rangePoints([this._height(),0]);
    },

    _getyScale: function () {
        var _y = this._getyDomain1();

        return d3.svg.axis()
            .scale(_y)
            .orient("left")
    },

    _gety2Scale: function () {

    },

    _appendYaxis: function (y) {
        y.attr("class", "y2 axis")
            .call(this._getyScale())
            .append("text")
            .attr("x", -this._height()/2)
            .attr("y", -40)
            .style("text-anchor", "center")
            .text(this.options.yUnit)
            //旋转x轴label
            .attr("transform", "rotate(-90)");
        y.selectAll("text")
            .attr("font-size", "12px")
    },

    _appendYaxis2: function (y) {
    },

    _setXYTick: function () {
        this._xTick = (this._width() - 2) / (this.data.ROWS.length + 1);
        this._yTick = (this._height() - 1) / (this.data.HEIGHT.length);
    },
    /**
     * 设置数据，生成剖面图
     * @method setData
     * @param data {Object} 数据，json
     * @param field {string} 非风数据时指定字段绘制色块
     * @return {LW.Profile.Isoline}
     */
    setData: function (data,field) {
        if (!data)
            return this;
        this.field = field;

        LW.Profile.prototype.setData.call(this, data);

        this.clear();

        // update grid
        this._updateGrid();
    },

    clear: function(){
        if(this._ctx)
            this._ctx.clearRect(0, 0, this._width(), this._height() + this.options.margins.top);
    },

    _updateGrid: function () {
        if (!this._ctx) return;

        var ctx = this._ctx;
        ctx.lineWidth = 1;
        var legendData = this.options.legendData;
        var rows = this.data.ROWS, heights = this.data.HEIGHT.length;
        for (var i = 0; i < rows.length; i++) {
            var item = rows[i];
            for (var j = 0; j < heights; j++) {
                if(this.options.wind){
                    var speed = item.WINDSPEED[j];
                    var dir = item.WINDDIR[j];
                    if (speed != null && dir != null) {
                        var p = this._getXY(i+1, j+1);
                        p.y += this.options.margins.top;
                        var color = Sun.Util.LegendData.getColorOfRangeLegend(legendData,speed);
                        ctx.strokeStyle = color;
                        ctx.fillStyle =color;
                        if(speed<1){
                            ctx.beginPath();
                            ctx.arc(p.x,p.y,2, 0, Math.PI*2);
                            ctx.fill();
                        }
                        else
                            Sun.Util.Geometry.drawWindByPosition(this._ctx, speed, dir, p, true, 18, 5);
                    }
                }
                else{
                    var value = item[this.field][j];
                    var p = this._getXY(i, j-1);
                    ctx.fillStyle = Sun.Util.LegendData.getColorOfRangeLegend(legendData,value);
                    ctx.fillRect(p.x+this._xTick/2, p.y+this._yTick/2, this._xTick + 1, this._yTick+1);
                }
            }
        }
    },

    _getXY: function (xIndex, yIndex) {
        return {x: this._xTick * xIndex + 1, y: this._height() - this._yTick * yIndex};
    }
});

/**
 * @module Layer.Plot.Profile
 */

(function () {

    /**
     *  以下常量与公式均为从《天气分析预报物理量计算基础》书籍中查询得到
     *  若未特殊说明，所有温度单位为℃，气压单位为hPa
     */
    var Const = {
        Rv:461.5,  //水汽比气体常数     单位:J/(Kg*K)    //参见P6
        Rd : 287.05, //干空气比气体常数   单位:J/(Kg*K)   //参见P6
        g : 9.81,    //重力加速度         单位:m/s^2    //参见P17
        cpd : 1004.675, //干空气的定压比热   单位:J/(Kg*K)    //参见P39
        cw : 4185.7,     //湿空气比定压热    单位:J/(Kg*K)   //参见P39
        cp : 1004.07,   //干空气比定压热容   单位:J/(Kg*K)    //参见P40
        //水汽化潜热（近似值，实际为变量，与温度相关，由于变化很小，近似为不变）若需要精确值，使用Lw方法获取；
        Lw : 2.501 * Math.pow(10,6),      // 单位:J/Kg    //参见P4
        TK : 273.15, //0℃对应的绝对温度     // 单位:K //参见P5
        P00 : 1000,  //1000hPa气压标准值
        Omega : 7.292 * Math.pow(10, -5),    //地球自转角速度(来源于百度百科:地球自转角速度)
        H_UNIT : 10,  // 高度单位,高度值*10
        waterDensity : 1 // 水的密度(单位g/cm3) 参考百度百科
    };

    // var Range={
    //         adiabat:{start:-80,end:180,gap:20},
    //         temp:{start:-120,end:50,gap:10,count:18},
    //         hpa:{start:100,end:1050},
    //         km:{start:-0.5,end:16,gap:1,count:16},
    //         hRatio:[0.05,0.1,0.2,0.5,1,1.5,2,3,4,6,8,12,16,20,24,30]
    // };

    // var hpa_km=[[1000,950,850,700,500,400,300,200,100],[0,0.7,1.5,3,5.5,7,9,12,16]];
    var hpa_km=[[1050,1000,925,850,700,500,400,300,200,100],[-0.5,0,0.7,1.47,3.05,5.6,7.3,9.5,12.4,16]];

    /**
     * T-LnP图
     *
     * Features :
     *      1. 干绝热线、湿绝热线、等比湿饱和线
     *      2. 温度曲线、状态曲线、露点温度线；温度曲线和状态曲线相交部分的面积绘制
     *      3. 需引用d3.js
     *
     * Update Note：
     *      + v1.3.0-dev ：Created
     *      + v1.4.1 : 坐标系由1000hpa到1050hpa，以适应地面坐标大于1000hpa的情况
     *      + v1.5.2 : Ranges范围配置由常量改为options属性
     *      + v1.5.3 : 增加风速线和假相当位温图，由options.chart2配置是否开启
     *      + v1.5.4 : 1. 增加鼠标移过展示高度和各个要素的插值数据
     *                 2. 图表1增加湿球温度线，图表2增加湿度线
     *                 3. 假相当位温图动态x轴，限定范围为最小值向下取整10 + 60。绘制时限定，鼠标移过展示插值时不限定
     *                 4. 增加高度AGL的展示
     *                 5. 优化风杆绘制位置，需要sun@1.0.25支持
     *
     * @class LW.Profile.T_LnP
     * @extends LW.Profile
     * @demo demo/plot/profile/profile_T-Inp.html {T-LnP图}
     * @demo demo/plot/profile/profile_T-Inp_θse.html {T-LnP+θse}
     * @demo demo/plot/profile/profile_T-Inp_WindVector.html {T-LnP+θse+风矢端图}
     */

    /**
     * @class LW.Profile.T_LnP
     * @constructor
     * @param panelContainer {string} 面板容器 style="position: absolute;"
     * @param map {L.Map} 地图
     * @param options {object} 外部属性，可重设Properties
     * @returns {LW.Profile.T_LnP}
     */

    LW.Profile.T_LnP = LW.Profile.extend({
        options: {
            /**
             * 剖面的css class
             * @property className
             * @type {string}
             * @default 'lw-tlnp-profile'
             */
            className: 'lw-profile lw-tlnp-profile',
            width: 700,
            height: 550,
            margins: {
                top: 30,
                right: 100,
                bottom: 30,
                left: 50
            },
            /**
             * 各种线的颜色配置
             * @property colors
             * @type {object}
             * @default {
                    dayAdiabat:'#ffafaf',
                    wetAdiabat:'#94c294',
                    hRation:'#94c294',
                    state:'#322cde',
                    t:'#fc312e',
                    td:'#158815'
                }
             */
            colors:{
                dayAdiabat:'#ffafaf',//干绝热线
                wetAdiabat:'#94c294',//湿绝热线
                hRation:'#94c294',//等比湿饱和线
                state:'#df0023',//状态曲线
                t:'#0066ff',//温度曲线
                td:'#009f3c',//露点温度
                wetbuld:'#06b0ff',//湿球温度
                θse:'#0560e9',//假相当位温
                rh:'#05a140',//湿度
                windVane:'#666',
                tempLine:'#0072ff',//温度线
                symbolLine:'#dba725',//标志线
                // 风线和风杆颜色。为地面高度AGL,每往上加3km切换一种颜色
                windColors:['#ff5a00','#009f3c','#00ffff','#e638ec','#0066ff','#df0023']
            },
            /**
             * 各种线的数值范围
             * @property ranges
             * @type {object}
             * @default {
                    adiabat:{start:-80,end:180,gap:20},
                    temp:{start:-120,end:50,gap:10},
                    hpa:{start:100,end:1050},
                    km:{start:-0.5,end:16,gap:1,count:16},
                    hRatio:[0.05,0.1,0.2,0.5,1,1.5,2,3,4,6,8,12,16,20,24,30]
                }
             */
            ranges:{
                adiabat:{start:-80,end:180,gap:20},
                temp:{start:-120,end:50,gap:10},
                hpa:{start:100,end:1050},
                km:{start:-0.5,end:16,gap:1,count:16},
                hRatio:[0.05,0.1,0.2,0.5,1,1.5,2,3,4,6,8,12,16,20,24,30]
            },
            // hpa_km:null,

            /**
             * 是否展示图表2，包含假相当位温图、风速图、湿度图
             * @property chart2Map
             * @type {Boolean}
             * @default false
             */
            chart2Map:false,

            /**
             * 是否展示鼠标移过标识线
             * @property focusLine
             * @type {Boolean}
             * @default false
             */
            focusLine:false,

            /**
             * 当前位置高度展示的颜色配置
             * @property AGL
             * @type {object}
             * @default {
                fill:'#ffe485',
                fillOpacity:0.2,
                textColor:'#e63753'
            }
             */
            AGL:{
                fill:'#ffe485',
                fillOpacity:0.2,
                textColor:'#e63753'
            }
        },


        _initialShow: function () {
            LW.Profile.prototype._initialShow.call(this);
            this._setMask();
            var maskId = 'url(#profile-mask'+this.id+')';

            var self = this;
            this.lineGen = d3.svg.line()
                .x(function(d) {
                    return self.xScale(d.t);
                })
                .y(function(d) {
                    return self.yScale(self._getY(d.p));
                    // return self.yScale(d.p);
                });
            this.position = function (value) {
                return {x:self.xScale(value.t),y:self.yScale(self._getY(value.p))};
            };

            this.g_dryAdiabat = this.g.append("g");
            this.g_wetAdiabat = this.g.append("g");
            this.g_hRatio = this.g.append("g");
            this.g_feature = this.g.append("g").attr('clip-path',maskId);

            //wind canvas
            var canvas = this.canvas = this.cont.append("canvas");
            canvas.attr("width", '40')
                .attr("height", this._height() + this.options.margins.top+20)
                .style("position", "absolute")
                .style("pointer-events", 'none')
                .style("top", 0)
                .style("left", this.options.margins.left+this._width() + 'px');

            this._ctx = canvas[0][0].getContext('2d');

            // 假相当位温图
            if(this.options.chart2Map){
                this.g_chart2 = this.g.append("g").attr("class", "chart2");
                this.g_chart2XAxis1 = this.g_chart2.append("g");//θse
                this.g_chart2XAxis2 = this.g_chart2.append("g");//wind
                this.g_chart2XAxis3 = this.g_chart2.append("g");//rh
                this.g_chart2Wind = this.g_chart2.append("g").attr('clip-path',maskId);
                this.g_chart2θse = this.g_chart2.append("g");
                this.g_chart2rh = this.g_chart2.append("g");
            }

            if(this.options.focusLine)
                this._appendFocus();
        },
        _setMask: function(){
            this.id = L.stamp(this);
            var x = this._width()-1,y = this._height()-1;
            x = this.options.chart2Map?(x+40+180):x;
            var defs = this.g.append('defs');
            var clipPath = defs.append('clipPath').attr('id','profile-mask'+this.id);
            var d = 'M1 1L1 '+ y +'L' + x + ' ' + y + 'L' + x + ' 1Z';
            clipPath.append('path').attr('d',d);
        },

        _getxScale: function () {
            var range = this.options.ranges;
            range.temp.count = (range.temp.end-range.temp.start)/range.temp.gap;
            var _x = this.xScale = d3.scale.linear()
                .domain([range.temp.start,range.temp.end])
                .range([0, this._width()]);


            return d3.svg.axis()
                .scale(_x)
                .orient("bottom")
                .ticks(range.temp.count)
                .tickSize(-this._height() - 1);
        },

        // 大气压坐标系
        _getyScale: function () {
            var ytick = this._yTick;
            var _maxH = this._maxH = 16;
            var hpaToRange = hpa_km[1].map(function (value) {
                return (_maxH - value) * ytick
            });
            var hpa = hpa_km[0].concat();
            hpa[0] = '';//1050hpa不展示
            var _y = d3.scale.ordinal()
                .domain(hpa)
                .range(hpaToRange);

            // var _y2 = this.yScale = d3.scale.linear()
            //     .domain([1000,100])
            //     .range([this._height(),0]);

            return d3.svg.axis()
                .scale(_y)
                .orient("left")
                .tickSize(-this._width());
        },

        // 海拔高度坐标系
        _gety2Scale: function () {
            var range = this.options.ranges;
            var _y2 = this.yScale = d3.scale.linear()
                .domain([range.km.start,range.km.end])
                .range([this._height(),0]);

            return d3.svg.axis()
                .scale(_y2)
                .orient("left")
                .tickFormat(d =>  d + "km" )
                .tickSize(26)
                .ticks(range.km.count);
        },

        _appendYaxis2: function (y) {
            y.attr("class", "y2 axis")
                .attr("transform", "translate(" + this._width() + ",0)")
                .call(this._gety2Scale());
        },

        _appendYaxis: function (y) {
            y.attr("class", "y axis")
                .call(this._getyScale())
                .append("text")
                .attr("x", 5)
                .attr("y", -10)
                .style("text-anchor", "end")
                .text(this.options.yUnit);
            var w = this._width(),h = this._height();
            var w2 = this.options.chart2Map?(w+40+180):w;
            y.select('path')
                .attr('d','M{0},0H0V{1}H{0}'.format(w2,h));
        },

        _updateAxis: function () {
            LW.Profile.prototype._updateAxis.call(this);
            if(this.options.chart2Map) {
                this._clearSvgNode(this.g_chart2XAxis1);
                this._clearSvgNode(this.g_chart2XAxis2);
                this._clearSvgNode(this.g_chart2XAxis3);
                this._appendXaxisChart2(this.g_chart2XAxis1,this.g_chart2XAxis2,this.g_chart2XAxis3);
            }
        },

        _appendXaxisChart2: function (x1,x2,x3) {
            var canvasWidth = 40;
            var startX = canvasWidth+this._width(),
                width=180,height = this._height(),self = this;
            var data = this.data,colors = this.options.colors;
            var min = Math.min.apply(null, data.JXDWW_T);
            min = Math.floor(min/10)*10;
            var max = min+60;
            data['θse'] = data.JXDWW_T.map(function (v){
                return v<max?v:max;
            })
            // 假相当位温
            x1.attr("class", "x2 axis")
                .attr("transform", "translate(0," + height + ")")
                .call(getXScale([min,max],10,'bottom',-height - 1,'chart2XAxis_θse'))
                .append("text")
                .attr("x", startX+12)
                .attr("y", 13)
                .style("text-anchor", "end")
                .text('θse');
            // x1.append('line')//图1-图2的连接线
            //     .attr('class','concat-line')
            //     .attr({x1:0,x2:startX,y1:0,y2:0});
            // x1.selectAll("text").style('fill',colors.θse);

            // 风速
            x2.attr("class", "x2 axis")
                .attr("transform", "translate(0,0)")
                .call(getXScale([0,60],10,'top',0,'chart2XAxis_wind'))
                .append("text")
                .attr("x", startX+12)
                .attr("y", -3)
                .style("text-anchor", "end")
                .text('风速');
            // x2.append('line')//图1-图2的连接线
            //     .attr('class','concat-line')
            //     .attr({x1:0,x2:startX,y1:0,y2:0});

            // 湿度
            x3.attr("class", "x2 axis")
                .attr("transform", "translate(0,0)")
                .call(getXScale([0,120],20,'top',0,'chart2XAxis_rh',120,-15))
                .append("text")
                .attr("x", startX+12)
                .attr("y", 15)
                .style("text-anchor", "end")
                .text('湿度');
            x3.selectAll("text").style('fill',colors.rh);

            function getXScale(range,gap,orient,tickSize,scaleName,hideTick,tickPadding) {
                var count = (range[1]-range[0])/gap;
                var _x = self[scaleName] =  d3.scale.linear()
                    .domain([range[0],range[1]])
                    .range([startX, startX+width]);

                return d3.svg.axis()
                    .scale(_x)
                    .orient(orient)
                    .ticks(count)
                    .tickSize(tickSize)
                    .tickPadding(tickPadding || 3)
                    .tickFormat(function(d,idx) {return idx==0||d==hideTick ? '': d});
            }
        },

        setData: function (data) {
            this.clear();
            if (!data)
                return this;
            if(data.hpa_km)
                hpa_km = data.hpa_km;

            LW.Profile.prototype.setData.call(this,data);


            this._updateBaseLine();
            this._updateFeatureLine();
            this._updateWindVane();
            this._updateAGL();//当前位置高度
            if(this.options.chart2Map)// Tip:chart2暂时为固定轴。不更新也可
                this._updateChart2Map();
        },

        clear: function(){
            this._clearSvgNode(this.g_dryAdiabat);
            this._clearSvgNode(this.g_wetAdiabat);
            this._clearSvgNode(this.g_hRatio);
            this._clearSvgNode(this.g_feature);
            this._ctx.clearRect(0,0,40,this._height() + this.options.margins.top+20);
            if(this.options.chart2Map){
                this._clearSvgNode(this.g_chart2Wind);
                this._clearSvgNode(this.g_chart2θse);
                this._clearSvgNode(this.g_chart2rh);
            }
        },

        _updateBaseLine: function () {
            var colors = this.options.colors,range = this.options.ranges;
            var lineGen = this.lineGen,getPosition=this.position;
            drawDryAdiabat(this.g_dryAdiabat);//干绝热线
            drawWetAdiabat(this.g_wetAdiabat);//湿绝热线
            drawHRatio(this.g_hRatio);//等比湿饱和线

            function drawDryAdiabat(g){
                for(var i=range.adiabat.start;i<=range.adiabat.end;i+=range.adiabat.gap){
                    var line=[];
                    for(var p=range.hpa.start;p<=range.hpa.end;p+=1){
                        var t = dryA_t(p,i);
                        if(t>=range.temp.start && t<=range.temp.end)
                            line.push({t:t,p:p});
                    }
                    drawLine(g,line,colors.dayAdiabat,{value:i,pos:0.2})
                }
            }
            function drawWetAdiabat(g) {
                for(var i=range.adiabat.start;i<=range.adiabat.end;i+=range.adiabat.gap){
                    var line=[];
                    for(var p=range.hpa.start;p<=range.hpa.end;p+=1){
                        var t = wetA_t(p,i,0.3);
                        if(t>=range.temp.start && t<=range.temp.end)
                            line.push({t:t,p:p});
                    }
                    drawLine(g,line,colors.wetAdiabat,{value:i,pos:0.3})
                }
            }
            function drawHRatio(g) {
                for(var i=0;i<=range.hRatio.length;i++) {
                    var line = [];
                    for(var p=400;p<=range.hpa.end;p+=1){
                        var t = hRatio_t(range.hRatio[i],p);
                        if(t>=range.temp.start && t<=range.temp.end)
                            line.push({t:t,p:p});
                    }
                    drawLine(g,line,colors.hRation,{value:range.hRatio[i],pos:0.3});
                }
            }

            function drawLine(g,line,color,text) {
                if(line.length>0){
                    g.append('svg:path')
                        .attr('d', lineGen(line))
                        .attr({'stroke':color,'stroke-dasharray':'3,3','stroke-width':1,'fill':'none'});
                    if(text){
                        var idx = Math.ceil(line.length*text.pos);
                        var position = getPosition(line[idx]);
                        g.append("text")
                            .attr({x:position.x,y:position.y,fill:color})
                            .style("font-size", 12)
                            .style("text-anchor", "middle")
                            .text(text.value);
                    }
                }
            }
        },

        _updateFeatureLine:function () {
            var colors = this.options.colors;
            var lineGen = this.lineGen,getPosition = this.position;
            var data = this.data,g = this.g_feature;
            var range = this.data.range,invalid=data.invalid;

            // 绘制颜色区块
            var iPoint = data.heightPoints.LFC,color = colors.t;
            if(iPoint != invalid)
                drawArea(data.ZP[0],iPoint,colors.state);
            if(data.heightPoints.EL != invalid){
                drawArea(iPoint,data.heightPoints.EL,colors.t);
                iPoint = data.heightPoints.EL;
                color = colors.state;
            }
            if(iPoint != invalid)
                drawArea(iPoint,data.heightPoints.EAL,color);

            // 绘制折线
            drawLine(data.ZT,colors.state,false);//状态曲线
            drawLine(data.CTD,colors.td,false);//露点温度
            drawLine(data.CT,colors.t,true);//温度曲线
            drawLine(data.wetbuld,colors.wetbuld,false);//露点温度

            // 绘制标识线
            drawSymbolLine();
            drawTempLine();


            function drawLine(temp,color,drawPoints) {
                if(!temp) return;
                var line = [],points=[];
                for(var i=0;i<data.ZP.length;i++){
                    var p = data.ZP[i];
                    var item = {t:temp[i],p:p};
                    line.push(item);
                    if(drawPoints){
                        if(hpa_km[0].indexOf(p)!=-1)
                            points.push(item);
                    }
                }
                g.append('svg:path')
                    .attr('d', lineGen(line))
                    .attr('stroke', color)
                    .attr('stroke-width', 2)
                    .attr('fill', 'none');

                if(drawPoints){
                    for(var k=0;k<points.length;k++){
                        var pos = getPosition(points[k]);
                        g.append('circle')
                            .attr({'cx':pos.x,'cy':pos.y,'r':2.5,'fill':color});
                        g.append("text")
                            .attr({x:pos.x+5,y:pos.y+5,fill:color})
                            .style("font-size", 12)
                            .style("text-anchor", "start")
                            .text(points[k].t);
                    }
                }
            }

            function drawArea(end,start,color) {
                var line1 = [], line2 = [];
                for(var i=0;i<data.ZP.length;i++){
                    var p = data.ZP[i];
                    if(p>=start && p<=end){
                        line1.push({t:data.ZT[i],p:p});
                        line2.push({t:data.CT[i],p:p});
                    }
                }
                var line = line1.concat(line2.reverse());
                g.append('svg:path')
                    .attr('d', lineGen(line))
                    .attr('stroke', 'none')
                    .attr('fill', color)
                    .attr('fill-opacity', 0.4);
            }

            function drawSymbolLine() {
                for(var key in data.heightPoints){
                    if(key != 'EAL'){
                        var p = data.heightPoints[key];
                        if(p!=invalid){
                            var position = getPosition({t:0,p:p});
                            g.append("line")
                                .attr({x1:48,x2:70,y1:position.y,y2:position.y})
                                .attr({'stroke':colors.symbolLine,'stroke-width':2});
                            g.append("text")
                                .attr({x:48,y:position.y-2,fill:colors.symbolLine})
                                .style("font-size", 11)
                                .style("text-anchor", "start")
                                .text(key.toLocaleUpperCase());
                        }
                    }
                }
            }

            function drawTempLine() {
                for(var i=0;i<data.temPoints.length;i++){
                    var p = data.temPoints[i].hPa;
                    if(p!=invalid){
                        var position = getPosition({t:0,p:p});
                        g.append("line")
                            .attr({x1:48,x2:70,y1:position.y,y2:position.y})
                            .attr({'stroke':colors.tempLine,'stroke-width':2});
                        g.append("text")
                            .attr({x:45,y:position.y+5,fill:colors.tempLine})
                            .style("font-size", 13)
                            .style("text-anchor", "end")
                            .text(data.temPoints[i].name+'℃');
                    }
                }
            }
        },

        _getWindColor:function (h){
            var AGL=this.data.AGL||0,colors = this.options.colors;
            if(colors.windColors){
                var idx = Math.floor((h-AGL/1000)/3);
                return colors.windColors[idx];
            }
            return colors.windVane;
        },

        _updateWindVane:function () {
            var data = this.data,invalid=data.invalid;
            var ctx = this._ctx,y_offsest = this.options.margins.top;
            for(var i=0;i<data.WIND_P.length;i++){
                var p = data.WIND_P[i],h = this._getY(p);
                var wind = data.WIND_VALUE[i];
                if(wind[0] != invalid && wind[1] != invalid){
                    var y = this.yScale(this._getY(p))+y_offsest;
                    var color = this._getWindColor(h);
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    Sun.Util.Geometry.drawWindByPosition(ctx,wind[1],wind[0], {x:20,y:y},true,24,6,true);
                }
            }
        },

        _updateAGL:function (){
            var data = this.data,AGL = data.AGL;
            if(AGL){
                var xy = this._getXY(0,AGL/1000+0.5);//开始值为-0.5不是0.所以+0.5修正下
                var g = this.g_feature,opts = this.options.AGL;
                if(!this.AGLRect){ // clear 的时候不clear rect
                    this.AGLRect = g.append("rect")
                        .attr("width", this._width())
                        .style("fill", opts.fill)
                        .style("fill-opacity", opts.fillOpacity)
                        .style("stroke", "none")
                        .style("pointer-events", "all")
                }
                this.AGLRect.attr('y',this._height()-xy.y)
                    .attr("height", xy.y);

                g.append("text")
                    .attr({x:75,y:this._height()-10,fill:opts.textColor})
                    .attr('style', 'font-weight: bold')
                    .style("pointer-events", "none")
                    .text('AGL:'+AGL+'m');
            }
        },

        _updateChart2Map: function(){
            var data = this.data,invalid=data.invalid,self = this;
            var opts = this.options;
            drawWindLine(this.g_chart2Wind);
            drawWindθse(this.g_chart2θse);//假相当位温
            drawRHLine(this.g_chart2rh);

            function drawWindLine(g) {
                var line = d3.svg.line()
                    .x(function(d) {
                        return self['chart2XAxis_wind'](d.x);
                    })
                    .y(function(d) {
                        return self.yScale(self._getY(d.p));
                    });
                for(var i=0;i<data.WIND_P.length;i++){
                    var p = data.WIND_P[i],h = self._getY(p);
                    var w = data.WIND_VALUE[i];
                    var color = self._getWindColor(h);
                    if(w[0] != invalid && w[1] != invalid){
                        g.append('svg:path')
                            .attr('d', line([{x:0,p:p},{x:w[1],p:p}]))
                            .attr({'stroke':color,'stroke-width':2,'fill':'none'});
                    }
                }
            }
            function drawWindθse(g) {
                var lineGen = d3.svg.line()
                    .x(function(d) {
                        return self['chart2XAxis_θse'](d.x);
                    })
                    .y(function(d) {
                        return self.yScale(self._getY(d.p));
                    });
                var line = [];
                for(var i=0;i<data.JXDWW_P.length;i++){
                    var p = data.JXDWW_P[i];
                    var item = {x:data.θse[i],p:p};
                    line.push(item);
                }
                g.append('svg:path')
                    .attr('d', lineGen(line))
                    .attr('stroke', opts.colors.θse)
                    .attr('stroke-width', 2)
                    .attr('fill', 'none');
            }
            function drawRHLine(g) {
                if(data.CRH){
                    var lineGen = d3.svg.line()
                        .x(function(d) {
                            return self['chart2XAxis_rh'](d.x);
                        })
                        .y(function(d) {
                            return self.yScale(self._getY(d.p));
                        });
                    var line = [];
                    for(var i=0;i<data.ZP.length;i++){
                        var p = data.ZP[i];
                        var item = {x:data.CRH[i],p:p};
                        line.push(item);
                    }
                    g.append('svg:path')
                        .attr('d', lineGen(line))
                        .attr('stroke', opts.colors.rh)
                        .attr('stroke-width', 2)
                        .attr('fill', 'none');
                }
            }
        },

        _getY:function (hpa) {
            for(var i=1;i<hpa_km[0].length;i++){
                var hpa1 = hpa_km[0][i-1], hpa2 = hpa_km[0][i];
                if(hpa<=hpa1 && hpa>=hpa2){
                    var p = (hpa-hpa2)/(hpa1-hpa2);
                    var height1 = hpa_km[1][i-1], height2 = hpa_km[1][i];
                    return p*(height1-height2)+height2;
                }
            }
        },

        _getHpa:function (km){
            for(var i=1;i<hpa_km[1].length;i++){
                var km1 = hpa_km[1][i-1], km2 = hpa_km[1][i];
                if(km>=km1 && km<=km2){
                    var p = (km-km2)/(km1-km2);
                    var height1 = hpa_km[0][i-1], height2 = hpa_km[0][i];
                    return p*(height1-height2)+height2;
                }
            }
        },

        _setXYTick: function () {
            var range = this.options.ranges;
            this._xTick = this._width()/range.temp.count;
            this._yTick = this._height()/(range.km.count-range.km.start);
        },

        _getXY: function (xIndex, yIndex) {
            return {x: this._xTick * xIndex + 1, y: this._yTick * yIndex};
        },

        // mouse focus handle

        _appendFocus: function () {
            var w = this._width();
            var w2 = this.options.chart2Map?(w+40+180):w;
            // focus line
            var focusG = this._focusG = this.svg.append("g")
                .attr("transform", "translate(" + this.options.margins.left + "," + this.options.margins.top + ")")
                .style("visibility", "hidden");
            this._mousefocus = focusG.append('svg:line')
                .attr('class', 'mouse-focus-line')
                .attr('x1', 0)
                .attr('x2', w2);
            this._focuslabelY = focusG.append("svg:text")
                .style("pointer-events", "none")
                .attr("class", "mouse-focus-label");
            this._focusLabel = {
                CTD:{colorKey:'td',x:w/2-66,unit:'℃'},
                wetbuld:{colorKey:'wetbuld',x:w/2-22,unit:'℃'},
                CT:{colorKey:'t',x:w/2+22,unit:'℃'},
                ZT:{colorKey:'state',x:w/2+66,unit:'℃'},
                'JXDWW_T':{colorKey:'θse',x:w2-40,unit:'k'},
                CRH:{colorKey:'rh',x:w2-80,unit:'%'},
                'WIND_VALUE':{colorKey:'#333',x:w-90,unit:'m/s'},
                'WIND_DIR':{colorKey:'#333',x:w-40,unit:''}
            };
            var colors = this.options.colors;
            for(var key in this._focusLabel){
                var item = this._focusLabel[key];
                item.label = focusG.append("svg:text")
                    .attr("x", item.x)
                    .attr("class", "mouse-focus-label")
                    .style("fill",colors[item.colorKey]);
            }

            // focus backgroud
            focusG.append("rect")
                .attr("width", w2)
                .attr("height", this._height())
                .style("fill", "none")
                .style("stroke", "none")
                .style("pointer-events", "all")
                .on("mousemove.focus", this._mousemoveHandler.bind(this))
                .on("mouseout.focus", this._mouseoutHandler.bind(this));
        },

        _mousemoveHandler: function (d, i, ctx) {
            var coords = d3.mouse(this.canvas.node());
            var top = this.options.margins.top;
            this._showFocusLine(coords[0],coords[1]-top);

        },
        _mouseoutHandler: function () {
            this._focusG.style("visibility", "hidden");
        },

        _showFocusLine: function (x, y) {
            if(this.yScale){
                this._focusG.style("visibility", "visible");
                this._mousefocus
                    .attr('y1', y)
                    .attr('y2', y)
                    .classed('hidden', false);

                var _y = this.yScale.invert(y),
                    hpa = this._getHpa(_y);
                this._focuslabelY.attr("y", y-5)
                    .attr("x", 15)
                    .text(Math.round(_y*1000)+'m '+(hpa?(Math.round(hpa)+'hpa'):''));
                this._setLineLabel(hpa,y);
            }
        },

        _setLineLabel:function (hpa,y){
            var data = this.data,invalid = data.invalid;
            var labels = this._focusLabel;
            getX(['CT','CTD','ZT','wetbuld','CRH'],'ZP');
            getX(['JXDWW_T'],'JXDWW_P');
            getX(['WIND_VALUE'],'WIND_P');

            function getX(keys,hKey) {
                var index = -1, h1, h2;
                for (var i = 0; i <= data[hKey].length - 1; i++) {
                    h1 = data[hKey][i], h2 = data[hKey][i + 1];
                    if (hpa <= h1 && hpa >= h2) {
                        index = i;
                        break;
                    }
                }
                for (i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var item = data[key];
                    if(item){
                        if (index >= 0) {
                            var v1 = item[index], v2 = item[index + 1];
                            if(key == 'WIND_VALUE'){
                                var dir1 = v1[0],dir2= v2[0];
                                if(dir1!=invalid && dir2 !=invalid)
                                    var dir = getValue(dir1,dir2);
                                v1 = v1[1];
                                v2 = v2[1];
                            }
                            if(v1!=invalid && v2 !=invalid)
                                var v = getValue(v1,v2)
                        }
                        labels[key].label
                            .attr("y", y - 5)
                            .text(typeof v != "undefined" ? (v + labels[keys[i]].unit) : '');
                        if(key == 'WIND_VALUE')
                            labels['WIND_DIR'].label
                                .attr("y", y - 5)
                                .text(typeof dir != "undefined" ? (Sun.Weather.wind_getWindDirDesc(dir,v,true)) : '');
                    }
                }

                function getValue(v1,v2){
                    var value = (hpa - h1) / (h2 - h1) * (v2 - v1) + v1;
                    return Math.round(value);
                }
            }
        }
    });

    /**
     * 位温计算公式 参见P33 4.1.8
     * @param t   气温（单位℃)
     * @param p     气压(单位hPa）
     * @return      位温（单位℃）
     */
    function dryA_ww(t,p) {
        //公式: θ = T * (1000/p)^(Rd/Cpd)
        return (t + Const.TK ) * Math.pow(Const.P00/p,Const.Rd/Const.cpd) - Const.TK;
    }
    /**
     * 根据位温公式逆推得到温度
     * @param p     气压
     * @param θ {number}
     * @return {number}   抬升至气压处温度
     */
    function dryA_t(p,θ) {
        // 由位温公式逆推：T = θ/((1000/p)^(Rd/Cpd))
        var fm1 = Math.pow((Const.P00)/p,Const.Rd/Const.cpd);
        return (θ + Const.TK )/fm1 - Const.TK;
    }
    /**
     * 根据位温公式逆推得到气压
     * @param t     气温（单位℃）
     * @param θ  {number}
     * @return {number}   气温对应气压（单位hPa）
     */
    function dryA_p(t,θ) {
        return 1000 * Math.pow((t + Const.TK)/(θ + Const.TK) , Const.cpd/Const.Rd);
    }

    function wetA_ww(t, p) {
        var θ = dryA_ww(t,p);
        var r = HHB(t,p);
        var lw = Lw(t);
        var s1 = (θ + Const.TK) * (1 + 0.46 * r); //计算第一部分
        var s2 = Const.cpd * (t + Const.TK); //计算真数分母
        var s3 = Math.exp(lw * r / s2);  //计算幂计算部分
        return s1 * s3 - Const.TK;
    }

    function wetA_t( p, theta, jd){
        //设置初始值
        var t_start = -140,t_end = 55;
        var lt = t_start * 0.5 + t_end * 0.5;

        // 为避免此处发生死循环,加入检测条件跳出
        var j = 0;
        while ( t_end - t_start >= Math.pow(10,-1 * jd) ){

            j++;
            if (j >= 2000)
                return lt;

            var v = wetA_ww(lt,p);
            if ( v == theta) return lt;
            if ( v < theta ) t_start = lt;
            if ( v > theta ) t_end = lt;
            lt = t_start * 0.5 + t_end * 0.5;
        }
        return lt;
    }

    function hRatio_t(hRatio,p) {
        var e = p*hRatio/622;
        var lne = Math.log(e/6.112);
        return (243.5*lne)/(17.67-lne);
    }
    /**
     * 水汽压(根据露点温度差计算) 参见P5 1.1.5
     * @param   td 当前温度下的露点温度
     * @return  水汽压
     */
    function SQY( td){
        var Td = td + Const.TK;
        return Math.exp(53.67957 - 6743.769/Td - 4.8451 * Math.log(Td));
    }

    /**
     * 混合比 参见P9 1.3.13
     * @param td 当前温度下的露点温度
     * @param p 气压
     * @return  比湿 (单位)Kg/Kg
     */
    function HHB( td, p){
        //混合比公式(约等于比湿)q = 0.622 * e/p
        var e = SQY(td);
        return 0.622 * e/(p - e);
    }
    /**
     * 水汽化潜热精确公式        //参见P17
     * @param t     温度
     * @return {number}
     */
    function Lw(t){
        return Const.Lw - 0.00237 * Math.pow(10,6) * t;
    }

    /**
     * 风矢端图
     *
     * Features :
     *
     * @class LW.Profile.WindVector
     * @constructor
     * @extends L.Class
     * @demo demo/plot/profile/profile_T-Inp_WindVector.html {T-LnP+θse+风矢端图}
     */
    LW.Profile.WindVector = L.Class.extend({
        options: {
            /**
             * 剖面边长（单位：px）
             * @property side
             * @type {number}
             * @default 440
             */
            side: 440,
            /**
             * 最大半径（单位：px）
             * @property maxRadius
             * @type {number}
             * @default 200
             */
            maxRadius:200,
            /**
             * 最大风（单位：m/s）
             * @property maxWind
             * @type {number}
             * @default 60
             */
            maxWind:60,
            /**
             * 风间隔（单位：m/s）
             * @property windGap
             * @type {number}
             * @default 10
             */
            windGap:10,
            /**
             * 风圈颜色
             * @property windCircleColor
             * @type {string}
             * @default '#d28e05'
             */
            windCircleColor:'#d28e05',
            /**
             * 风线颜色。为地面高度AGL,每往上加3km切换一种颜色
             * @property windLineColor
             * @type {string|Array}
             * @default ['#ff5a00','#009f3c','#00ffff','#e638ec','#0066ff','#df0023']
             */
            windColors:['#ff5a00','#009f3c','#00ffff','#e638ec','#0066ff','#df0023'],
            /**
             * 风关键点文字颜色
             * @property windPosColor
             * @type {string}
             * @default '#fff'
             */
            windPosColor:'#fff'
        },

        initialize: function (panelContainer, options) {
            L.setOptions(this, options);
            // 展示初始化
            var pContainer = document.getElementById(panelContainer);
            this.container = L.DomUtil.create("div", this.options.className);
            pContainer.appendChild(this.container);
            this.cont = d3.select(this.container);

            var side = this.options.side;
            var canvas = this.canvas = this.cont.append("canvas");
            canvas.attr("width", side)
                .attr("height", side)
            // .style("position", "absolute")
            // .style("top", 0)
            // .style("left",0);

            this._ctx = canvas[0][0].getContext('2d');
        },

        setData:function (data) {
            this.clear();
            this._drawBaseCircle();
            this.data = data;
            if(data){
                if(data.hpa_km)
                    hpa_km = data.hpa_km;
                this._drawWindLine(data);
            }
        },

        clear: function(){
            this._ctx.clearRect(0,0,this.options.side,this.options.side);
        },

        _drawBaseCircle:function(){
            var opt = this.options,ctx = this._ctx;
            var center = opt.side/2,unitRadius = opt.maxRadius/opt.maxWind;

            ctx.strokeStyle = opt.windCircleColor;
            ctx.fillStyle = opt.windCircleColor;
            ctx.textAlign = 'left';
            ctx.lineWidth = 1;

            var padding = opt.side/2-opt.maxRadius;
            ctx.moveTo(padding,center);
            ctx.lineTo(opt.side-padding,center);
            ctx.moveTo(center,padding);
            ctx.lineTo(center,opt.side-padding);
            ctx.stroke();

            for(var i=0;i<=opt.maxWind;i+=opt.windGap){
                if(i>0){
                    ctx.setLineDash([6,2]);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(center, center, i*unitRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fillText(i, center+i*unitRadius-13, center+10);
                    ctx.fillText(i, center-i*unitRadius+1, center+10);
                    ctx.fillText(i, center, center+i*unitRadius-2);
                    ctx.fillText(i, center, center-i*unitRadius+10);
                }
                if(i<opt.maxWind){
                    ctx.setLineDash([2,2]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(center, center, (i+opt.windGap/2)*unitRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        },

        _getWindColor:function (h){
            var AGL=this.data.AGL||0,colors = this.options.colors;
            var idx = Math.floor((h-AGL/1000)/3);
            return this.options.windColors[idx];
        },

        _getY:function (hpa) {
            for(var i=1;i<hpa_km[0].length;i++){
                var hpa1 = hpa_km[0][i-1], hpa2 = hpa_km[0][i];
                if(hpa<=hpa1 && hpa>=hpa2){
                    var p = (hpa-hpa2)/(hpa1-hpa2);
                    var height1 = hpa_km[1][i-1], height2 = hpa_km[1][i];
                    return p*(height1-height2)+height2;
                }
            }
        },
        _drawWindLine:function (data) {
            var opt = this.options, ctx = this._ctx;
            var center = opt.side/2,unitRadius = opt.maxRadius/opt.maxWind;

            ctx.fillStyle = opt.windPosColor;
            ctx.textAlign = 'center';
            ctx.setLineDash([]);
            ctx.beginPath();

            for(var i=0;i<data.WIND_VALUE.length;i++){
                var wind = data.WIND_VALUE[i];
                if(i==0)
                    ctx.moveTo(center,center);
                if(wind[0] != data.invalid && wind[1] != data.invalid){
                    var uv = Sun.Weather.wind_getUVByWind(wind[1],wind[0]);
                    var p = data.WIND_P[i],h = this._getY(p);
                    ctx.strokeStyle = this._getWindColor(h);
                    var x = center+uv.u*unitRadius,y = center-uv.v*unitRadius;
                    ctx.lineTo(x,y);
                    ctx.fillText(p, x,y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x,y);
                }
            }
        }
    });
})();


/**
 * @module Layer.Plot.Profile
 */

/**
 * 雷达剖面
 *
 * Features :
 *      1. 该剖面为空间剖面，需用Profile.Editable绘制两点，并将起始经纬传入用于绘制x坐标轴
 *      2. 为了UI美观,雷达高度为0-20km，间隔为0.5km
 *      3. 可支持鼠标移过剖面图，在gis上显示改点对应的位置
 *      4. 需引用d3.js
 *
 * Update Note：
 *      + v1.5.3 ：增加dataIndexed属性，兼容支持数据为图例索引或dbz数据（dbz值得为图例中value值）
 *
 * @class LW.Profile.Radar
 * @extends LW.Profile
 * @demo demo/plot/profile/profileRadar.html  {雷达剖面}
 */

/**
 * @class LW.Profile.Radar
 * @constructor
 * @param panelContainer {string} 面板容器 style="position: absolute;"
 * @param map {L.Map} 地图
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.Profile.Radar}
 */
LW.Profile.Radar = LW.Profile.extend({
    options: {
        /**
         * 剖面的css class
         * @property className
         * @type {string}
         * @default 'lw-radar-profile'
         */
        className: 'lw-radar-profile',

        /**
         * 剖面长度（单位：px）
         * @property width
         * @type {number}
         * @default 600
         */
        width: 600,

        /**
         * 剖面宽度（单位：px）
         *
         * 注：最好使用默认长宽
         * @property height
         * @type {number}
         * @default 260
         */
        height: 260,

        /**
         * 剖面外边距，可以调整剖面与外容器上下左右的距离
         * @property margins
         * @type {object}
         * @default {top: 30,right: 40,bottom: 30,left: 50}
         */
        margins: {
            top: 30,
            right: 40,
            bottom: 30,
            left: 50
        },

        /**
         * x轴单位
         * @property xUnit
         * @type {string}
         * @default '(km)'
         */
        xUnit: '(km)',

        /**
         * x轴单位位置
         * @property xUnitP
         * @type {string}
         * @default {x: 35,y: 17}
         */
        xUnitP: {
            x: 35,
            y: 17
        },

        /**
         * y轴单位
         * @property yUnit
         * @type {string}
         * @default '(km)'
         */
        yUnit: '(km)',

        /**
         * 雷达图例数据
         * @property legendData
         * @type {Array}
         * @default null
         */
        legendData: null,

        /**
         * 是否是图例索引数据
         * @property dataIndexed
         * @type {Boolean}
         * @default true
         */
        dataIndexed:true,

        /**
         * 指示图片地址
         * @property iconUrl
         * @type {string}
         * @default 'marker.png'
         */
        iconUrl: 'marker.png'
    },

    _initialShow: function () {
        LW.Profile.prototype._initialShow.call(this);

        //canvas
        var canvas = this.canvas = this.cont.append("canvas");
        canvas.attr("width", this._width())
            .attr("height", this._height())
            .style("position", "absolute")
            .style("top", (this.options.margins.top - 0.5) + 'px')
            .style("left", (this.options.margins.left + 0.5) + 'px');

        this._ctx = canvas[0][0].getContext('2d');


        // upper svg
        this._upperSvg = this.cont.append("svg");
        this._upperSvg.attr("width", this.options.width - this.options.margins.left)
            .attr("height", this._height())
            .style("position", "absolute")
            .style("top", this.options.margins.top)
            .style("left", this.options.margins.left);

        this._appendFoucs();
    },

    _appendFoucs: function () {
        // focus line
        var focusG = this._focusG = this._upperSvg.append("g");
        this._mousefocus = focusG.append('svg:line')
            .attr('class', 'mouse-focus-line')
            .attr('x2', '0')
            .attr('y2', '0')
            .attr('x1', '0')
            .attr('y1', '0');
        this._focuslabelY2 = focusG.append("svg:text")
            .style("pointer-events", "none");
        this._focuslabelY = focusG.append("svg:text")
            .style("pointer-events", "none")
            .attr("class", "mouse-focus-label-y");

        // focus backgroud
        this._upperSvg.append("rect")
            .attr("width", this._width())
            .attr("height", this._height())
            .style("fill", "none")
            .style("stroke", "none")
            .style("pointer-events", "all")
            .on("mousemove.focus", this._mousemoveHandler.bind(this))
            .on("mouseout.focus", this._mouseoutHandler.bind(this));
    },

    /**
     * 设置剖面起始经纬
     * @method setLatlngs
     * @param sLatlng {L.Latlng} 开始经纬
     * @param eLatlng {L.Latlng} 结束经纬
     */
    setLatlngs: function (sLatlng, eLatlng) {
        this.sLatlng = sLatlng;
        this.eLatlng = eLatlng;
    },

    _getxScale: function () {
        if (this.sLatlng && this.eLatlng) {
            var d = this.sLatlng.distanceTo(this.eLatlng) / 1000;
            var _x = d3.scale.linear()
                .domain([0, d])
                .range([0, this._width()]);

            return d3.svg.axis()
                .scale(_x)
                .orient("bottom")
                .outerTickSize(-this._height());
        }
    },

    _get5x: function (value) {
        return Math.ceil(value/5)*5;
    },

    _get5xArray: function (value,gap) {
        var v_5x = this._get5x(value);
        var arr=[];
        for(var i=0;i<=v_5x;i+=gap){
            arr.push(i);
        }
        return arr;
    },

    _getyScale: function () {
        /*
         * 为了美观性考虑，y轴定为20公里总高度，每隔5公里绘制辅助线，每隔1公里有刻度
         * 并与数据组协定传回数据也是到20公里
         */
        var domain = this.equalGap ? this._get5xArray(this.height,5) : [];

        var _y = d3.scale.ordinal()
            .domain(domain)
            .rangePoints([this._height(), 0]);

        return d3.svg.axis()
            .scale(_y)
            .orient("left")
            .tickSize(-this._width() - 1)
    },

    _gety2Scale: function () {
        var domain = this.equalGap ? this._get5xArray(this.height,1) : [].concat(this.data.yaxis).reverse();
        var _y = d3.scale.ordinal()
            .domain(domain)
            .rangePoints([this._height(), 0]);

        return d3.svg.axis()
            .scale(_y)
            .orient("left")
            .tickFormat(this.equalGap?'':function (d) {return d})
            .innerTickSize(-8);
    },

    _appendYaxis2: function (y) {
        y.attr("class", "y axis")
            .call(this._gety2Scale());
    },

    _setXYTick: function () {
        this._xTick = (this._width()) / (this.data.xaxiscounts);
        if(this.equalGap){
            var y_len = this._get5x(this.height)/this.gap;
            this._yOff = y_len - this.height/this.gap;
            this._yTick = (this._height()) / (y_len - 1);
        }
        else{
            this._yOff = -1;//Tip:第一行不绘制
            this._yTick = this._height() / (this.data.yaxis.length-1);
        }

    },

    /**
     * 设置数据并绘制
     * @method setData
     * @param data {Array}
     * @param equalGap {Boolean} 是否是等间隔数据
     * @param gap {number}
     * @param height {number}
     */
    setData: function (data,equalGap,gap,height) {
        if (!data)
            return this;

        this.equalGap = typeof equalGap != 'undefined' ? equalGap : true;
        this.gap = gap || 0.5;
        this.height = height || 20;

        LW.Profile.prototype.setData.call(this, data);

        // update grid
        this._updateRadar();
    },

    clear : function () {
        if(this._ctx)
            this._ctx.clearRect(0, 0, this._width(), this._height());
    },

    _updateRadar: function () {
        if (!this._ctx || !this.options.legendData) return;
        // clear
        this._ctx.clearRect(0, 0, this._width(), this._height());

        for (var i = 0, yCounts = this.data.yaxis.length; i < yCounts; i++) {
            for (var j = 0; j < this.data.xaxiscounts; j++) {
                var index = this.data.xaxiscounts * i + j;
                if (index < this.data.data.length) {
                    var value = this.data.data[index];
                    var idx = this.options.dataIndexed ? (value - 1) : //Tip:一开始就是索引-1。忘记原因
                        Sun.Util.Array.getItemIndexByField(this.options.legendData,'value',value);
                    if(idx != -1){
                        var color = this.options.legendData[idx].color;
                        var p = this._getXY(j, i);
                        this._ctx.fillStyle = color;
                        this._ctx.fillRect(p.x, p.y, this._xTick + 1, this._yTick+1);
                    }
                }
            }
        }
    },

    _getXY: function (xIndex, yIndex) {
        return {x: this._xTick * xIndex, y: this._yTick * (yIndex + this._yOff)};
    },


    // mouse focus handle

    _mousemoveHandler: function (d, i, ctx) {
        if(!this.sLatlng || !this.eLatlng)
            return;
        var coords = d3.mouse(this.canvas.node());
        var latlng = this._findLatlngForX(coords[0]);
        this._showDiagramIndicator(latlng, coords[0],coords[1]);


        if (!this._marker) {
            var iconUrl = LW.defaultIconPath() + this.options.iconUrl;
            this._marker = new L.Marker(latlng, {icon: new L.Icon({iconUrl: iconUrl, iconAnchor: L.point(12, 32)})})
                .addTo(this._map);
        } else {
            this._marker.setLatLng(latlng);
        }

    },
    _mouseoutHandler: function () {
        if (this._marker) {
            this._map.removeLayer(this._marker);
            this._marker = null;
        }
        this._focusG.style("visibility", "hidden");
    },

    _findLatlngForX: function (x) {
        var latlng1 = this.sLatlng;
        var latlng2 = this.eLatlng;
        var scale = x / this._width();
        var lat = latlng1.lat + (latlng2.lat - latlng1.lat) * scale;
        var lng = latlng1.lng + (latlng2.lng - latlng1.lng) * scale;
        return [lat, lng];
    },

    _showDiagramIndicator: function (latlng, x, y) {
        var index = Sun.Util.Math.toFixed(y / this._yTick, 0);
        var height = this.data ? this.data.yaxis[index] : '';

        this._focusG.style("visibility", "visible");
        this._mousefocus.attr('x1', x)
            .attr('y1', 0)
            .attr('x2', x)
            .attr('y2', this._height())
            .classed('hidden', false);

        var text = Sun.Util.Math.toFixed(latlng[0], 2) + ',' +
            Sun.Util.Math.toFixed(latlng[1], 2) + ' 高:' + height + 'km';
        var width = Sun.Util.Common.getTextWidth ? (Sun.Util.Common.getTextWidth(text)-20) : 140;
        this._focuslabelY.attr("y", 15)
            .attr("x", x > this._width() / 2 ? x - width : x + 2)
            .text(text);
        this._focuslabelY2.attr("y", 15)
            .attr("x", x > this._width() / 2 ? x - width : x + 2)
            .text(text);
    }
});


/**
 * @module Layer.Plot
 */

/**
 * 交通气象图层
 *
 * Features :
 *      1. 根据网格数据或站点数据展示道路上的气象信息
 *      2. 可以获得分段的道路信息
 *      3. 展示原理：
 *          (1) 将道路数据按给定的最小公里(默认1公里)分段，然后在每段的中间用双线性插值算出值表示这一段。
 *          (2) 不用网格数据直接映射的原因是道路是一条线，不是个区域，若网格映射可能导致地图缩小后一个线上的点即可对应多个网格
 *          (3) 若道路是区域，可直接用LW.GridLayer,将道路区域作为遮罩展示即可
 * Update Note：
 *      + v1.1.0 : Created
 *      + v1.5.4 : 增加可以直接设置geo数据的功能
 *
 *
 * @class LW.TrafficLayer
 * @extends LW.CanvasLayer
 * @demo demo/plot/traffic.html  {网格数据}
 */
LW.TrafficLayer = LW.CanvasLayer.extend({
    options: {
        renderer: L.canvas(),
        lineWidth: 3,
        /**
         * 是否数据为网格数据
         * @property sourceGrid
         * @type {boolean}
         * @default false
         */
        sourceGrid: true,
        valueScale: 1,
        /**
         * 插值的最小公里数
         * @property minKm
         * @type {number}
         * @default 0.5
         */
        minKm: 0.5,
        gradient: true,
        legendData:[],
        dataType:'json'
    },

    initialize: function (pathData,  options) {
        L.setOptions(this, options);
        this.pathData = pathData;
        this.gridModel = new LW.GridModel({dataType:this.options.dataType});
        if (!this.options.sourceGrid)
            this._setContourModel();
    },

    _setContourModel: function () {
        if (this.options.bounds) {
            this.contourModel = new LW.ContourModel();
            this.contourModel.setGridBounds(this.options.bounds, this.options.columns, this.options.rows);
        }
    },

    _getDiscreteData: function (data, valueField) {
        var discreteData = [];
        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            var value = item[valueField];
            if (!isNaN(value) && value != null && item['STATIONLAT'] != null && item['STATIONLON'] != null) {
                var dValue = value * this.options.valueScale;
                var dItem = {lat: item['STATIONLAT'], lng: item['STATIONLON'], value: dValue};
                discreteData.push(dItem);
            }
        }
        return discreteData;
    },

    /**
     * 设置数据，可设置网格或站点数据（站点将被插值成格点），但数据源需与sourceGrid属性相匹配
     * @method setData
     * @param data {Array} 数据源，需要叠加再道路上的气象、预警等数据
     * @param pathData {Array} 道路数据,初始后道路无变化，可传null
     * @param legendData {Array} 图例数据
     * @param valueField {string} 值字段名，在站点数据时使用
     */
    setData: function (data, pathData, legendData, valueField) {
        var gridData;
        if(!this.options.sourceGrid){
            if (data && data.length > 2) {
                var discreteData = this._getDiscreteData(data, valueField);
                // 插值
                if (discreteData.length > 2) {
                    this.contourModel.interpolate(discreteData);
                    gridData = this.contourModel.getGridValueData();
                }
            }
        }
        else
            gridData = data;
        if(gridData) this.gridModel.setData(gridData);
        if(pathData) this.pathData = pathData;
        if(legendData) this.options.legendData = legendData;
        this.data = this._roadInterpolate();
        this._reset();
    },

    /**
     * 直接设置geo数据
     * @method setGeoData
     * @param data [Array] 非渐变：{latlngs:[[lng,lat],...],value:10},options.gradient需要配置成false
     *                      渐变：{latlngs:[[lng,lat],...],start:10,end:12},options.gradient需要配置成true
     * @param legendData
     */
    setGeoData:function (data,legendData){
        if(legendData) this.options.legendData = legendData;
        this.data = {geoData:data};
        this._reset();
    },

    _roadInterpolate: function () {
        var geoData = [], listData = [], self = this;
        for (var i = 0; i < this.pathData.length; i++) {
            var item = this.pathData[i].geometry;
            var properties = this.pathData[i].properties;
            var coordinates = item.coordinates;
            if(item.type === 'LineString')
                setItem(coordinates);
            else{
                for (var j = 0; j < coordinates.length; j++) {
                    setItem(coordinates[j],properties.name || properties.NAME);
                }
            }
        }
        return {geoData: geoData, listData: listData};

        function setItem(points,name) {
            var sectionKm = 0, legendIndex = -1;
            var prevPoint = points[0];
            for (var m = 1; m < points.length; m++) {
                // 路段数据
                if (sectionKm === 0) {
                    var traffic = {latlngs: [prevPoint]};
                    geoData.push(traffic);
                }
                sectionKm += L.latLng(prevPoint[1], prevPoint[0]).distanceTo([points[m][1], points[m][0]]) / 1000;
                traffic.latlngs.push(points[m]);
                self._setSegmentValue(traffic);
                if (sectionKm > self.options.minKm)
                    sectionKm = 0;
                prevPoint = points[m];
                // 列表天气描述
                var index = Sun.Util.LegendData.getColorIndex(self.options.legendData, traffic.value);
                if (legendIndex < index)
                    legendIndex = index;
            }
            listData.push({name: name, legendIndex: legendIndex});
        }
    },

    _setSegmentValue: function (segment) {
        // 取该段中点在网格数据中的值
        var gridModel = this.gridModel;
        if(this.options.gradient){
            var p1 = segment.latlngs[0], p2 = segment.latlngs[segment.latlngs.length-1];
            segment.start = gridModel.getInterpolation(p1[1], p1[0]);
            segment.end = gridModel.getInterpolation(p2[1], p2[0]);
        }
        else{
            var index = Math.floor(segment.latlngs.length / 2);
            var latlng = segment.latlngs[index];
            segment.value = gridModel.getInterpolation(latlng[1], latlng[0]);
        }
    },



    /**
     * 获取分段道路气象信息列表
     * @returns {Array} [{legendIndex:-1,name:'G70福银高速_永寿县'}]
     */
    getListData: function () {
        return this.data ? this.data.listData : [];
    },

    clear: function () {
        var size = this._renderer._bounds.getSize();
        this._renderer._ctx.clearRect(0, 0, size.x, size.y);
    },

    _reset: function () {
        this.size = this._renderer._bounds.getSize();
        this._update();
    },

    _update: function () {
        this.clear();
        if (this.data) {
            var ctx = this._renderer._ctx;
            var geoData = this.data.geoData;
            var options = this.options;
            for (var i = 0; i < geoData.length; i++) {
                var item = geoData[i];
                ctx.beginPath();
                ctx.lineWidth = this.options.lineWidth;
                ctx.lineJoin = "round";
                for (var j = 0; j < item.latlngs.length; j++) {
                    var pj = this._map.latLngToLayerPoint([item.latlngs[j][1], item.latlngs[j][0]]);
                    ctx[j===0?'moveTo':'lineTo'](pj.x, pj.y);
                    if(options.gradient && j>0){
                        var pj0 = this._map.latLngToLayerPoint([item.latlngs[j-1][1], item.latlngs[j-1][0]]);
                        var gradient = ctx.createLinearGradient(pj0.x, pj0.y, pj.x, pj.y);
                        gradient.addColorStop(0, getColor(item.start));
                        gradient.addColorStop(1, getColor(item.end));
                        ctx.strokeStyle = gradient;
                        ctx.stroke();
                    }
                }
                if(!options.gradient){
                    ctx.strokeStyle = getColor(item.value);
                    ctx.stroke();
                }
            }

            this._renderer.setMask();
        }

        function getColor(value) {
            return Sun.Util.LegendData.getColorOfRangeLegend(options.legendData, value)
        }
    },

    _containsPoint: L.Util.falseFn
});

/**
 * @class LW.TrafficLayer
 * @constructor
 * @param roadData {Array} 道路数据
 * @param options {object} 外部属性，可重设Properties
 * @returns {LW.TrafficLayer}
 */
LW.trafficLayer = function (roadData, options) {
    return new LW.TrafficLayer(roadData, options);
};

/*
 * Extends L.Map to synchronize the interaction on one map to one or more other maps.
 */

(function () {
    'use strict';

    L.Map = L.Map.extend({
        sync: function (map, options) {
            this._initSync();
            options = options || {};

            // prevent double-syncing the map:
            var present = false;
            this._syncMaps.forEach(function (other) {
                if (map === other) {
                    present = true;
                }
            });

            if (!present) {
                this._syncMaps.push(map);
            }

            if (!options.noInitialSync) {
                map.setView(this.getCenter(), this.getZoom(), {
                    animate: false,
                    reset: true
                });
            }
            return this;
        },

        // unsync maps from each other
        unsync: function (map) {
            var self = this;

            if (this._syncMaps) {
                this._syncMaps.forEach(function (synced, id) {
                    if (map === synced) {
                        self._syncMaps.splice(id, 1);
                    }
                });
            }

            return this;
        },

        // overload methods on originalMap to replay on _syncMaps;
        _initSync: function () {
            if (this._syncMaps) {
                return;
            }
            var originalMap = this;

            this._syncMaps = [];

            L.extend(originalMap, {
                setView: function (center, zoom, options, sync) {
                    if (!sync) {
                        originalMap._syncMaps.forEach(function (toSync) {
                            toSync.setView(center, zoom, options, true);
                        });
                    }
                    return L.Map.prototype.setView.call(this, center, zoom, options);
                },

                panBy: function (offset, options, sync) {
                    if (!sync) {
                        originalMap._syncMaps.forEach(function (toSync) {
                            toSync.panBy(offset, options, true);
                        });
                    }
                    return L.Map.prototype.panBy.call(this, offset, options);
                },

                _onResize: function (event, sync) {
                    if (!sync) {
                        originalMap._syncMaps.forEach(function (toSync) {
                            toSync._onResize(event, true);
                        });
                    }
                    return L.Map.prototype._onResize.call(this, event);
                }
            });

            // originalMap.on('zoomend', function () {
            // originalMap._syncMaps.forEach(function (toSync) {
            //     toSync.setView(originalMap.getCenter(), originalMap.getZoom(), {
            //         animate: false,
            //         reset: false
            //     });
            // });
            // }, this);

            originalMap.dragging._draggable._updatePosition = function () {
                L.Draggable.prototype._updatePosition.call(this);
                var self = this;
                originalMap._syncMaps.forEach(function (toSync) {
                    L.DomUtil.setPosition(toSync.dragging._draggable._element, self._newPos);
                    // toSync.eachLayer(function (l) {
                    //     if (l._google !== undefined) {
                    //         l._google.setCenter(originalMap.getCenter());
                    //     }
                    // });
                    // toSync.fire('moveend');
                });
            };
            originalMap.dragging._draggable._onUp = function (e) {
                L.Draggable.prototype._onUp.call(this,e);
                originalMap._syncMaps.forEach(function (toSync) {
                    toSync.fire('moveend');
                });
            };
        }
    });
})();
